<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>The solve function ¬∑ HomotopyContinuation.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="HomotopyContinuation.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">HomotopyContinuation.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Solving polynomial systems</span><ul><li class="is-active"><a class="tocitem" href>The solve function</a><ul class="internal"><li><a class="tocitem" href="#Basic-usage-1"><span>Basic usage</span></a></li><li><a class="tocitem" href="#Result-1"><span>Result</span></a></li><li><a class="tocitem" href="#Analyse-a-Result-1"><span>Analyse a Result</span></a></li><li><a class="tocitem" href="#Estimate-the-computational-complexity-1"><span>Estimate the computational complexity</span></a></li></ul></li><li><a class="tocitem" href="../solver/">The Solver struct</a></li></ul></li><li><a class="tocitem" href="../monodromy/">Solving parametrized systems with monodromy</a></li><li><a class="tocitem" href="../input/">Input</a></li><li><span class="tocitem">Tracking paths</span><ul><li><a class="tocitem" href="../path_tracker/">Path Tracker</a></li><li><a class="tocitem" href="../core_tracker/">Core Tracker</a></li></ul></li><li><a class="tocitem" href="../homotopies/">Homotopies</a></li><li><a class="tocitem" href="../systems/">Polynomial systems</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Solving polynomial systems</a></li><li class="is-active"><a href>The solve function</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>The solve function</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaHomotopyContinuation/HomotopyContinuation.jl/blob/master/docs/src/solving.md" title="Edit on GitHub"><span class="docs-icon fab">ÔÇõ</span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="The-solve-function-1"><a class="docs-heading-anchor" href="#The-solve-function-1">The solve function</a><a class="docs-heading-anchor-permalink" href="#The-solve-function-1" title="Permalink"></a></h1><p>The <a href="#HomotopyContinuation.solve"><code>solve</code></a> function is the most convenient way to solve general polynomial systems. For the mathematical background take a look at our <a href="https://www.juliahomotopycontinuation.org/guides/introduction/">introduction</a> guide.</p><h2 id="Basic-usage-1"><a class="docs-heading-anchor" href="#Basic-usage-1">Basic usage</a><a class="docs-heading-anchor-permalink" href="#Basic-usage-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.solve" href="#HomotopyContinuation.solve"><code>HomotopyContinuation.solve</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solve(args...; options...)::Result</code></pre><p>The solve function takes many different arguments and options depending on your specific situation, but in the end it always returns a <a href="#HomotopyContinuation.Result"><code>Result</code></a> containing the result of the computations. Depending on the prodived arguments different kind of homotopies are constructed. In particular it is possible to construct the following homotopies:</p><ul><li>Total degree homotopy</li><li>Polyhedral homotopy</li><li>Parameter homotopy</li><li>Multi-homogeneous homotopy</li><li>Start target homotopy</li></ul><p>If the input is a <em>homogeneous</em> polynomial system, solutions in projective space are computed. Otherwise affine solutions are computed.</p><p><strong>Options</strong></p><p>The <code>solve</code> routines takes many different options. In particular all options to <a href="../core_tracker/#HomotopyContinuation.CoreTracker"><code>CoreTracker</code></a> and <a href="../path_tracker/#HomotopyContinuation.PathTracker"><code>PathTracker</code></a> are allowed. Additionally the following options are allowed:</p><ul><li><code>affine_tracking::Bool=true</code>: Indicate whether path tracking should happen in affine space.</li><li><code>early_stop_cb</code>: Here it is possible to provide a function (or any callable struct) which accepts a <code>PathResult</code> <code>r</code> as input and returns a <code>Bool</code>. If <code>early_stop_cb(r)</code> is <code>true</code> then no further paths are tracked and the computation is finished. This is only called for successfull paths unless <code>save_all_paths</code> is <code>true</code>. This is for example useful if you only want to compute one solution of a polynomial system. For this <code>early_stop_cb = _ -&gt; true</code> would be sufficient.</li><li><code>homotopy::AbstractHomotopy</code>: A constructor to construct a <a href="../homotopies/#HomotopyContinuation.AbstractHomotopy"><code>AbstractHomotopy</code></a> for the totaldegree and start target homotopy. The default is <a href="../homotopies/#HomotopyContinuation.StraightLineHomotopy"><code>StraightLineHomotopy</code></a>. The constructor is called with <code>homotopy(start, target)</code> where <code>start</code> and <code>target</code> are homogeneous <a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a>s.</li><li><code>homvar::Union{Int,MultivariatePolynomials.AbstractVariable}</code>: This considers the <em>homogeneous</em> system <code>F</code> as an affine system which was homogenized by <code>homvar</code>. If <code>F</code> is an <code>AbstractSystem</code> <code>homvar</code> is the index (i.e. <code>Int</code>) of the homogenization variable. If <code>F</code> is an <code>AbstractVariables</code> (e.g. created by <code>@polyvar x</code>) <code>homvar</code> is the actual variable used in the system <code>F</code>.</li><li><code>path_jumping_check::Bool=true</code>: Enable a check whether one of the paths jumped to another one.</li><li><code>path_result_details=:default</code>: The amount of information computed in each path result. Possible values are <code>:minimal</code> (minimal details), <code>:default</code> (default) and <code>:extensive</code>.</li><li><code>projective_tracking::Bool=false</code>: Indicate whether path tracking should happen in projective space. The flag <code>affine_tracking</code> is dominant.</li><li><code>seed</code>: The random seed used during the computations. The seed is also reported in the result. For a given random seed the result is always identical.</li><li><code>show_progress</code> (default <code>true</code>): Whether a progress bar should be printed to report the progress of the current computation.</li><li><code>system::AbstractSystem</code>: A constructor to assemble a <a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a>. The default is <a href="../systems/#HomotopyContinuation.SPSystem"><code>SPSystem</code></a>. This constructor is only applied to the input of <code>solve</code>. The constructor is called with <code>system(polynomials, variables)</code> where <code>polynomials</code> is a vector of <code>MultivariatePolynomials.AbstractPolynomial</code>s and <code>variables</code> determines the variable ordering. If you experience significant compilation times, consider to change system to <code>FPSystem</code>.</li><li><code>system_scaling</code> (default <code>:equations</code>) Whether to apply an automatic scaling of the equations (:equations), of the equations and variables (<code>:equations_and_variables</code>) or no scaling at all (<code>nothing</code>).</li><li><code>threading</code> (default <code>true</code>): Enable or disable multi-threading. The number of threads used is controlled by the environment variable <code>JULIA_NUM_THREADS</code>.</li><li><code>variable_ordering</code>: Provide a custom ordering of the variables.</li></ul><p><strong>Examples</strong></p><p><strong>Total Degree Homotopy</strong></p><pre><code class="language-none">solve(F; options...)</code></pre><p>Solve the system <code>F</code> using a start system computed from the degrees of the entries of <code>F</code>. The number of paths to track is equal to the total degree <code>d‚ÇÅ‚ãØd‚±º</code>, where <code>d·µ¢</code> is the degree of the <code>i</code>th entry of <code>F</code>. <code>F</code> can be</p><ul><li><code>Vector{&lt;:MultivariatePolynomials.AbstractPolynomial}</code> (e.g. constructed by using the exported <code>@polyvar</code>)</li><li>A composition of polynomial systems constructed by <a href="../reference/#HomotopyContinuation.compose"><code>compose</code></a></li><li>Any <a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a></li></ul><p>We can solve the system <span>$F(x,y) = (x^2+y^2+1, 2x+3y-1)$</span> in the following way:</p><pre><code class="language-julia">julia&gt; @polyvar x y;
julia&gt; solve([x^2+y^2+1, 2x+3y-1])
Result with 2 solutions
==================================
‚Ä¢ 2 non-singular solutions (0 real)
‚Ä¢ 0 singular solutions (0 real)
‚Ä¢ 2 paths tracked
‚Ä¢ random seed: 661766</code></pre><p><strong>Polyhedral Homotopy</strong></p><pre><code class="language-none">solve(F; start_system = :polyhedral, only_torus=false, options...)</code></pre><p>Solve the system <code>F</code> using a start system computed from the Newton Polytopes of the ntries <code>F</code>. The number of paths to track is equal to the mixed volume of the Newton Polytopes of the entries of <code>F</code>. The mixed volume is at most the total degree of <code>F</code>. <code>F</code> can be</p><ul><li><code>Vector{&lt;:MultivariatePolynomials.AbstractPolynomial}</code> (e.g. constructed by <code>@polyvar</code>)</li><li>A composition of polynomial systems constructed by <a href="../reference/#HomotopyContinuation.compose"><code>compose</code></a>. Note that the composition will not preserved.</li></ul><p>If <code>only_torus == true</code> then only solutions in the algebraic torus <span>$(‚ÑÇ\setminus \{0\})^n$</span> will be computed.</p><p>We can solve the system <span>$F(x,y) = (x^2+y^2+1, 2x+3y-1)$</span> in the following way:</p><pre><code class="language-julia">julia&gt; @polyvar x y;
julia&gt; solve([x^2+y^2+1, 2x+3y-1]; start_system = :polyhedral)
Result with 2 solutions
==================================
‚Ä¢ 2 non-singular solutions (0 real)
‚Ä¢ 0 singular solutions (0 real)
‚Ä¢ 2 paths tracked
‚Ä¢ random seed: 222880</code></pre><p><strong>Parameter Homotopy</strong></p><pre><code class="language-none">solve(F, startsolutions;
    parameters,
    start_parameters,
    target_parameters,
    start_gamma = nothing,
    target_gamma = nothing,
)</code></pre><p>Solve the parameter homotopy</p><div>\[H(x, t) = F(x, \frac{tŒ≥‚ÇÅp‚ÇÅ+(1-t)Œ≥‚ÇÄp‚ÇÄ}{tŒ≥‚ÇÅ+(1-t)Œ≥‚ÇÄ}),\]</div><p>where <span>$p‚ÇÅ$</span> (=<code>start_parameters</code>) and <span>$p‚ÇÄ$</span> (=<code>target_parameters</code>) are vectors of parameter values for <span>$F$</span> and <span>$Œ≥‚ÇÅ$</span> (=<code>start_gamma</code>) and <span>$Œ≥‚ÇÄ$</span> (=<code>target_gamma</code>)     are complex numbers. If <code>start_parameters</code> or <code>target_parameters</code> is <code>nothing</code>, it is assumed that <code>Œ≥‚ÇÄ=Œ≥‚ÇÅ=1</code>. The input <code>parameters</code> specifies the variables of <code>F</code> which should be considered as parameters. Necessarily we have <code>length(parameters) == length(p‚ÇÅ) == length(p‚ÇÄ)</code>.</p><pre><code class="language-none">solve(F, startsolutions; parameters, p‚ÇÅ, p‚ÇÄ, Œ≥‚ÇÅ=nothing, Œ≥‚ÇÄ=nothing)</code></pre><p>This is a unicode variant where <code>Œ≥‚ÇÅ=start_parameters</code>, <code>Œ≥‚ÇÄ=target_parameters</code>,     <code>Œ≥‚ÇÅ=start_gamma</code>, Œ≥‚ÇÄ=<code>target_gamma</code>.</p><p>We want to solve a parameter homotopy <span>$H(x,t) := F(x; t[1, 0]+(1-t)[2, 4])$</span> where</p><div>\[F(x; a) := (x‚ÇÅ^2-a‚ÇÅ, x‚ÇÅx‚ÇÇ-a‚ÇÅ+a‚ÇÇ)\]</div><p>and let&#39;s say we are only intersted in tracking of <span>$[1,1]$</span>. This can be accomplished as follows</p><pre><code class="language-julia">@polyvar x[1:2] a[1:2]
F = [x[1]^2-a[1], x[1]*x[2]-a[1]+a[2]]
startsolutions = [[1, 1]]
p‚ÇÅ = [1, 0]
p‚ÇÄ = [3im, 0.5+2im]
solve(F, startsolutions; parameters=a, start_parameters=p‚ÇÅ, target_parameters=p‚ÇÄ)
# If you like unicode this is also possible
solve(F, startsolutions; parameters=a, p‚ÇÅ=p‚ÇÅ, p‚ÇÄ=p‚ÇÄ)</code></pre><p><strong>Start Target Homotopy</strong></p><pre><code class="language-none">solve(G, F, start_solutions; options...)</code></pre><p>This constructs the homotopy <span>$H(x,t) = tG(x)+(1-t)F(x)$</span> to compute solutions of the system <code>F</code>. <code>start_solutions</code> is a list of solutions of <code>G</code> which are tracked to solutions of <code>F</code>.</p><pre><code class="language-julia">@polyvar x y
G = [x^2-1,y-1]
F = [x^2+y^2+z^2, 2x+3y-z]
solve(G, F, [[1, 1], [-1, 1]])</code></pre><p><strong>Homogeneous Systems</strong></p><p>If <code>F</code> has is homogeneous, we return results in projective space</p><pre><code class="language-julia">julia&gt; @polyvar x y z;
julia&gt; solve([x^2+y^2+z^2, 2x+3y-z])
Result{PVector{Complex{Float64},1}} with 2 solutions
====================================================
‚Ä¢ 2 non-singular solutions (0 real)
‚Ä¢ 0 singular solutions (0 real)
‚Ä¢ 2 paths tracked
‚Ä¢ random seed: 490575</code></pre><p>It your polynomial system is not homogeneous, you can homogenize it as follows</p><pre><code class="language-julia">@polyvar x y
g = [x^2+y^2+1, 2x+3y-1]
f = homogenize(g)</code></pre><p>It is also possible to specify the homogenizing variable.</p><pre><code class="language-julia">@polyvar x y z
g = [x^2+y^2+1, 2x+3y-1]
f = homogenize(g, z)</code></pre><p>If your polynomial system is already homogeneous, but you would like to consider it as an affine system you can do</p><pre><code class="language-julia">@polyvar x y z
solve([x^2+y^2+z^2, 2x+3y-z], homvar=z)</code></pre><p>This yields the same result as <code>solve([x^2+y^2+1, 2x+3y-1])</code>.</p><p><strong>Multi-homogeneous Systems</strong></p><p>By exploiting the multi-homogeneous structure of a polynomial system it is possible to decrease the number of paths necessary to track.</p><pre><code class="language-julia">@polyvar x y
# Use variable groups to only track 2 paths instead of 4
solve([x*y - 6, x^2 - 5], variable_groups=[(x,), (y,)])</code></pre><p>To check whether a certain variable grouping is beneficial you can use the <a href="#HomotopyContinuation.bezout_number"><code>bezout_number</code></a> function.</p><p><strong>Abstract Homotopy</strong></p><pre><code class="language-none">solve(H::AbstractHomotopy, start_solutions; options...)</code></pre><p>Solve the homotopy <code>H</code> by tracking the each solution of <span>$H(‚ãÖ, t)$</span> (as provided by <code>start_solutions</code>) from <span>$t=1$</span> to <span>$t=0$</span>.</p><p><strong>Many parameters</strong></p><pre><code class="language-none">solve(
    F, start_solutions;
    start_parameters = ...,
    target_parameters = ..., # multiple parameters
    options...,
    many_parameters_options...
)</code></pre><p>Solve the system paramterized system <code>F</code> for many different target parameters. If no further options are specified (resp. only those which are explained above) then the result of this funciton is similar to</p><pre><code class="language-none">map(params) do p
    res = solve(F, S; start_parameters = start_params, target_parameters = p, options...)
    (res, p)
end</code></pre><p>Note if <code>threading = true</code> then the parallelization is done on a parameter by parameter basis (and not as above on a path by path basis). Note that order of the results is not guaranteed. The <code>many_parameters_options</code> allow to apply transformations on the results</p><p><strong>Many parameter options</strong></p><ul><li><code>flatten::Bool</code>: Flatten the output of <code>transform_result</code>. This is useful for example if <code>transform_result</code> returns a vector of solutions, and you only want a single vector of solutions as the result (instead of a vector of vector of solutions).</li><li><code>transform_parameters::Function</code>: Transform a parameters values <code>p</code> before passing it to <code>target_parameters = ...</code>. By default this <code>identity</code>.</li><li><code>transform_result::Function</code>: A function taking two arguments, the <code>result</code> and the parameters <code>p</code>. By default this returns the tuple <code>(result, p)</code>.</li></ul><p><strong>Many parameter examples</strong></p><p>We start with some setup. We intersect a circle with a many different lines.</p><pre><code class="language-julia">@polyvar x y
f = x^2 + y^2 - 1

@polyvar a b c
l = a * x + b * y + c
F = [f, l]

# Compute start solutions S‚ÇÄ for given start parameters p‚ÇÄ
p‚ÇÄ = randn(ComplexF64, 3)
S‚ÇÄ = solutions(solve(subs(F, [a, b, c] =&gt; p‚ÇÄ)))
# The parameters we are intersted in
params = [rand(3) for i = 1:100]</code></pre><p>Here are the some examples of the different options.</p><pre><code class="language-julia-repl">julia&gt; result1 = solve(
           F,
           S‚ÇÄ;
           parameters = [a, b, c],
           start_parameters = p‚ÇÄ,
           target_parameters = params,
       );

julia&gt; typeof(result1)
Array{Tuple{Result{Array{Complex{Float64},1}},Array{Float64,1}},1}

julia&gt; result1[1]
(Result{Array{Complex{Float64},1}} with 2 solutions
==================================================
‚Ä¢ 2 non-singular solutions (2 real)
‚Ä¢ 0 singular solutions (0 real)
‚Ä¢ 2 paths tracked
‚Ä¢ random seed: 814544
, [0.6323567622396351, 0.15381245892007867, 0.44070720179305134])

julia&gt; # Only keep real solutions
       result2 = solve(
           F,
           S‚ÇÄ;
           parameters = [a, b, c],
           start_parameters = p‚ÇÄ,
           target_parameters = params,
           transform_result = (r, p) -&gt; real_solutions(r),
       );

julia&gt; typeof(result2)
Array{Array{Array{Float64,1},1},1}

julia&gt; result2[1:3]
3-element Array{Array{Array{Float64,1},1},1}:
 [[-0.4840916699908168, -0.8750172884266356], [-0.831904725657279, 0.554918487193468]]
 [[-0.9979849536743425, 0.06345102236859917], [0.5252178600449688, -0.8509678016762935]]
 [[-0.8602211106475295, 0.5099212103809087], [0.7844127443972155, -0.6202391848530926]]

julia&gt; # Now instead of an Array{Array{Array{Float64,1},1},1} we want to have an
       # Array{Array{Float64,1},1}
       result3 = solve(
           F,
           S‚ÇÄ;
           parameters = [a, b, c],
           start_parameters = p‚ÇÄ,
           target_parameters = params,
           transform_result = (r, p) -&gt; real_solutions(r),
           flatten = true
       );

julia&gt; typeof(result3)
Array{Array{Float64,1},1}

julia&gt; result3[1:3]
3-element Array{Array{Float64,1},1}:
 [-0.4840916699908168, -0.8750172884266356]
 [-0.831904725657279, 0.554918487193468]
 [-0.9979849536743425, 0.06345102236859917]

julia&gt; # The passed `params` do not directly need to be the target parameters.
       # Instead they can be some more concrete informations (e.g. an index)
       # and we can them by using the `transform_parameters` method
       result4 = solve(
           F,
           S‚ÇÄ;
           parameters = [a, b, c],
           start_parameters = p‚ÇÄ,
           target_parameters = 1:100,
           transform_result = (r, p) -&gt; (real_solutions(r), p),
           transform_parameters = _ -&gt; rand(3)
       );

julia&gt; typeof(result4)
Array{Tuple{Array{Array{Float64,1},1},Int64},1}

julia&gt; result4[1:3]
3-element Array{Tuple{Array{Array{Float64,1},1},Int64},1}:
 ([[-0.9459225556889465, -0.3243925378902725], [0.39166252055983675, -0.9201089446303168]], 1)
 ([[-0.838341089344409, 0.5451460519134572], [0.4299213699880814, -0.9028663332008627]], 68)
 ([[-0.8261686468010706, -0.5634229024834612], [-0.19003485030903675, -0.9817773452611452]], 69)</code></pre></div></section></article><h2 id="Result-1"><a class="docs-heading-anchor" href="#Result-1">Result</a><a class="docs-heading-anchor-permalink" href="#Result-1" title="Permalink"></a></h2><p>A call to <a href="#HomotopyContinuation.solve"><code>solve</code></a> returns a <a href="#HomotopyContinuation.Result"><code>Result</code></a>:</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.Result" href="#HomotopyContinuation.Result"><code>HomotopyContinuation.Result</code></a> ‚Äî <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Result{V&lt;:AbstractVector}</code></pre><p>The result of <code>solve</code>. This is a wrapper around the results of each single path (<a href="../path_tracker/#HomotopyContinuation.PathResult"><code>PathResult</code></a>) and it contains some additional informations like a random seed to replicate the result.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.seed" href="#HomotopyContinuation.seed"><code>HomotopyContinuation.seed</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">seed(prob::AbstractProblem)</code></pre><p>Get the random seed used for the problem <code>prob</code>.</p></div></section><section><div><pre><code class="language-none">seed(result)</code></pre><p>The random seed used in the computation.</p></div></section></article><h2 id="Analyse-a-Result-1"><a class="docs-heading-anchor" href="#Analyse-a-Result-1">Analyse a Result</a><a class="docs-heading-anchor-permalink" href="#Analyse-a-Result-1" title="Permalink"></a></h2><p>The nonsingular solutions are obtained as follows.</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.nonsingular" href="#HomotopyContinuation.nonsingular"><code>HomotopyContinuation.nonsingular</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nonsingular(result::Results; conditions...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is non-singular. This is just a shorthand for <code>results(R; only_nonsingular=true, conditions...)</code>. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></section></article><p>The singular solutions are returned by using the following.</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.singular" href="#HomotopyContinuation.singular"><code>HomotopyContinuation.singular</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">singular(R::Results; tol=1e10, multiple_results=false, kwargs...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is singular. A solution is labeled singular if the condition number is greater than <code>singular_tol</code>, or if the winding number is &gt; 1. If <code>multiple_results=false</code> only one point from each cluster of multiple solutions is returned. If If <code>multiple_results=true</code> all singular solutions in <code>R</code> are returned. For the possible <code>kwargs</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></section></article><p>In order to analyse a <code>Result</code> we provide the following additional helper functions</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.results" href="#HomotopyContinuation.results"><code>HomotopyContinuation.results</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">results(result; only_real=false, real_tol=1e-6, only_nonsingular=false,
            onlysigular=false, singular_tol=1e10, onlyfinite=true, multiple_results=false)</code></pre><p>Return all <code>PathResult</code>s for which the given conditions apply.</p><p><strong>Example</strong></p><pre><code class="language-julia">R = solve(F)

# This gives us all PathResults considered non-singular and real (but still as a complex vector).
real_solutions = results(R, only_real=true, only_nonsingular=true)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.mapresults" href="#HomotopyContinuation.mapresults"><code>HomotopyContinuation.mapresults</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mapresults(f::Function, result; conditions...)</code></pre><p>Apply the function <code>f</code> to all <code>PathResult</code>s for which the given conditions apply. For the possible conditions see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia"># This gives us all solutions considered real (but still as a complex vector).
real_solutions = mapresults(solution, R, only_real=true)</code></pre></div></section><section><div><pre><code class="language-none">mapresults(f, result::MonodromyResult; only_real=false, real_tol=1e-6)</code></pre><p>Apply the function <code>f</code> to all entries of <code>MonodromyResult</code> for which the given conditions apply.</p><p><strong>Example</strong></p><pre><code class="language-julia"># This gives us all solutions considered real (but still as a complex vector).
real_solutions = mapresults(solution, R, only_real=true)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.solutions" href="#HomotopyContinuation.solutions"><code>HomotopyContinuation.solutions</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solutions(result; conditions...)</code></pre><p>Return all solution (as <code>Vector</code>s) for which the given conditions apply. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; @polyvar x y
julia&gt; result = solve([(x-2)y, y+x+3]);
julia&gt; solutions(result)
[[2.0+0.0im, -5.0+0.0im], [-3.0+0.0im, 0.0+0.0im]]</code></pre></div></section><section><div><pre><code class="language-julia">solutions(result::MonodromyResult; only_real=false, real_tol=1e-6)</code></pre><p>Return all solutions (as <code>SVector</code>s) for which the given conditions apply.</p><p><strong>Example</strong></p><pre><code class="language-julia">real_solutions = solutions(R, only_real=true)</code></pre></div></section><section><div><pre><code class="language-none">solutions(MS::MonodromySolver)</code></pre><p>Get the solutions of the loop.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.real_solutions" href="#HomotopyContinuation.real_solutions"><code>HomotopyContinuation.real_solutions</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">real_solutions(result; tol=1e-6, conditions...)</code></pre><p>Return all real solution (as <code>Vector</code>s of reals) for which the given conditions apply. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>. Note that <code>only_real</code> is always <code>true</code> and <code>real_tol</code> is now <code>tol</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; @polyvar x y
julia&gt; result = solve([(x-2)y, y+x+3]);
julia&gt; real_solutions(result)
[[2.0, -5.0], [-3.0, 0.0]]</code></pre></div></section><section><div><pre><code class="language-none">real_solutions(res::MonodromyResult; tol=1e-6)</code></pre><p>Returns the solutions of <code>res</code> whose imaginary part has norm less than 1e-6.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.finite" href="#HomotopyContinuation.finite"><code>HomotopyContinuation.finite</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">finite(result::AffineResults; conditions...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is finite. This is just a shorthand for <code>results(R; onlyfinite=true, conditions...)</code>. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="Base.real-Tuple{Union{Array{#s124,1} where #s124&lt;:PathResult, Result}}" href="#Base.real-Tuple{Union{Array{#s124,1} where #s124&lt;:PathResult, Result}}"><code>Base.real</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">real(result, tol=1e-6)</code></pre><p>Get all results where the solutions are real with the given tolerance <code>tol</code>. See <a href="../path_tracker/#HomotopyContinuation.is_real-Tuple{PathResult}"><code>is_real</code></a> for details regarding the determination of &#39;realness&#39;.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.at_infinity" href="#HomotopyContinuation.at_infinity"><code>HomotopyContinuation.at_infinity</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">at_infinity(result::AffineResult)</code></pre><p>Get all results where the solutions is at infinity.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.failed" href="#HomotopyContinuation.failed"><code>HomotopyContinuation.failed</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">failed(result)</code></pre><p>Get all results where the path tracking failed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.multiplicities!-Tuple{Result}" href="#HomotopyContinuation.multiplicities!-Tuple{Result}"><code>HomotopyContinuation.multiplicities!</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">multiplicities!(result::Result; tol=1e-6)</code></pre><p>Compute the multiplicities of the solutions in <code>result</code> with respect to the given tolerance.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.multiplicities-Tuple{Union{Array{#s124,1} where #s124&lt;:PathResult, Result}}" href="#HomotopyContinuation.multiplicities-Tuple{Union{Array{#s124,1} where #s124&lt;:PathResult, Result}}"><code>HomotopyContinuation.multiplicities</code></a> ‚Äî <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">multiplicities(V::Results; tol=1e-6)</code></pre><p>Returns a <code>Vector</code> of <code>Vector{PathResult}</code>s grouping the <code>PathResult</code>s whose solutions appear with multiplicities <em>greater</em> 1 in &#39;V&#39;. Two solutions are regarded as equal, when their pairwise distance is less than &#39;tol&#39;.</p></div></section></article><p>If you are interested in the number of solutions of a certain kind we also provide the following helper functions.</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.nresults" href="#HomotopyContinuation.nresults"><code>HomotopyContinuation.nresults</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nresults(
    result;
    only_real = false,
    real_tol = 1e-6,
    only_nonsingular = false,
    singular_tol = 1e10,
    onlyfinite = true,
)</code></pre><p>The number of solutions which satisfy the corresponding predicates.</p><p><strong>Example</strong></p><pre><code class="language-julia">result = solve(F)
# Get all non-singular results where all imaginary parts are smaller than 1e-8
nresults(result, only_real=true, real_tol=1e-8, only_nonsingular=true)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.nfinite" href="#HomotopyContinuation.nfinite"><code>HomotopyContinuation.nfinite</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nfinite(result)</code></pre><p>The number of finite solutions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.nreal" href="#HomotopyContinuation.nreal"><code>HomotopyContinuation.nreal</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nreal(result; tol=1e-6)</code></pre><p>The number of real solutions where all imaginary parts of each solution are smaller than <code>tol</code>.</p></div></section><section><div><pre><code class="language-none">nreal(res::MonodromyResult; tol=1e-6)</code></pre><p>Counts how many solutions of <code>res</code> have imaginary part norm less than 1e-6.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.nsingular" href="#HomotopyContinuation.nsingular"><code>HomotopyContinuation.nsingular</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nsingular(
    result;
    singular_tol = 1e10,
    multiplicitytol = 1e-5,
    counting_multiplicities = false,
    kwargs...,
)</code></pre><p>The number of singular solutions. A solution is considered singular if its windingnumber is larger than 1 or the condition number is larger than <code>tol</code>. If <code>counting_multiplicities=true</code> the number of singular solutions times their multiplicities is returned.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.nnonsingular" href="#HomotopyContinuation.nnonsingular"><code>HomotopyContinuation.nnonsingular</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nnonsingular(result; tol=1e-10)</code></pre><p>The number of non-singular solutions.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.nat_infinity" href="#HomotopyContinuation.nat_infinity"><code>HomotopyContinuation.nat_infinity</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nat_infinity(result)</code></pre><p>The number of solutions at infinity.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.nfailed" href="#HomotopyContinuation.nfailed"><code>HomotopyContinuation.nfailed</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">nafailed(result)</code></pre><p>The number of failed paths.</p></div></section></article><p>Also make sure to check the documentation for <a href="../path_tracker/#HomotopyContinuation.PathResult"><code>PathResult</code></a>.</p><h2 id="Estimate-the-computational-complexity-1"><a class="docs-heading-anchor" href="#Estimate-the-computational-complexity-1">Estimate the computational complexity</a><a class="docs-heading-anchor-permalink" href="#Estimate-the-computational-complexity-1" title="Permalink"></a></h2><p>We provide methods to compute the number of paths that needs to be tracked.</p><p>For the totaldegree homotopy:</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.bezout_number" href="#HomotopyContinuation.bezout_number"><code>HomotopyContinuation.bezout_number</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">bezout_number(F::MPPolys; variable_groups=[variables(F)], homvars=nothing, parameters=nothing)
bezout_number(multidegrees, groups::VariableGroups)</code></pre><p>Compute the multi-homogeneous bezout number associated to the given system and variable groups.</p></div></section></article><p>For the polyhedral homotopy:</p><article class="docstring"><header><a class="docstring-binding" id="MixedSubdivisions.mixed_volume" href="#MixedSubdivisions.mixed_volume"><code>MixedSubdivisions.mixed_volume</code></a> ‚Äî <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">mixed_volume(F::Vector{&lt;:MP.AbstractPolynomialLike}; show_progress=true, algorithm=:regeneration)
mixed_volume(ùë®::Vector{&lt;:Matrix}; show_progress=true, algorithm=:regeneration)</code></pre><p>Compute the mixed volume of the given polynomial system <code>F</code> resp. represented by the support <code>ùë®</code>. There are two possible values for <code>algorithm</code>:</p><ul><li><code>:total_degree</code>: Use the total degree homotopy algorithm described in Section 7.1</li><li><code>:regeneration</code>: Use the tropical regeneration algorithm described in Section 7.2</li></ul></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../">¬´ Introduction</a><a class="docs-footer-nextpage" href="../solver/">The Solver struct ¬ª</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 2 December 2019 14:14">Monday 2 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
