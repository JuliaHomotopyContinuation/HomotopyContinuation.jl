var documenterSearchIndex = {"docs":
[{"location":"endgame_tracker/#EndgameTracker-1","page":"EndgameTracker","title":"EndgameTracker","text":"","category":"section"},{"location":"endgame_tracker/#","page":"EndgameTracker","title":"EndgameTracker","text":"EndgameTracker is a data structure to track for a given AbstractHomotopy H(xt) a solution x from t₁  0 to 0, i.e.,  H(xt₁) = 0 and x with H(x0) = 0 is returned. This is done by following an implicitly defined path x(t) using Tracker. In contrast to Tracker this also has an endgame to handle diverging paths and singular solutions.","category":"page"},{"location":"endgame_tracker/#","page":"EndgameTracker","title":"EndgameTracker","text":"AbstractPathTracker","category":"page"},{"location":"endgame_tracker/#HomotopyContinuation.AbstractPathTracker","page":"EndgameTracker","title":"HomotopyContinuation.AbstractPathTracker","text":"AbstractPathTracker\n\nSupertype for path trackers.\n\n\n\n\n\n","category":"type"},{"location":"endgame_tracker/#Constructor-and-Options-1","page":"EndgameTracker","title":"Constructor and Options","text":"","category":"section"},{"location":"endgame_tracker/#","page":"EndgameTracker","title":"EndgameTracker","text":"EndgameTracker\nEndgameOptions","category":"page"},{"location":"endgame_tracker/#HomotopyContinuation.EndgameTracker","page":"EndgameTracker","title":"HomotopyContinuation.EndgameTracker","text":"EndgameTracker(tracker::Tracker; options = EndgameOptions())\nEndgameTracker(H::AbstractHomotopy; options = EndgameOptions())\n\nA EndgameTracker combines a Tracker with an endgame. That is, while a Tracker assumes that the solution path is non-singular and convergent, the endgame allows to handle singular endpoints as well as diverging paths. To compute singular solutions the Cauchy endgame used, for divering paths a strategy based on the valuation of local Puiseux series expansion of the path is used. See [BT20] for a detailed description. By convention, a EndgameTracker always tracks from t=1 to t = 0. See EndgameOptions for the possible options.\n\n[BT20]: Breiding, P. and Timme, S. \"Tropical Endgame\", In preparation (2020)\n\n\n\n\n\n","category":"type"},{"location":"endgame_tracker/#HomotopyContinuation.EndgameOptions","page":"EndgameTracker","title":"HomotopyContinuation.EndgameOptions","text":"EndgameOptions(; options...)\n\nOptions controlling the behaviour of a EndgameTracker.\n\nOptions\n\nat_infinity_check = true: Whether divering paths should be truncated.\nendgame_start = 0.1: The point t in time where the endgame starts.\nonly_nonsingular = false: If true don't run the Cauchy endgame to handle singular solutions.\nzero_is_at_infinity = false: Whether paths going to a solution where at least one coordinates is zero should also be considered diverging.\n\nParameters\n\nThese parameters control the behaviour during the endgame. See [BT20] for details.\n\nmin_cond = 1e3: The minimal growth of the condition number after which an endgame strategy is considered to be applied.\nmax_endgame_steps = 2000: The maximal number of steps performed during the endgame.\nmax_winding_number = 12: The maximal winding number which is attempted in the\n\nCauchy endgame.\n\nmin_coord_growth = 100: The minimal relative growth of a coordinate necessary to to be considered going to infininity (resp. zero).\nval_at_infinity_tol = 1e-3: Tolerance on the valuation which has to be satisfied before a path is considered to diverge / go to infinity.\nval_finite_tol = 1e-3: Tolerance on the valuation which has to be satisfied before the Cauchy endgame is started.\n\n[BT20]: Breiding, P. and Timme, S. \"Tropical Endgame\", In preparation (2020)\n\n\n\n\n\n","category":"type"},{"location":"endgame_tracker/#Tracking-1","page":"EndgameTracker","title":"Tracking","text":"","category":"section"},{"location":"endgame_tracker/#","page":"EndgameTracker","title":"EndgameTracker","text":"track(::EndgameTracker, ::AbstractVector, ::Real)","category":"page"},{"location":"endgame_tracker/#HomotopyContinuation.track-Tuple{EndgameTracker,AbstractArray{T,1} where T,Real}","page":"EndgameTracker","title":"HomotopyContinuation.track","text":"track(endgame_tracker::EndgameTracker, x::AbstractVector, t::Real = 1.0;\n      path_number = nothing, debug = false)\n\nTrack the given start solution x from t towards 0 using the given endgame_tracker. Returns a PathResult.\n\ntrack(endgame_tracker::EndgameTracker, r::PathResult, t::Real = 1.0;\n      path_number = nothing, debug = false)\n\nTrack solution(r) from t towards 0 using the given endgame_tracker.\n\n\n\n\n\n","category":"method"},{"location":"start_systems/#Start-Systems-1","page":"Start systems","title":"Start Systems","text":"","category":"section"},{"location":"start_systems/#Total-Degree-1","page":"Start systems","title":"Total Degree","text":"","category":"section"},{"location":"start_systems/#","page":"Start systems","title":"Start systems","text":"total_degree","category":"page"},{"location":"start_systems/#HomotopyContinuation.total_degree","page":"Start systems","title":"HomotopyContinuation.total_degree","text":"total_degree(\n    F::System;\n    parameters = nothing,\n    gamma = cis(2π * rand()),\n    tracker_options = TrackerOptions(),\n    endgame_options = EndgameOptions(),\n)\n\nSolve the system F using a total degree homotopy. This returns a path tracker (EndgameTracker or OverdeterminedTracker) and an iterator to compute the start solutions. If the system F has declared variable_groups then a multi-homogeneous a start system following [Wam93] will be constructed.\n\n[Wam93]: An efficient start system for multi-homogeneous polynomial continuation, Wampler, C.W. Numer. Math. (1993) 66: 517. https://doi.org/10.1007/BF01385710\n\n\n\n\n\n","category":"function"},{"location":"start_systems/#Mixed-Volume-(Polyhedral-Homotopy)-1","page":"Start systems","title":"Mixed Volume (Polyhedral Homotopy)","text":"","category":"section"},{"location":"start_systems/#","page":"Start systems","title":"Start systems","text":"polyhedral\nPolyhedralTracker","category":"page"},{"location":"start_systems/#HomotopyContinuation.polyhedral","page":"Start systems","title":"HomotopyContinuation.polyhedral","text":"polyhedral(F::Union{System, AbstractSystem};\n    only_non_zero = false,\n    endgame_options = EndgameOptions(),\n    tracker_options = TrackerOptions())\n\nSolve the system F in two steps: first solve a generic system derived from the support of F using a polyhedral homotopy as proposed in [HS95], then perform a coefficient-parameter homotopy towards F. This returns a path tracker (PolyhedralTracker or OverdeterminedTracker) and an iterator to compute the start solutions.\n\nIf only_non_zero is true, then only the solutions with non-zero coordinates are computed. In this case the number of paths to track is equal to the mixed volume of the Newton polytopes of F.\n\nIf only_non_zero is false, then all isolated solutions of F are computed. In this case the number of paths to track is equal to the mixed volume of the convex hulls of supp(F_i)  0 where supp(F_i) is the support of F_i. See also [LW96].\n\nfunction polyhedral(\n    support::AbstractVector{<:AbstractMatrix},\n    coefficientss::AbstractVector{<:AbstractVector{<:Number}};\n    kwargs...,\n)\n\nIt is also possible to provide directly the support and coefficients of the system F to be solved.\n\n[HS95]: Birkett Huber and Bernd Sturmfels. “A Polyhedral Method for Solving Sparse Polynomial Systems.” Mathematics of Computation, vol. 64, no. 212, 1995, pp. 1541–1555\n\n[LW96]: T.Y. Li and Xiaoshen Wang. \"The BKK root count in C^n\". Math. Comput. 65, 216 (October 1996), 1477–1484.\n\nExample\n\nWe consider a system f which has in total 6 isolated solutions, but only 3 where all coordinates are non-zero.\n\n@var x y\nf = System([2y + 3 * y^2 - x * y^3, x + 4 * x^2 - 2 * x^3 * y])\ntracker, starts = polyhedral(f; only_non_zero = false)\n# length(starts) == 8\ncount(is_success, track.(tracker, starts)) # 6\n\ntracker, starts = polyhedral(f; only_non_zero = true)\n# length(starts) == 3\ncount(is_success, track.(tracker, starts)) # 3\n\n\n\n\n\n","category":"function"},{"location":"start_systems/#HomotopyContinuation.PolyhedralTracker","page":"Start systems","title":"HomotopyContinuation.PolyhedralTracker","text":"PolyhedralTracker <: AbstractPathTracker\n\nThis tracker realises the two step approach of the polyhedral homotopy. See also [polyhedral].\n\n\n\n\n\n","category":"type"},{"location":"start_systems/#Overdetermined-1","page":"Start systems","title":"Overdetermined","text":"","category":"section"},{"location":"start_systems/#","page":"Start systems","title":"Start systems","text":"OverdeterminedTracker\nsquare_up\nexcess_solution_check!\nexcess_solution_check","category":"page"},{"location":"start_systems/#HomotopyContinuation.OverdeterminedTracker","page":"Start systems","title":"HomotopyContinuation.OverdeterminedTracker","text":"OverdeterminedTracker(tracker::AbstractPathTracker, F::RandomizedSystem)\n\nWraps the given AbstractPathTracker tracker to apply excess_solution_check for the given randomized system F on each path result.\n\n\n\n\n\n","category":"type"},{"location":"start_systems/#HomotopyContinuation.square_up","page":"Start systems","title":"HomotopyContinuation.square_up","text":"square_up(F::Union{System, AbstractSystem})\n\nCreates the RandomizedSystem mathfrakR(F(x) N) where N is the number of variables of F.\n\n\n\n\n\n","category":"function"},{"location":"start_systems/#HomotopyContinuation.excess_solution_check!","page":"Start systems","title":"HomotopyContinuation.excess_solution_check!","text":"excess_solution_check!(path_result::PathResult,\n                       F::RandomizedSystem,\n                       newton_cache = NewtonCache(F.system))\n\nAssigns to the PathResult path_result the return_code :excess_solution if the path_result is a solution of the randomized system F but not of the polynomial system underlying F. This is performed by using Newton's method for non-singular solutions and comparing the residuals of the solutions for singular solutions.\n\n\n\n\n\n","category":"function"},{"location":"start_systems/#HomotopyContinuation.excess_solution_check","page":"Start systems","title":"HomotopyContinuation.excess_solution_check","text":"excess_solution_check(F::RandomizedSystem)\n\nReturns a function λ(::PathResult) which performs the excess solution check. The call excess_solution_check(F)(path_result) is identical to excess_solution_check!(F, path_result). See also excess_solution_check!.\n\n\n\n\n\n","category":"function"},{"location":"result/#Results-1","page":"Results","title":"Results","text":"","category":"section"},{"location":"result/#","page":"Results","title":"Results","text":"A call to solve returns a Result:","category":"page"},{"location":"result/#","page":"Results","title":"Results","text":"Result\nseed(::Result)\npath_results(::Result)","category":"page"},{"location":"result/#HomotopyContinuation.Result","page":"Results","title":"HomotopyContinuation.Result","text":"Result\n\nThe result of solve. This is a wrapper around the results of each single path (PathResult) and it contains some additional information like a random seed to replicate the result.\n\n\n\n\n\n","category":"type"},{"location":"result/#HomotopyContinuation.seed-Tuple{Result}","page":"Results","title":"HomotopyContinuation.seed","text":"seed(::Result)\n\nReturns the seed to replicate the result.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.path_results-Tuple{Result}","page":"Results","title":"HomotopyContinuation.path_results","text":"path_results(::Result)\n\nReturns the stored PathResults.\n\n\n\n\n\n","category":"method"},{"location":"result/#Filtering-results-and-solutions-1","page":"Results","title":"Filtering results and solutions","text":"","category":"section"},{"location":"result/#","page":"Results","title":"Results","text":"results\nsolutions\nBase.real(::Result)\nreal_solutions\nnonsingular\nsingular\nat_infinity\nfailed","category":"page"},{"location":"result/#HomotopyContinuation.results","page":"Results","title":"HomotopyContinuation.results","text":"results(\n    result;\n    only_real = false,\n    real_tol = 1e-6,\n    only_nonsingular = false,\n    only_singular = false,\n    singular_tol = 1e10,\n    only_finite = true,\n    multiple_results = false,\n)\nresults(f, result; options...)\n\nReturn all PathResults for which satisfy the given conditions and apply if provided the function f.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.solutions","page":"Results","title":"HomotopyContinuation.solutions","text":"solutions(result; conditions...)\n\nReturns all solutions for which the given conditions apply, see results for the possible conditions.\n\nExample\n\njulia> @var x y\njulia> F = System([(x-2)y, y+x+3]);\njulia> solutions(solve(F))\n2-element Array{Array{Complex{Float64},1},1}:\n [2.0 + 0.0im, -5.0 + 0.0im]\n [-3.0 + 0.0im, 0.0 + 0.0im]\n\n\n\n\n\n","category":"function"},{"location":"result/#Base.real-Tuple{Result}","page":"Results","title":"Base.real","text":"real(result, tol=1e-6)\n\nGet all results where the solutions are real with the given tolerance tol. See is_real for details regarding the determination of 'realness'.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.real_solutions","page":"Results","title":"HomotopyContinuation.real_solutions","text":"real_solutions(result; tol=1e-6, conditions...)\n\nReturn all real solution for which the given conditions apply. For the possible conditions see results. Note that only_real is always true and real_tol is now tol.\n\nExample\n\njulia> @var x y;\njulia> F = System([(x-2)y, y+x+3]);\njulia> real_solutions(solve(F))\n2-element Array{Array{Float64,1},1}:\n [2.0, -5.0]\n [-3.0, 0.0]\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nonsingular","page":"Results","title":"HomotopyContinuation.nonsingular","text":"nonsingular(result; conditions...)\n\nReturn all PathResults for which the solution is non-singular. This is just a shorthand for results(R; only_nonsingular=true, conditions...). For the possible conditions see results.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.singular","page":"Results","title":"HomotopyContinuation.singular","text":"singular(result; tol=1e10, multiple_results=false, kwargs...)\n\nReturn all [PathResult]s for which the solution is singular. A solution is labeled singular if the condition number is greater than singular_tol, or if the winding number is > 1. If multiple_results=false only one point from each cluster of multiple solutions is returned. If If multiple_results=true all singular solutions in R are returned. For the possible kwargs see results.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.at_infinity","page":"Results","title":"HomotopyContinuation.at_infinity","text":"at_infinity(result)\n\nGet all results where the solutions is at infinity.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.failed","page":"Results","title":"HomotopyContinuation.failed","text":"failed(result)\n\nGet all results where the path tracking failed.\n\n\n\n\n\n","category":"function"},{"location":"result/#Counting-1","page":"Results","title":"Counting","text":"","category":"section"},{"location":"result/#","page":"Results","title":"Results","text":"nresults\nnsolutions\nnreal\nnnonsingular\nnsingular\nnat_infinity\nnexcess_solutions\nnfailed","category":"page"},{"location":"result/#HomotopyContinuation.nresults","page":"Results","title":"HomotopyContinuation.nresults","text":"nresults(\n    result;\n    only_real = false,\n    real_tol = 1e-6,\n    only_nonsingular = false,\n    only_singular = false,\n    singular_tol = 1e10,\n    only_finite = true,\n    multiple_results = false,\n)\n\nCount the number of solutions which satisfy the corresponding conditions. See also results.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nsolutions","page":"Results","title":"HomotopyContinuation.nsolutions","text":"nsolutions(result)\n\nThe number of solutions.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nreal","page":"Results","title":"HomotopyContinuation.nreal","text":"nreal(result; tol=1e-6)\n\nThe number of real solutions. See also is_real.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nnonsingular","page":"Results","title":"HomotopyContinuation.nnonsingular","text":"nnonsingular(result; tol=1e-10)\n\nThe number of non-singular solutions. See also is_singular.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nsingular","page":"Results","title":"HomotopyContinuation.nsingular","text":"nsingular(\n    result;\n    singular_tol = 1e10,\n    counting_multiplicities = false,\n    kwargs...,\n)\n\nThe number of singular solutions. A solution is considered singular if its winding number is larger than 1 or the condition number is larger than tol. If counting_multiplicities=true the number of singular solutions times their multiplicities is returned.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nat_infinity","page":"Results","title":"HomotopyContinuation.nat_infinity","text":"nat_infinity(result)\n\nThe number of solutions at infinity.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nexcess_solutions","page":"Results","title":"HomotopyContinuation.nexcess_solutions","text":"nexcess_solutions(result)\n\nThe number of exess solutions. See also excess_solution_check.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nfailed","page":"Results","title":"HomotopyContinuation.nfailed","text":"nfailed(result)\n\nThe number of failed paths.\n\n\n\n\n\n","category":"function"},{"location":"result/#PathResult-1","page":"Results","title":"PathResult","text":"","category":"section"},{"location":"result/#","page":"Results","title":"Results","text":"PathResult\nsolution(::PathResult)\nis_success(::PathResult)\nis_at_infinity(::PathResult)\nis_excess_solution(::PathResult)\nis_failed(::PathResult)\nis_finite(::PathResult)\nis_singular(::PathResult)\nis_nonsingular(::PathResult)\nis_real(::PathResult)\naccuracy(::PathResult)\nresidual(::PathResult)\nsteps(::PathResult)\naccepted_steps(::PathResult)\nrejected_steps(::PathResult)\nwinding_number(::PathResult)\npath_number(::PathResult)\nstart_solution(::PathResult)\nmultiplicity(::PathResult)\nlast_path_point(::PathResult)\nvaluation(::PathResult)","category":"page"},{"location":"result/#HomotopyContinuation.PathResult","page":"Results","title":"HomotopyContinuation.PathResult","text":"PathResult\n\nA PathResult is the result of tracking of a path with track using an AbstractPathTracker ( e.g. EndgameTracker)\n\nFields\n\nGeneral solution information:\n\nreturn_code: See the list of return codes below.\nsolution::V: The solution vector.\nt::Float64: The value of t at which solution was computed. Note that if return_code is :at_infinity, then t is the value when this was decided.\naccuracy::Float64: An estimate the (relative) accuracy of the computed solution.\nresidual::Float64: The infinity norm of H(solution,t).\ncondition_jacobian::Float64: This is the condition number of the Jacobian at the solution. A high condition number indicates a singular solution or a solution on a positive dimensional component.\nwinding_number:Union{Nothing, Int}: The computed winding number. This is a lower bound on the multiplicity of the solution. It is nothing if the Cauchy endgame was not used.\nextended_precision::Bool: Indicate whether extended precision is necessary to achieve the accuracy of the solution.\npath_number::Union{Nothing,Int}: The number of the path (optional).\nstart_solution::Union{Nothing,V}: The start solution of the path (optional).\n\nPerformance information:\n\naccepted_steps::Int: The number of accepted steps during the path tracking.\nrejected_steps::Int: The number of rejected steps during the path tracking.\nextended_precision_used::Bool: Indicates whether extended precision was necessary to track the path.\n\nAdditional path and solution informations\n\nvaluation::Vector{Float64}: An approximation of the valuation of the Puiseux series expansion of x(t).\nlast_path_point::Tuple{V,Float64}: The last pair (xt) before the solution was computed. If the solution was computed with the Cauchy endgame, then the pair (xt) can be used to rerun the endgame.\n\nReturn codes\n\nPossible return codes are:\n\n:success: The EndgameTracker obtained a solution.\n:at_infinity: The EndgameTracker stopped the tracking of the path since it determined that that path is diverging towards infinity.\n:at_zero: The EndgameTracker stopped the tracking of the path since it determined that that path has a solution where at least one coordinate is 0. This only happens if the option zero_is_at_infinity is true.\n:excess_solution: For the solution of the system, the system had to be modified which introduced artificial solutions and this solution is one of them.\nvarious return codes indicating termination of the tracking\n\n\n\n\n\n","category":"type"},{"location":"result/#HomotopyContinuation.solution-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.solution","text":"solution(r::PathResult)\n\nGet the solution of the path.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_success-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_success","text":"is_success(r::PathResult)\n\nChecks whether the path is successfull.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_at_infinity-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_at_infinity","text":"is_at_infinity(r::PathResult)\n\nChecks whether the path goes to infinity.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_excess_solution-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_excess_solution","text":"is_excess_solution(r::PathResult)\n\nChecks whether the path is successfull.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_failed-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_failed","text":"is_failed(r::PathResult)\n\nChecks whether the path failed.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_finite-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_finite","text":"is_finite(r::PathResult)\n\nChecks whether the path result is finite.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_singular-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_singular","text":"is_singular(r::PathResult; tol::Float64 = 1e10)\n\nChecks whether the path result r is singular. This is true if the winding number is larger than  1 or if the condition number of the Jacobian is larger than tol.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_nonsingular-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_nonsingular","text":"is_nonsingular(r::PathResult; tol::Float64 = 1e10)\n\nChecks whether the path result is non-singular. This is true if it is not singular.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_real-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_real","text":"is_real(r::PathResult; tol::Float64 = 1e-6)\n\nWe consider a result as real if the infinity-norm of the imaginary part of the solution is at most tol.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.accuracy-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.accuracy","text":"accuracy(r::PathResult)\n\nGet the accuracy of the solution. This is an estimate of the (relative) distance to the true solution.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.residual-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.residual","text":"residual(r::PathResult)\n\nGet the residual of the solution.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.steps-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.steps","text":"steps(r::PathResult)\n\nTotal number of steps the path tracker performed.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.accepted_steps-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.accepted_steps","text":"accepted_steps(r::PathResult)\n\nTotal number of steps the path tracker accepted.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.rejected_steps-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.rejected_steps","text":"rejected_steps(r::PathResult)\n\nTotal number of steps the path tracker rejected.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.winding_number-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.winding_number","text":"winding_number(r::PathResult)\n\nGet the winding number of the solution of the path. Returns nothing if it wasn't computed.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.path_number-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.path_number","text":"path_number(r::PathResult)\n\nGet the number of the path. Returns nothing if it wasn't provided.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.start_solution-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.start_solution","text":"start_solution(r::PathResult)\n\nGet the start solution of the path.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.multiplicity-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.multiplicity","text":"multiplicity(r::PathResult)\n\nGet the multiplicity of the solution of the path. Returns nothing if it wasn't computed.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.last_path_point-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.last_path_point","text":"last_path_point(r::PathResult)\n\nReturns a tuple (x,t) containing the last zero of H(x, t) before the Cauchy endgame was used. Returns nothing if the endgame strategy was not invoked.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.valuation-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.valuation","text":"valuation(r::PathResult)\n\nGet the computed valuation of the path.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#ModelKit-1","page":"ModelKit","title":"ModelKit","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"ModelKit is the symbolic input and modeling language of HomotopyContinuation.jl. It is designed such that you can easily create an efficient formulation of your problem.","category":"page"},{"location":"model_kit/#Expressions-and-Variables-1","page":"ModelKit","title":"Expressions and Variables","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"Expression\nVariable\n@var\n@unique_var","category":"page"},{"location":"model_kit/#HomotopyContinuation.ModelKit.Expression","page":"ModelKit","title":"HomotopyContinuation.ModelKit.Expression","text":"Expression <: Number\n\nA symbolic expression.\n\njulia> expr = (Variable(:x) + 1)^2\n(1 + x)^2\n\njulia> Expression(2)\n2\n\njulia> Expression(Variable(:x))\nx\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation.ModelKit.Variable","page":"ModelKit","title":"HomotopyContinuation.ModelKit.Variable","text":"Variable(name::Union{String,Symbol}, indices...) <: Number\n\nA data structure representing a variable.\n\njulia> Variable(:a)\na\n\njulia> Variable(:x, 1)\nx₁\n\njulia> Variable(:x, 10, 5)\nx₁₀₋₅\n\nEquality and ordering\n\nVariables are identified by their name and indices. That is, two variables are equal if and only if they have the same name and indices.\n\njulia> Variable(:a) == Variable(:a)\ntrue\n\njulia> Variable(:a, 1) == Variable(:a, 2)\nfalse\n\nSimilarly, variables are first ordered lexicographically by their name and then by their indices.\n\njulia> Variable(:a, 1) < Variable(:a, 2)\ntrue\n\njulia> Variable(:a, 1) < Variable(:b, 1)\ntrue\n\njulia> a = [Variable(:a, i, j) for i in 1:2, j in 1:2]\n2×2 Array{Variable,2}:\n a₁₋₁  a₁₋₂\n a₂₋₁  a₂₋₂\n\njulia> sort(vec(a))\n4-element Array{Variable,1}:\n a₁₋₁\n a₂₋₁\n a₁₋₂\n a₂₋₂\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation.ModelKit.@var","page":"ModelKit","title":"HomotopyContinuation.ModelKit.@var","text":"@var variable1 variable2 ...\n\nDeclare variables with the given names and automatically create the variable bindings. The macro supports indexing notation to create Arrays of variables.\n\nExamples\n\njulia> @var a b x[1:2] y[1:2,1:3]\n(a, b, Variable[x₁, x₂], Variable[y₁₋₁ y₁₋₂ y₁₋₃; y₂₋₁ y₂₋₂ y₂₋₃])\n\njulia> a\na\n\njulia> b\nb\n\njulia> x\n2-element Array{Variable,1}:\n x₁\n x₂\n\njulia> y\n2×3 Array{Variable,2}:\n y₁₋₁  y₁₋₂  y₁₋₃\n y₂₋₁  y₂₋₂  y₂₋₃\n\n\n\n\n\n","category":"macro"},{"location":"model_kit/#HomotopyContinuation.ModelKit.@unique_var","page":"ModelKit","title":"HomotopyContinuation.ModelKit.@unique_var","text":"@unique_var variable1 variable2\n\nThis is similar to @var with the only difference that the macro automatically changes the names of the variables to ensure uniqueness. However, the binding is still to the declared name. This is useful to ensure that there are no name collisions.\n\nExamples\n\njulia> @unique_var a b\n(a#591, b#592)\n\njulia> a\na#591\n\njulia> b\nb#592\n\n\n\n\n\n","category":"macro"},{"location":"model_kit/#Methods-1","page":"ModelKit","title":"Methods","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"coefficients\ndegree\ndegrees(::AbstractVector{Expression})\ndifferentiate\ndense_poly\nevaluate\nexpand\nexponents_coefficients\nhorner\nnvariables(::Expression)\nmonomials\nsubs\nrand_poly\nto_dict\nto_number\nvariables(::Expression)","category":"page"},{"location":"model_kit/#MultivariatePolynomials.coefficients","page":"ModelKit","title":"MultivariatePolynomials.coefficients","text":"coefficients(p::AbstractPolynomialLike)\n\nReturns an iterator over the coefficients of p of the nonzero terms of the polynomial sorted in the decreasing monomial order.\n\ncoefficients(p::AbstractPolynomialLike, X::AbstractVector)\n\nReturns an iterator over the coefficients of the monomials of X in p where X is a monomial vector not necessarily sorted but with no duplicate entry.\n\nExamples\n\nCalling coefficients on 4x^2y + xy + 2x should return an iterator of 4 1 2. Calling coefficients(4x^2*y + x*y + 2x + 3, [x, 1, x*y, y]) should return an iterator of 2 3 1 0.\n\n\n\n\n\ncoefficients(f::Expression, vars::AbstractVector{Variable})\n\nReturn all coefficients of the given polynomial f for the given variables vars. This assumes that the expression f is already expanded, e.g., with expand.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#MultivariatePolynomials.degree","page":"ModelKit","title":"MultivariatePolynomials.degree","text":"degree(t::AbstractTermLike)\n\nReturns the total degree of the monomial of the term t, i.e. sum(exponents(t)).\n\ndegree(t::AbstractTermLike, v::AbstractVariable)\n\nReturns the exponent of the variable v in the monomial of the term t.\n\nExamples\n\nCalling degree(x^2*y) should return 3 which is 2 + 1. Calling degree(x^2*y, x) should return 2 and calling degree(x^2*y, y) should return 1.\n\n\n\n\n\ndegree(f::Expression, vars = variables(f); expanded = false)\n\nCompute the degree of the expression f  in vars. Unless expanded is true the expression is first expanded.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation.ModelKit.degrees-Tuple{AbstractArray{Expression,1}}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.degrees","text":"degrees(f::AbstractVector{Expression}, vars = variables(f); expanded = false)\n\nCompute the degrees of the expressions f in vars. Unless expanded is true the expressions are first expanded.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#MultivariatePolynomials.differentiate","page":"ModelKit","title":"MultivariatePolynomials.differentiate","text":"differentiate(p::AbstractPolynomialLike, v::AbstractVariable, deg::Union{Int, Val}=1)\n\nDifferentiate deg times the polynomial p by the variable v.\n\ndifferentiate(p::AbstractPolynomialLike, vs, deg::Union{Int, Val}=1)\n\nDifferentiate deg times the polynomial p by the variables of the vector or tuple of variable vs and return an array of dimension deg. It is recommended to pass deg as a Val instance when the degree is known at compile time, e.g. differentiate(p, v, Val{2}()) instead of differentiate(p, x, 2), as this will help the compiler infer the return type.\n\ndifferentiate(p::AbstractArray{<:AbstractPolynomialLike, N}, vs, deg::Union{Int, Val}=1) where N\n\nDifferentiate the polynomials in p by the variables of the vector or tuple of variable vs and return an array of dimension N+deg. If p is an AbstractVector this returns the Jacobian of p where the i-th row containts the partial derivaties of p[i].\n\nExamples\n\np = 3x^2*y + x + 2y + 1\ndifferentiate(p, x) # should return 6xy + 1\ndifferentiate(p, x, Val{1}()) # equivalent to the above\ndifferentiate(p, (x, y)) # should return [6xy+1, 3x^2+1]\ndifferentiate( [x^2+y, z^2+4x], [x, y, z]) # should return [2x 1 0; 4 0 2z]\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation.ModelKit.dense_poly","page":"ModelKit","title":"HomotopyContinuation.ModelKit.dense_poly","text":"dense_poly(vars::AbstractVector{Variable}, d::Integer;\n           homogeneous::Bool = false,\n           coeff_name::Symbol = gensym(:c))\n\nCreate a dense polynomial of degree d in the given variables variables where each coefficient is a parameter. Returns a tuple with the first argument being the polynomial and the second the parameters.\n\njulia> @var x y;\n\njulia> f, c = dense_poly([x, y], 2, coeff_name = :q);\n\njulia> f\n q₆ + x*q₄ + x^2*q₁ + y*q₅ + y^2*q₃ + x*y*q₂\n\njulia> c\n6-element Array{Variable,1}:\n q₁\n q₂\n q₃\n q₄\n q₅\n q₆\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation.ModelKit.evaluate","page":"ModelKit","title":"HomotopyContinuation.ModelKit.evaluate","text":"evaluate(expr::Expression, subs...)\nevaluate(expr::AbstractArray{Expression}, subs...)\n\nEvaluate the given expression.\n\nExample\n\njulia> @var x y;\n\njulia> evaluate(x^2, x => 2)\n4\n\njulia> evaluate(x * y, [x,y] => [2, 3])\n6\n\njulia> evaluate([x^2, x * y], [x,y] => [2, 3])\n2-element Array{Int64,1}:\n 4\n 6\n\n# You can also use the callable syntax\njulia> [x^2, x * y]([x,y] => [2, 3])\n2-element Array{Int64,1}:\n 4\n 6\n\n\n\n\n\nevaluate(F::AbstractSystem, x, p = nothing)\n\nEvaluate the given system.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation.ModelKit.expand","page":"ModelKit","title":"HomotopyContinuation.ModelKit.expand","text":"expand(e::Expression)\n\nExpand a given expression.\n\njulia> @var x y\n(x, y)\n\njulia> expand((x + y) ^ 2)\n2*x*y + x^2 + y^2\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation.ModelKit.exponents_coefficients","page":"ModelKit","title":"HomotopyContinuation.ModelKit.exponents_coefficients","text":"exponents_coefficients(f::Expression, vars::AbstractVector{Variable}; expanded = false)\n\nReturn a matrix M containing the exponents for all occuring terms (one term per column) and a vector c containing the corresponding coefficients. Expands the given expression f unless expanded = true.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation.ModelKit.horner","page":"ModelKit","title":"HomotopyContinuation.ModelKit.horner","text":"horner(f::Expression, vars = variables(f))\n\nRewrite f using a multi-variate horner schema.\n\nExample\n\njulia> @var u v c[1:3]\n(u, v, Variable[c₁, c₂, c₃])\n\njulia> f = c[1] + c[2] * v + c[3] * u^2 * v^2 + c[3]u^3 * v\nc₁ + v*c₂ + u^2*v^2*c₃ + u^3*v*c₃\n\njulia> horner(f)\nc₁ + v*(c₂ + u^3*c₃ + u^2*v*c₃)\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#MultivariatePolynomials.nvariables-Tuple{Expression}","page":"ModelKit","title":"MultivariatePolynomials.nvariables","text":"nvariables(expr::Expression; parameters = Variable[])\nnvariables(exprs::AbstractVector{Expression}; parameters = Variable[])\n\nObtain the number of variables used in the given expression not counting the the ones declared in parameters.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#MultivariatePolynomials.monomials","page":"ModelKit","title":"MultivariatePolynomials.monomials","text":"monomials(p::AbstractPolynomialLike)\n\nReturns an iterator over the monomials of p of the nonzero terms of the polynomial sorted in the decreasing order.\n\nmonomials(vars::Tuple, degs::AbstractVector{Int}, filter::Function = m -> true)\n\nBuilds the vector of all the monovec m with variables vars such that the degree degree(m) is in degs and filter(m) is true.\n\nExamples\n\nCalling monomials on 4x^2y + xy + 2x should return an iterator of x^2y xy x.\n\nCalling monomials((x, y), [1, 3], m -> degree(m, y) != 1) should return [x^3, x*y^2, y^3, x] where x^2*y and y have been excluded by the filter.\n\n\n\n\n\nmonomials(variables::AbstractVector{Variable}, d::Integer; homogeneous::Bool = false)\n\nCreate all monomials of a given degree in the given variables.\n\njulia> @var x y\n(x, y)\n\njulia> monomials([x,y], 2)\n6-element Array{Expression,1}:\nx^2\nx*y\ny^2\n  x\n  y\n  1\n\njulia> monomials([x,y], 2; homogeneous = true)\n3-element Array{Operation,1}:\n x ^ 2\n x * y\n y ^ 2\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#MultivariatePolynomials.subs","page":"ModelKit","title":"MultivariatePolynomials.subs","text":"subs(p, s::AbstractSubstitution...)\n\nApply the substitutions s to p. Use p(s...) if we are sure that all the variables are substited in s.\n\nThe allowed substutions are:\n\nv => p where v is a variable and p a polynomial, e.g. x => 1 or x => x^2*y + x + y.\nV => P where V is a tuple or vector of variables and P a tuple or vector of polynomials, e.g. (x, y) => (y, x) or (y, x) => (2, 1).\n\nThe order of the variables is lexicographic with the name with TypedPolynomials and by order of creation with DynamicPolynomials. Since there is no guarantee on the order of the variables, substitution directly with a tuple or a vetor is not allowed. You can use p(variables(p) => (1, 2)) instead if you are sure of the order of the variables (e.g. the name order matches the creation order).\n\nExamples\n\np = 3x^2*y + x + 2y + 1\np(x => 2, y => 1) # Return type is Int\nsubs(p, x => 2, y => 1) # Return type is Int in TypedPolynomials but is a polynomial of Int coefficients in DynamicPolynomials\nsubs(p, y => x*y^2 + 1)\np(y => 2) # Do not do that, this works fine with TypedPolynomials but it will not return a correct result with DynamicPolynomials since it thinks that the return type is `Int`.\n\n\n\n\n\nsubs(expr::Expression, subsitutions::Pair...)\nsubs(exprs::AbstractVector{<:Expression}, subsitutions::Pair...)\n\nApply the given substitutions to the given expressions.\n\nExamples\n\n@var x y\n\njulia> subs(x^2, x => y)\ny ^ 2\n\njulia> subs(x * y, [x,y] => [x+2,y+2])\n(x + 2) * (y + 2)\n\njulia> subs([x + y, x^2], x => y + 2, y => x + 2)\n2-element Array{Expression,1}:\n 4 + x + y\n (2 + y)^2\n\n# You can also use the callable syntax\njulia> (x * y)([x,y] => [x+2,y+2])\n (x + 2) * (y + 2)\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation.ModelKit.rand_poly","page":"ModelKit","title":"HomotopyContinuation.ModelKit.rand_poly","text":"rand_poly(T = ComplexF64, vars::AbstractVector{Variable}, d::Integer; homogeneous::Bool = false)\n\nCreate a random dense polynomial of degree d in the given variables variables. Each coefficient is sampled independently via randn(T).\n\njulia> @var x y;\n\njulia> rand_poly(Float64, [x, y], 2)\n0.788764085756728 - 0.534507647623108*x - 0.778441366874946*y -\n 0.128891763280247*x*y + 0.878962738754971*x^2 + 0.550480741774464*y^2\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation.ModelKit.to_dict","page":"ModelKit","title":"HomotopyContinuation.ModelKit.to_dict","text":"to_dict(expr::Expression, vars::AbstractVector{Variable})\n\nReturn the coefficients of expr w.r.t. the given variables vars. Assumes that expr is expanded.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation.ModelKit.to_number","page":"ModelKit","title":"HomotopyContinuation.ModelKit.to_number","text":"to_number(x::Expression)\n\nTries to unpack the Expression x to a native number type.\n\n```julia-repl julia> x = to_number(Expression(2)) 2\n\njulia> typeof(x) Int64\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#MultivariatePolynomials.variables-Tuple{Expression}","page":"ModelKit","title":"MultivariatePolynomials.variables","text":"variables(expr::Expression; parameters = Variable[])\nvariables(exprs::AbstractVector{Expression}; parameters = Variable[])\n\nObtain all variables used in the given expression up to the ones declared in parameters.\n\nExample\n\njulia> @var x y a;\njulia> variables(x^2 + y)\n2-element Array{Variable,1}:\n x\n y\n\njulia> variables([x^2 + a, y]; parameters = [a])\n2-element Array{Variable,1}:\n x\n y\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#System-1","page":"ModelKit","title":"System","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"System\ndegrees(F::System)\nexpressions(F::System)\noptimize(::System)\nmulti_degrees(::System)\nnparameters(::System)\nnvariables(::System)\nparameters(::System)\nsupport_coefficients(::System)\nvariables(::System)\nvariable_groups(::System)","category":"page"},{"location":"model_kit/#HomotopyContinuation.ModelKit.System","page":"ModelKit","title":"HomotopyContinuation.ModelKit.System","text":"System(exprs::AbstractVector{Expression};\n            variables = variables(exprssion),\n            parameters = Variable[])\nSystem(exprs, variables; parameters = Variable[])\n\nCreate a system from the given Expressions exprs. The variables determine also the variable ordering. The parameters argument allows to declare certain Variables as parameters.\n\nExamples\n\njulia> @var x y;\njulia> F = System([x^2, y^2]; variables = [y, x])\nSystem of length 2\n 2 variables: y, x\n\n x^2\n y^2\n\n# Systems are callable.\n# This evaluates F at y=2 and x=3\njulia> F([2, 3])\n2-element Array{Int64,1}:\n 9\n 4\n\nIt is also possible to declare parameters.\n\njulia> @var x y a b;\njulia> F = System([x^2 + a, y^2 + b]; variables = [y, x], parameters = [a, b])\nSystem of length 2\n 2 variables: y, x\n 2 parameters: a, b\n\n a + x^2\n b + y^2\n\njulia> F([2, 3], [5, -2])\n 2-element Array{Int64,1}:\n  14\n   2\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation.ModelKit.degrees-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.degrees","text":"degrees(F::System)\n\nReturn the degrees of the given system.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.expressions-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.expressions","text":"expressions(F::System)\n\nReturns the expressions of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.optimize-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.optimize","text":"optimize(F::System)\n\nOptimize the evaluation cost of the given system F. This applies a multivariate horner schema to the given expressions. See also horner.\n\nExample\n\njulia> f\nSystem of length 4\n 4 variables: z₁, z₂, z₃, z₄\n\n z₁ + z₂ + z₃ + z₄\n z₂*z₁ + z₂*z₃ + z₃*z₄ + z₄*z₁\n z₂*z₃*z₁ + z₂*z₃*z₄ + z₂*z₄*z₁ + z₃*z₄*z₁\n -1 + z₂*z₃*z₄*z₁\n\njulia> optimize(f)\nSystem of length 4\n 4 variables: z₁, z₂, z₃, z₄\n\n z₁ + z₂ + z₃ + z₄\n (z₂ + z₄)*z₁ + (z₂ + z₄)*z₃\n z₁*(z₃*z₄ + (z₃ + z₄)*z₂) + z₂*z₃*z₄\n -1 + z₂*z₃*z₄*z₁\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.multi_degrees-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.multi_degrees","text":"multi_degrees(F::System)\n\nReturn the degrees with respect to the given variable groups.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.nparameters-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.nparameters","text":"nparameters(F::System)\n\nReturns the number of parameters of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#MultivariatePolynomials.nvariables-Tuple{System}","page":"ModelKit","title":"MultivariatePolynomials.nvariables","text":"nvariables(F::System)\n\nReturns the number of variables of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.parameters-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.parameters","text":"parameters(F::System)\n\nReturns the parameters of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.support_coefficients-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.support_coefficients","text":"support_coefficients(F::System)\n\nReturn the support of the system and the corresponding coefficients.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#MultivariatePolynomials.variables-Tuple{System}","page":"ModelKit","title":"MultivariatePolynomials.variables","text":"variables(F::System)\n\nReturns the variables of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.variable_groups-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.variable_groups","text":"variable_groups(F::System)\n\nReturns the variable groups of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#Homotopy-1","page":"ModelKit","title":"Homotopy","text":"","category":"section"},{"location":"model_kit/#","page":"ModelKit","title":"ModelKit","text":"Homotopy\nexpressions(::Homotopy)\nnparameters(::Homotopy)\nnvariables(::Homotopy)\nparameters(::Homotopy)\nvariables(::Homotopy)","category":"page"},{"location":"model_kit/#HomotopyContinuation.ModelKit.Homotopy","page":"ModelKit","title":"HomotopyContinuation.ModelKit.Homotopy","text":"Homotopy(exprs, vars, t, parameters = Variable[])\n\nCreate a homotopy H(vars,t) from the given Expressions exprs where vars are the given variables and t is the dedicated variable parameterizing the family of systems. The parameters argument allows to declare certain Variables as parameters.\n\nExample\n\njulia> @var x y t;\n\njulia> H = Homotopy([x + t, y + 2t], [y, x], t)\nHomotopy in t of length 2\n 2 variables: y, x\n\n t + x\n 2*t + y\n\njulia> H([2, 3], 0)\n2-element Array{Int64,1}:\n 3\n 2\n\n\njulia> H([2, 3], 1)\n2-element Array{Int64,1}:\n 4\n 4\n\nIt is also possible to declare additional variables.\n\njulia> @var x y t a b;\njulia> H = Homotopy([x^2 + t*a, y^2 + t*b], [x, y], t, [a, b])\nHomotopy in t of length 2\n 2 variables: x, y\n 2 parameters: a, b\n\n a*t + x^2\n b*t + y^2\njulia> H([2, 3], 1, [5, 2])\n2-element Array{Int64,1}:\n 9\n 11\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation.ModelKit.expressions-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.expressions","text":"expressions(H::Homotopy)\n\nReturns the expressions of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.nparameters-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.nparameters","text":"nparameters(H::Homotopy)\n\nReturns the number of parameters of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#MultivariatePolynomials.nvariables-Tuple{Homotopy}","page":"ModelKit","title":"MultivariatePolynomials.nvariables","text":"nvariables(H::Homotopy)\n\nReturns the number of variables of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.parameters-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.parameters","text":"parameters(H::Homotopy)\n\nReturns the parameters of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#MultivariatePolynomials.variables-Tuple{Homotopy}","page":"ModelKit","title":"MultivariatePolynomials.variables","text":"variables(H::Homotopy)\n\nReturns the variables of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"solve/#The-solve-function-1","page":"Solve","title":"The solve function","text":"","category":"section"},{"location":"solve/#","page":"Solve","title":"Solve","text":"The solve function is the most convenient way to solve general polynomial systems. For the mathematical background take a look at our introduction guide.","category":"page"},{"location":"solve/#","page":"Solve","title":"Solve","text":"solve","category":"page"},{"location":"solve/#HomotopyContinuation.solve","page":"Solve","title":"HomotopyContinuation.solve","text":"solve(f; options...)\nsolve(f, start_solutions; start_parameters, target_parameters, options...)\nsolve(g, f, start_solutions; options...)\nsolve(homotopy, start_solutions; options...)\n\nSolve the given problem. If only a single polynomial system f is given, then all (complex) isolated solutions are computed. If a system f depending on parameters together with start and target parameters is given then a parameter homotopy is performed. If two systems g and f with solutions of g are given then the solutions are tracked during the deformation of g to f. Similarly, for a given homotopy homotopy H(xt) with solutions at t=1 the solutions at t=0 are computed. See the documentation for examples. If the input is a homogeneous polynomial system, solutions on a random affine chart of projective space are computed.\n\nGeneral Options\n\nThe solve routines takes the following options:\n\ncatch_interrupt = true: If this is true, the computation is gracefully stopped and a partial result is returned when the computation is interruped.\nendgame_options: The options and parameters for the endgame. Expects an EndgameOptions struct.\nseed: The random seed used during the computations. The seed is also reported in the result. For a given random seed the result is always identical.\nshow_progress= true: Indicate whether a progress bar should be displayed.\nstop_early_cb: Here it is possible to provide a function (or any callable struct) which accepts a PathResult r as input and returns a Bool. If stop_early_cb(r) is true then no further paths are tracked and the computation is finished. This is only called for successfull paths. This is for example useful if you only want to compute one solution of a polynomial system. For this stop_early_cb = _ -> true would be sufficient.\nthreading = true: Enable multi-threading for the computation. The number of available threads is controlled by the environment variable JULIA_NUM_THREADS.\ntracker_options: The options and parameters for the path tracker. Expects a TrackerOptions struct.\n\nOptions depending on input\n\nIf only a polynomial system is given:\n\nstart_system: Possible values are :total_degree and :polyhedral. Depending on the choice furhter options are possible. See also total_degree and polyhedral.\n\nIf a system f depending on parameters together with start parameters, start solutions and multiple target parameters then the following options are also available:\n\nflatten: Flatten the output of transform_result. This is useful for example if  transform_result returns a vector of solutions, and you only want a single vector of  solutions as the result (instead of a vector of vector of solutions).\ntransform_parameters = identity: Transform a parameters values p before passing it to target_parameters = ....\ntransform_result: A function taking two arguments, the result and the parameters p. By default this returns the tuple (result, p).\n\nBasic example\n\njulia> @var x y;\n\njulia> F = System([x^2+y^2+1, 2x+3y-1])\nSystem of length 2\n 2 variables: x, y\n\n 1 + x^2 + y^2\n -1 + 2*x + 3*y\n\njulia> solve(F)\nResult with 2 solutions\n=======================\n• 2 non-singular solutions (0 real)\n• 0 singular solutions (0 real)\n• 2 paths tracked\n• random seed: 0x75a6a462\n• start_system: :polyhedral\n\n\n\n\n\n","category":"function"},{"location":"solve/#","page":"Solve","title":"Solve","text":"The function paths_to_track allows you to know beforehand how manys the you need to track:","category":"page"},{"location":"solve/#","page":"Solve","title":"Solve","text":"paths_to_track","category":"page"},{"location":"solve/#HomotopyContinuation.paths_to_track","page":"Solve","title":"HomotopyContinuation.paths_to_track","text":"paths_to_track(f; optopms..)\n\nReturns the number of paths tracked when calling solve with the given arguments.\n\n\n\n\n\n","category":"function"},{"location":"tracker/#Tracker-1","page":"Tracker","title":"Tracker","text":"","category":"section"},{"location":"tracker/#","page":"Tracker","title":"Tracker","text":"Tracker is a data structure to track for a given AbstractHomotopy H(xt) a solution x from t₁  ℂ to t₀  ℂ, i.e.,  H(xt₁) = 0 and x with H(xt₀) = 0 is returned. This is done by following an implicitly defined smooth path x(t) using a predictor-corrector scheme. In particular, it is assumed that for all t on the line segment between t₁ and t₀ the Jacobian H_x(x(t)t) has full column-rank. The algorithm uses as an predictor a Padé approximant of order (2,1) and as a corrector Newton's method. The details of the algorithm are described in the article [Tim20].","category":"page"},{"location":"tracker/#Constructor-and-Options-1","page":"Tracker","title":"Constructor and Options","text":"","category":"section"},{"location":"tracker/#","page":"Tracker","title":"Tracker","text":"Tracker\nTrackerOptions\nTrackerParameters\nDEFAULT_TRACKER_PARAMETERS\nCONSERVATIVE_TRACKER_PARAMETERS\nFAST_TRACKER_PARAMETERS","category":"page"},{"location":"tracker/#HomotopyContinuation.Tracker","page":"Tracker","title":"HomotopyContinuation.Tracker","text":"Tracker(H::AbstractHomotopy;\n        options = TrackerOptions(),\n        weighted_norm_options = WeightedNormOptions())\n\nConstruct a tracker for the given homotopy H. The algorithm computes along the path x(t) the local derivatives up to order 4. For options see also TrackerOptions. The algorithm uses as a weighted infinity norm to measure distances. See also WeightedNorm.\n\n[Tim20]: Timme, S. \"Mixed Precision Path Tracking for Polynomial Homotopy Continuation\". arXiv:1902.02968 (2020)\n\nExample\n\nWe want to solve the system\n\n@var x y t\nF = System([x^2 + y^2 - 3, 2x^2 + 0.5x*y + 3y^2 - 2])\n\nusing a total degree homotopy and Tracker.\n\n# construct start system and homotopy\nG = System(im * [x^2 - 1, y^2 - 1])\nH = StraightLineHomotopy(G, F)\nstart_solutions = [[1,1], [-1,1], [1,-1], [-1,-1]]\n# construct tracker\ntracker = Tracker(H)\n# track each start solution separetely\nresults = track.(tracker, start_solutions)\nprintln(\"# successfull: \", count(is_success, results))\n\nWe see that we tracked all 4 paths successfully.\n\n# successfull: 4\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation.TrackerOptions","page":"Tracker","title":"HomotopyContinuation.TrackerOptions","text":"TrackerOptions(; options...)\n\nThe set of options for a Tracker.\n\nOptions\n\nautomatic_differentiation = 1: The value automatic_differentiation determines up to which order the derivative is computed using automatic differentiation. Otherwise numerical differentiation is used. The automatic differentiation results in additional compilation time, however for numerically challenging paths it is strongly recommended to use automatic_differentiation = 3.\nmax_steps = 10_000: The maximal number of steps a tracker attempts\nmax_step_size = Inf: The maximal size of a step\nmax_initial_step_size = Inf: The maximal size of the first step\nmin_step_size = 1e-48: The minimal step size. If a smaller step size would be necessary, then the tracking gets terminated.\nextended_precision = true: Whether to allow for the use of extended precision, if necessary, in some computations. This can greatly improve the ability to track numerically difficult paths.\nterminate_cond = 1e13: If the relative component-wise condition number cond(H_x, ẋ) is larger than terminate_cond then the path is terminated as too ill-conditioned.\nparameters::Union{Symbol,TrackerParameters} = :default Set the TrackerParameters to control the performance of the path tracking algorithm. The values :default, :conservative and :fast are shorthands for using DEFAULT_TRACKER_PARAMETERS, CONSERVATIVE_TRACKER_PARAMETERS resp. FAST_TRACKER_PARAMETERS.\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation.TrackerParameters","page":"Tracker","title":"HomotopyContinuation.TrackerParameters","text":"TrackerParameters\n\nParameters that control the performance and robustness characteristics of the path tracking algorithm. See [Tim20] for an explanation and derivation of the parameters. We provide three sets of parameters for common use cases:\n\nDEFAULT_TRACKER_PARAMETERS\nFAST_TRACKER_PARAMETERS\nCONSERVATIVE_TRACKER_PARAMETERS\n\n[Tim20]: Timme, S. \"Mixed Precision Path Tracking for Polynomial Homotopy Continuation\". arXiv:1902.02968 (2020)\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation.DEFAULT_TRACKER_PARAMETERS","page":"Tracker","title":"HomotopyContinuation.DEFAULT_TRACKER_PARAMETERS","text":"The default TrackerParameters which have a good balance between robustness and efficiency.\n\n\n\n\n\n","category":"constant"},{"location":"tracker/#HomotopyContinuation.CONSERVATIVE_TRACKER_PARAMETERS","page":"Tracker","title":"HomotopyContinuation.CONSERVATIVE_TRACKER_PARAMETERS","text":"TrackerParameters which trade robustness against some speed.\n\n\n\n\n\n","category":"constant"},{"location":"tracker/#HomotopyContinuation.FAST_TRACKER_PARAMETERS","page":"Tracker","title":"HomotopyContinuation.FAST_TRACKER_PARAMETERS","text":"TrackerParameters which trade speed against a higher chance of path jumping.\n\n\n\n\n\n","category":"constant"},{"location":"tracker/#Tracking-1","page":"Tracker","title":"Tracking","text":"","category":"section"},{"location":"tracker/#","page":"Tracker","title":"Tracker","text":"track(tracker::Tracker, x₁::AbstractVector, t₁::Number, t₀::Number)","category":"page"},{"location":"tracker/#HomotopyContinuation.track-Tuple{Tracker,AbstractArray{T,1} where T,Number,Number}","page":"Tracker","title":"HomotopyContinuation.track","text":" track(tracker::Tracker, x::AbstractVector, t₁ = 1.0, t₀ = 0.0; debug::Bool = false)\n\nTrack the given solution x at t₁ using tracker to a solution at t₀.\n\ntrack(tracker::Tracker, r::TrackerResult, t₁ = 1.0, t₀ = 0.0; debug::Bool = false)\n\nTrack the solution of the result r from t₁ to t₀.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#Result-1","page":"Tracker","title":"Result","text":"","category":"section"},{"location":"tracker/#","page":"Tracker","title":"Tracker","text":"TrackerResult\nsolution(::TrackerResult)\nis_success(::TrackerResult)\nis_invalid_startvalue(::TrackerResult)\nsteps(::TrackerResult)\naccepted_steps(::TrackerResult)\nrejected_steps(::TrackerResult)","category":"page"},{"location":"tracker/#HomotopyContinuation.TrackerResult","page":"Tracker","title":"HomotopyContinuation.TrackerResult","text":"TrackerResult\n\nContaining the result of tracking a path with a Tracker.\n\nFields\n\nreturn_code::Symbol: A code indicating whether the tracking was successfull (:success). See TrackerCode for all possible values.\nsolution::V: The solution when the tracking stopped.\nt::ComplexF64: The value of t when the tracking stopped.\naccuracy::Float64: Estimate of the relative accuracy of the solution.\naccepted_steps::Int: Number of steps that got accepted.\nrejected_steps::Int: Number of steps that got rejected.\nextended_precision::Bool: Indicate whether extended precision is necessary to achieve the accuracy of the solution.\nextended_precision_used::Bool: This is true if during the tracking at any point extended precision was used.\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation.solution-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation.solution","text":"solution(result::TrackerResult)\n\nReturns the solutions obtained by the Tracker.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.is_success-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation.is_success","text":"is_success(result::TrackerResult)\n\nReturns true if the path tracking was successfull.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.is_invalid_startvalue-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation.is_invalid_startvalue","text":"is_invalid_startvalue(result::TrackerResult)\n\nReturns true if the path tracking failed since the start value was invalid.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.steps-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation.steps","text":"steps(result::TrackerResult)\n\nReturns the number of steps done.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.accepted_steps-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation.accepted_steps","text":"accepted_steps(result::TrackerResult)\n\nReturns the number of accepted steps.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.rejected_steps-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation.rejected_steps","text":"rejected_steps(result::TrackerResult)\n\nReturns the number of rejected_steps steps.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#Low-level-API-1","page":"Tracker","title":"Low-level API","text":"","category":"section"},{"location":"tracker/#","page":"Tracker","title":"Tracker","text":"track!(tracker::Tracker, x₁::AbstractVector, t₁::Number, t₀::Number)\ninit!(tracker::Tracker, ::TrackerResult, ::Number, ::Number)\nTrackerCode\nis_success(::TrackerCode.codes)\nis_tracking(::TrackerCode.codes)\nis_invalid_startvalue(::TrackerCode.codes)\nis_terminated(::TrackerCode.codes)\n","category":"page"},{"location":"tracker/#HomotopyContinuation.track!-Tuple{Tracker,AbstractArray{T,1} where T,Number,Number}","page":"Tracker","title":"HomotopyContinuation.track!","text":"track!(tracker::Tracker, x, t₁ = 1.0, t₀ = 0.0; debug::Bool = false)\n\nThe same as track but only returns the final TrackerCode.\n\ntrack!(tracker::Tracker, t₀; debug::Bool = false)\n\nTrack with tracker the current solution to t₀. This keeps the current state.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.init!-Tuple{Tracker,TrackerResult,Number,Number}","page":"Tracker","title":"HomotopyContinuation.init!","text":"init!(tracker::Tracker, x₁, t₁, t₀)\n\nSetup tracker to track x₁ from t₁ to t₀.\n\ninit!(tracker::Tracker, t₀)\n\nSetup tracker to continue tracking the current solution to t₀. This keeps the current state.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.TrackerCode","page":"Tracker","title":"HomotopyContinuation.TrackerCode","text":"TrackerCode\n\nThe possible states a CoreTracker can have are of type TrackerCode.codes and can be\n\nTrackerCode.success: Indicates a successfull tracking.\nTrackerCode.tracking: The tracking is still in progress.\nTrackerCode.terminated_accuracy_limit: Tracking terminaed since the accuracy was insufficient.\nTrackerCode.terminated_invalid_startvalue: Tracking terminated since the provided start value was invalid.\nTrackerCode.terminated_ill_conditioned: Tracking terminated since the path was too ill-conditioned.\nTrackerCode.terminated_max_steps: Tracking terminated since maximal number of steps is reached.\nTrackerCode.terminated_step_size_too_small: Trackint terminated since the step size was too small.\nTrackerCode.terminated_unknown: An unintended error occured. Please consider reporting an issue.\n\n\n\n\n\n","category":"module"},{"location":"tracker/#HomotopyContinuation.is_success-Tuple{HomotopyContinuation.TrackerCode.codes}","page":"Tracker","title":"HomotopyContinuation.is_success","text":"is_success(code::TrackerCode.codes)\n\nReturns true if code indicates a success in the path tracking.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.is_tracking-Tuple{HomotopyContinuation.TrackerCode.codes}","page":"Tracker","title":"HomotopyContinuation.is_tracking","text":"is_tracking(code::TrackerCode.codes)\n\nReturns true if code indicates that the path tracking is not yet finished.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.is_invalid_startvalue-Tuple{HomotopyContinuation.TrackerCode.codes}","page":"Tracker","title":"HomotopyContinuation.is_invalid_startvalue","text":"is_invalid_startvalue(code::TrackerCode.codes)\n\nReturns true if code indicates that the path tracking got terminated since the start value was not a zero.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.is_terminated-Tuple{HomotopyContinuation.TrackerCode.codes}","page":"Tracker","title":"HomotopyContinuation.is_terminated","text":"is_terminated(code::TrackerCode.codes)\n\nReturns true if code indicates that the path tracking got terminated.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Miscellaneous-1","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/#Newton's-method-1","page":"Miscellaneous","title":"Newton's method","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"newton\nNewtonResult\nis_success(::NewtonResult)\nNewtonCache","category":"page"},{"location":"misc/#HomotopyContinuation.newton","page":"Miscellaneous","title":"HomotopyContinuation.newton","text":"newton(\n    F::AbstractSystem,\n    x₀::AbstractVector,\n    norm::AbstractNorm = InfNorm(),\n    cache::NewtonCache = NewtonCache(F, x₀);\n    options...\n)\n\nAn implemenetation of a local Newton's method with various options to specify convergence criteria. Returns a NewtonResult. The computations are always performed in complex arithmetic with double precision, i.e., using Complex{Float64}. The optional cache argument pre-allocates the necessary memory. This is useful if the method is called repeatedly.\n\nOptions\n\nabs_tol::Float64 = 1e-8: The method is declared converged if norm(xᵢ₊₁ - xᵢ) < abs_tol.\nrel_tol::Float64 = abs_tol: The method is declared converged if norm(xᵢ₊₁ - xᵢ) < abs_tol * norm(x₀).\nmax_iters::Int = 20: The maximal number of iterations.\nextended_precision::Bool = false: An optional use of extended precision for the evaluation of F(x). This can increase the achievable accuracy.\ncontraction_factor::Float64 = 1.0: The Newton updates have to satisfy xᵢ₁ - xᵢ  a^2^(i-1)x₁ - x₀ for i  1 where a is contraction_factor.\nmin_contraction_iters::Int = typemax(Int):  The minimal number of iterations the contraction_factor has to be satisfied. If after min_contraction_iters many iterations the contraction factor is not satisfied the step is accepted anyway.\nmax_abs_norm_first_update::Float64 = Inf: The initial guess x₀ is rejected if norm(x₁ - x₀) >  max_abs_norm_first_update\nmax_rel_norm_first_update::Float64 = max_abs_norm_first_update: The initial guess x₀ is rejected if norm(x₁ - x₀) >  max_rel_norm_first_update * norm(x₀)\n\n\n\n\n\n","category":"function"},{"location":"misc/#HomotopyContinuation.NewtonResult","page":"Miscellaneous","title":"HomotopyContinuation.NewtonResult","text":"NewtonResult\n\nResult returned by newton.\n\nFields\n\nreturn_code::Symbol: Can be :success, :rejected or :max_iters.\nx::Vector{ComplexF64}: The last value obtained.\naccuracy::Float64: Estimate of the distance of x to a true zero.\niters::Int Number of iterations performed.\ncontraction_ratio::Float64: The value |xᵢ - xᵢ₋₁| / |xᵢ₋₁ - xᵢ₋₂|.\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation.is_success-Tuple{NewtonResult}","page":"Miscellaneous","title":"HomotopyContinuation.is_success","text":"is_success(R::NewtonResult)\n\nReturns true if the newton was successfull.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation.NewtonCache","page":"Miscellaneous","title":"HomotopyContinuation.NewtonCache","text":"NewtonCache(F::AbstractSystem)\n\nPre-allocates the necessary memory for newton.\n\n\n\n\n\n","category":"type"},{"location":"misc/#Norms-1","page":"Miscellaneous","title":"Norms","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"AbstractNorm\nInfNorm\nEuclideanNorm\nWeightedNorm\ndistance(u, v, ::AbstractNorm)\nnorm(u, ::AbstractNorm)\ninit!(::WeightedNorm, ::AbstractVector)\nupdate!(::WeightedNorm, ::AbstractVector)","category":"page"},{"location":"misc/#HomotopyContinuation.AbstractNorm","page":"Miscellaneous","title":"HomotopyContinuation.AbstractNorm","text":"AbstractNorm\n\nAn AbstractNorm represents any norm of a vector space. All norms are callable. norm(x) computes the norm of x and norm(x,y) computes the distance norm(x - y).\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation.InfNorm","page":"Miscellaneous","title":"HomotopyContinuation.InfNorm","text":"InfNorm <: AbstractNorm\n\nThe infinity or maximum norm.\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation.EuclideanNorm","page":"Miscellaneous","title":"HomotopyContinuation.EuclideanNorm","text":"EuclideanNorm <: AbstractNorm\n\nThe Euclidean resp. 2-norm.\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation.WeightedNorm","page":"Miscellaneous","title":"HomotopyContinuation.WeightedNorm","text":"WeightedNorm(d::AbstractVector, norm::AbstractNorm; options...)\nWeightedNorm(norm::AbstractNorm, n::Integer; options...)\nWeightedNorm(norm::AbstractNorm, x::AbstractVector; options...)\n\nA WeightedNorm represents a weighted variant of norm norm of a n-dimensional vector space.A norm||x||is weighted by introducing a vector of additional weightsdsuch that the new norm is||D⁻¹x||whereDis the diagonal matrix with diagonald. The WeightedNorm is desigened to change the weights dynamically by using init!(::WeightedNorm, x) and update!(::WeightedNorm, x). The weights are there constructed such that D¹x  10. The weights can be accessed and changed by indexing.\n\nOptions\n\nscale_min = sqrt(eps()): The minimal size of dᵢ is scale_min time the (weighted) norm of x.\nscale_abs_min = min(scale_min^2, 200 * sqrt(eps())): The absolute minimal size of dᵢ.\nscale_max = 1.0 / eps() / sqrt(2): The absolute maximal size of dᵢ\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation.distance-Tuple{Any,Any,AbstractNorm}","page":"Miscellaneous","title":"HomotopyContinuation.distance","text":"distance(u, v, norm::AbstractNorm)\n\nCompute the distance ||u-v|| with respect to the given norm norm.\n\n\n\n\n\n","category":"method"},{"location":"misc/#LinearAlgebra.norm-Tuple{Any,AbstractNorm}","page":"Miscellaneous","title":"LinearAlgebra.norm","text":"norm(u, norm::AbstractNorm)\n\nCompute the norm ||u|| with respect to the given norm norm.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation.init!-Tuple{WeightedNorm,AbstractArray{T,1} where T}","page":"Miscellaneous","title":"HomotopyContinuation.init!","text":"init!(w::WeightedNorm, x::AbstractVector)\n\nSetup the weighted norm w for x.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation.update!-Tuple{WeightedNorm,AbstractArray{T,1} where T}","page":"Miscellaneous","title":"HomotopyContinuation.update!","text":"update!(w::WeightedNorm, x::AbstractVector)\n\nUpdate the weighted norm w for x, this will interpolate between the previous weights and the norm of x.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Unique-points,-group-actions-and-multiplicities-1","page":"Miscellaneous","title":"Unique points, group actions and multiplicities","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"GroupActions\nUniquePoints\nsearch_in_radius(::UniquePoints, v, tol::Real)\nadd!(UP::UniquePoints{T,Id,M,GA}, v, id::Id, tol::Real) where {T,Id,M,GA}\nmultiplicities","category":"page"},{"location":"misc/#HomotopyContinuation.GroupActions","page":"Miscellaneous","title":"HomotopyContinuation.GroupActions","text":"GroupActions(actions::Function...)\n\nStore a bunch of group actions (f1, f2, f3, ...). Each action has to return a tuple. The actions are applied in the following sense\n\nf1 is applied on the original solution s\nf2 is applied on s and the results of 1\nf3 is applied on s and the results of 1) and 2)\n\nand so on\n\nExample\n\njulia> f1(s) = (s * s,);\n\njulia> f2(s) = (2s, -s, 5s);\n\njulia> f3(s) = (s + 1,);\n\njulia> GroupActions(f1)(3)\n(3, 9)\n\njulia> GroupActions(f1, f2)(3)\n(3, 9, 6, -3, 15, 18, -9, 45)\n\njulia> GroupActions(f1,f2, f3)(3)\n(3, 9, 6, -3, 15, 18, -9, 45, 4, 10, 7, -2, 16, 19, -8, 46)\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation.UniquePoints","page":"Miscellaneous","title":"HomotopyContinuation.UniquePoints","text":"UniquePoints{T, Id, M}\n\nA data structure for assessing quickly whether a point is close to an indexed point as determined by the given distances function M. The distance function has to be a metric. The indexed points are only stored by their identifiers Id.\n\nUniquePoints(v::AbstractVector{T}, id::Id;\n                metric = EuclideanNorm(),\n                group_actions = nothing)\n\nInitialize the data structure. This does not initialize the data structure with the point.\n\nExample\n\nx = randn(ComplexF64, 4)\npermutation(x) = ([x[2]; x[1]; x[3]; x[4]],)\ngroup_actions = GroupActions(permutation)\nX = group_actions(x)\n\n# without group actions\nunique_points = UniquePoints(x, 1)\nHC.add!.(unique_points, X, 1:length(X), 1e-5)\nlength(unique_points) # 2\n\nunique_points = UniquePoints(x, 1, group_actions = group_actions)\nHC.add!.(unique_points, X, 1:length(X), 1e-5)\nlength(unique_points) # 1\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation.search_in_radius-Tuple{UniquePoints,Any,Real}","page":"Miscellaneous","title":"HomotopyContinuation.search_in_radius","text":"search_in_radius(unique_points, v, tol)\n\nSearch whether unique_points contains a point p with distances at most tol from v. Returns nothing if no point exists, otherwise the identifier of p is returned.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation.add!-Union{Tuple{GA}, Tuple{M}, Tuple{Id}, Tuple{T}, Tuple{UniquePoints{T,Id,M,GA},Any,Id,Real}} where GA where M where Id where T","page":"Miscellaneous","title":"HomotopyContinuation.add!","text":"add!(unique_points, v, id, tol)\n\nSearch whether unique_points contains a point p with distances at most tol from v. If this is the case the identifier of p and false is returned. Otherwise (id, true) is returned.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation.multiplicities","page":"Miscellaneous","title":"HomotopyContinuation.multiplicities","text":"multiplicities(vectors; metric = EuclideanNorm(), atol = 0.0, rtol = 1e-8, kwargs...)\n\nReturns an array of arrays of integers. Each vector w in 'v' contains all indices i,j such that w[i] and w[j] have distance at most max(atol, rtol * metric(0,w[i])). The remaining kwargs are things that can be passed to UniquePoints.\n\njulia> multiplicities([[1,0.5], [1,0.5], [1,1]])\n[[1,2]]\n\nThis is the same as\n\nmultiplicities([[1,0.5], [1,0.5], [1,1]]; distance=(x,y) -> LinearAlgebra.norm(x-y))\n\nHere is an example for using group actions.\n\njulia> X = [[1, 2, 3, 4], [2,1,3,4], [1,2,4,3], [2,1,4,3]]\njulia> permutation(x) = [x[2], x[1], x[3], x[4]]\njulia> m = multiplicities(X, group_action = permutation)\n[[1,2], [3,4]]\n\n\n\n\n\n","category":"function"},{"location":"misc/#Debugging-1","page":"Miscellaneous","title":"Debugging","text":"","category":"section"},{"location":"misc/#","page":"Miscellaneous","title":"Miscellaneous","text":"path_info","category":"page"},{"location":"misc/#HomotopyContinuation.path_info","page":"Miscellaneous","title":"HomotopyContinuation.path_info","text":"path_info(tracker::Tracker, x₀, t₁ = 1.0, t₀ = 0.0; debug::Bool = false, kwargs...)\n\nTrack a path using the given tracker and start value x₀. This returns a struct containing detailed information about the tracked path.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#Linear-and-Affine-Subspaces-1","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"We provide built-in data structures to work with affine and linear subspaces L. L can be represented in either extrinsic coordinates x with L = x  Ax = b  or in intrinsic coordinates u with L=Bu+p  u.","category":"page"},{"location":"linear_affine/#Coordinates-1","page":"Linear and Affine Subspaces","title":"Coordinates","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"To specify which coordinates are given / expected the following can be used:","category":"page"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"Coordinates\nIntrinsic\nExtrinsic","category":"page"},{"location":"linear_affine/#HomotopyContinuation.Coordinates","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.Coordinates","text":"Coordinates\n\nA type used for encoding the used coordinates and for performing coordinate changes.\n\nCurrently supported coordinates are:\n\nIntrinsic\nExtrinsic\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#HomotopyContinuation.Intrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.Intrinsic","text":"Intrinsic <: Coordinates\n\nIndicates the use of the intrinsic description of an affine subspace. See also AffineIntrinsic.\n\n\n\n\n\n","category":"constant"},{"location":"linear_affine/#HomotopyContinuation.Extrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.Extrinsic","text":"Extrinsic <: Coordinates\n\nIndicates the use of the extrinsic description of an affine subspace. See also AffineExtrinsic.\n\n\n\n\n\n","category":"constant"},{"location":"linear_affine/#Affine-Subspace-1","page":"Linear and Affine Subspaces","title":"Affine Subspace","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"AffineSubspace\nAffineExtrinsic\nAffineIntrinsic","category":"page"},{"location":"linear_affine/#HomotopyContinuation.AffineSubspace","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.AffineSubspace","text":"AffineSubspace(A, b)\n\nAn m-dimensional affine subspace L in n-dimensional space given by the extrinsic description L =  x  A x = b .\n\njulia> A = AffineSubspace([1 0 3; 2 1 3], [5, -2])\n1-dim. affine subspace {x|Ax=b} with eltype Float64:\nA:\n2×3 Array{Float64,2}:\n 1.0  0.0  3.0\n 2.0  1.0  3.0\nb:\n2-element Array{Float64,1}:\n  5.0\n -2.0\n\njulia> dim(A)\n1\n\njulia> codim(A)\n2\n\njulia> ambient_dim(A)\n3\n\nAn AffineSubspace holds always its extrinsic description, see also AffineIntrinsic, as well as its intrinsic description, see AffineExtrinsic.\n\njulia> intrinsic(A)\nAffineIntrinsic{Float64}:\nA:\n3×1 Array{Float64,2}:\n -0.6882472016116853\n  0.6882472016116853\n  0.22941573387056186\nb₀:\n3-element Array{Float64,1}:\n -3.0526315789473677\n -3.947368421052632\n  2.684210526315789\n\nAn AffineSubspace can be evaluated with either using Intrinsic or Extrinsic coordinates.\n\njulia> u = [0.5]\n1-element Array{Float64,1}:\n 0.5\n\njulia> x = A(u, Intrinsic)\n3-element Array{Float64,1}:\n -3.3967551797532103\n -3.6032448202467893\n  2.79891839325107\n\njulia> A(x, Extrinsic)\n  2-element Array{Float64,1}:\n   0.0\n   0.0\n\nTo change the used coordinates you can use coord_change.\n\njulia> coord_change(A, Extrinsic, Intrinsic, x)\n1-element Array{Float64,1}:\n 0.49999999999999994\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#HomotopyContinuation.AffineExtrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.AffineExtrinsic","text":"AffineExtrinsic\n\nExtrinsic description of an m-dimensional affine subspace L in n-dimensional space. That is L =  x  A x = b .\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#HomotopyContinuation.AffineIntrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.AffineIntrinsic","text":"AffineIntrinsic\n\nIntrinsic description of an m-dimensional affine subspace L in n-dimensional space. That is L =  u  A u + b₀ . Here, A and b₀ are in orthogonal coordinates. That is, the columns of A are orthonormal and A b₀ = 0.\n\n\n\n\n\n","category":"type"},{"location":"linear_affine/#Functions-1","page":"Linear and Affine Subspaces","title":"Functions","text":"","category":"section"},{"location":"linear_affine/#","page":"Linear and Affine Subspaces","title":"Linear and Affine Subspaces","text":"ambient_dim\ncodim\ncoord_change\ndim\nintrinsic\nextrinsic\ngeodesic\ngeodesic_distance\nrand_affine_subspace","category":"page"},{"location":"linear_affine/#HomotopyContinuation.ambient_dim","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.ambient_dim","text":"ambient_dim(A::AffineSubspace)\n\nDimension of ambient space of the affine subspace A.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation.codim","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.codim","text":"codim(A::AffineExtrinsic)\n\nCodimension of the affine subspace A.\n\n\n\n\n\ncodim(A::AffineIntrinsic)\n\nCodimension of the affine subspace A.\n\n\n\n\n\ncodim(A::AffineSubspace)\n\nCodimension of the affine subspace A.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation.coord_change","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.coord_change","text":"coord_change(A::AffineSubspace, C₁::Coordinates, C₂::Coordinates, p)\n\nGiven an affine subspace A and a point p in coordinates C₁ compute the point x describing p in coordinates C₂.\n\nExample\n\njulia> A = AffineSubspace([1 0 3; 2 1 3], [5, -2]);\n\njulia> u = [1.25];\n\njulia> x = coord_change(A, Intrinsic, Extrinsic, u)\n3-element Array{Float64,1}:\n -3.9129405809619744\n -3.087059419038025\n  2.9709801936539915\n\njulia> A(x, Extrinsic)\n2-element Array{Float64,1}:\n 0.0\n 0.0\n\njulia> x - A(u, Intrinsic)\n3-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation.dim","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.dim","text":"dim(A::AffineExtrinsic)\n\nDimension of the affine subspace A.\n\n\n\n\n\ndim(A::AffineIntrinsic)\n\nDimension of the affine subspace A.\n\n\n\n\n\ndim(A::AffineSubspace)\n\nDimension of the affine subspace A.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation.intrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.intrinsic","text":"intrinsic(A::AffineSubspace)\n\nObtain the intrinsic description of A, see also AffineIntrinsic.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation.extrinsic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.extrinsic","text":"extrinsic(A::AffineSubspace)\n\nObtain the extrinsic description of A, see also AffineExtrinsic.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation.geodesic","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.geodesic","text":"geodesic(A::AffineSubspace, B::AffineSubspace)\n\nReturns the geodesic γ(t) connecting A and B in the Grassmanian Gr(k+1n+1) where k is the dimension of A and n is the ambient dimension. See also Corollary 4.3 in [LKK19].\n\n[LKK19]: Lim, Lek-Heng, Ken Sze-Wai Wong, and Ke Ye. \"Numerical algorithms on the affine Grassmannian.\" SIAM Journal on Matrix Analysis and Applications 40.2 (2019): 371-393\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation.geodesic_distance","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.geodesic_distance","text":"geodesic_distance(A::AffineSubspace, B::AffineSubspace)\n\nCompute the geodesic distance between A and B in the affine Grassmanian Graff(k, n) where k = dim(A) and n is the amebient dimension. This follows the derivation in [LKK19].\n\n[LKK19]: Lim, Lek-Heng, Ken Sze-Wai Wong, and Ke Ye. \"Numerical algorithms on the affine Grassmannian.\" SIAM Journal on Matrix Analysis and Applications 40.2 (2019): 371-393.\n\n\n\n\n\n","category":"function"},{"location":"linear_affine/#HomotopyContinuation.rand_affine_subspace","page":"Linear and Affine Subspaces","title":"HomotopyContinuation.rand_affine_subspace","text":"rand_affine_subspace(n::Integer; dim | codim, real = false)\n\nGenerate a random AffineSubspace with given dimension dim or codimension codim (one of them has to be provided) in ambient space of dimension n. If real is true, then the extrinsic description is real. The subspace is generated by drawing each entry of the extrinsic description indepdently from a normal distribuation using randn.\n\nExample\n\njulia> rand_affine_subspace(3; dim = 1)\n1-dim. affine subspace {x|Ax=b} with eltype Complex{Float64}:\nA:\n2×3 Array{Complex{Float64},2}:\n  -1.73825+1.27987im   -0.0871343+0.840408im  -0.551957+0.106397im\n -0.597132-0.343965im   -0.122543-0.172715im   -1.04949+0.370917im\nb:\n2-element Array{Complex{Float64},1}:\n  0.47083334430689394 + 0.8099804422599071im\n -0.12018696822943896 + 0.11723026326952792im\n\njulia> rand_affine_subspace(4; codim = 1)\n3-dim. affine subspace {x|Ax=b} with eltype Complex{Float64}:\nA:\n1×4 Array{Complex{Float64},2}:\n 0.345705+0.0893881im  -0.430867-0.663249im  0.979969-0.569378im  -0.29722-0.192493im\nb:\n1-element Array{Complex{Float64},1}:\n 0.7749708228192062 + 0.9762873764567546im\n\n\n\n\n\n","category":"function"},{"location":"systems_homotopies/#Systems-and-Homotopies-1","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"Systems (AbstractSystem) and homotopies (AbstractHomotopy) are used for the numerical computations.","category":"page"},{"location":"systems_homotopies/#Systems-1","page":"Systems and Homotopies","title":"Systems","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"Systems (AbstractSystem) are the basic building blocks of homotopies.","category":"page"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AbstractSystem","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation.AbstractSystem","page":"Systems and Homotopies","title":"HomotopyContinuation.AbstractSystem","text":"AbstractSystem\n\nAn abstract type representing a polynomial system F(x).\n\nThe following systems are available:\n\nAffineChartSystem\nCompositionSystem\nFixedParameterSystem\nModelKitSystem\nRandomizedSystem\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#AffineChartSystem-1","page":"Systems and Homotopies","title":"AffineChartSystem","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AffineChartSystem\non_affine_chart(F::System, dims)","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation.AffineChartSystem","page":"Systems and Homotopies","title":"HomotopyContinuation.AffineChartSystem","text":"AffineChartSystem(F::AbstractSystem, v::PVector{T,N})\n\nGiven a system F(x) (ℙ^m_1    ℙ^m_N)  ℂⁿ this creates a new affine system F which operates on the affine chart defined by the vector v  ℙ^m_1    ℙ^m_N and the augmented conditions vᵀx = 1.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation.on_affine_chart-Tuple{System,Any}","page":"Systems and Homotopies","title":"HomotopyContinuation.on_affine_chart","text":"on_affine_chart(F::Union{System,AbstractSystem}, dimensions)\n\nConstruct an AffineChartSystem on a randomly generated chart v. Each entry is drawn idepdently from a univariate normal distribution.\n\n\n\n\n\n","category":"method"},{"location":"systems_homotopies/#CompositionSystem-1","page":"Systems and Homotopies","title":"CompositionSystem","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"CompositionSystem\ncompose","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation.CompositionSystem","page":"Systems and Homotopies","title":"HomotopyContinuation.CompositionSystem","text":"CompositionSystem(G::AbstractSystem, F::AbstractSystem)\n\nConstruct the system G(F(xp)p). Note that the parameters are passed to G and F are identical.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation.compose","page":"Systems and Homotopies","title":"HomotopyContinuation.compose","text":"compose(G::Union{AbstractSystem,System}, F::Union{AbstractSystem,System})\n\nConstruct the composition G(F(x)). You can also use the infix operator ∘ (written by \\circ).\n\nExample\n\njulia> @var a b c x y z\n\njulia> g = System([a * b * c]);\n\njulia> f = System([x+y, y + z, x + z]);\n\njulia> compose(g, f)\nComposition G ∘ F:\nF:\nModelKitSystem{(0xbb16b481c0808501, 1)}:\nCompiled: System of length 3\n 3 variables: x, y, z\n\n x + y\n y + z\n x + z\n\nG:\nModelKitSystem{(0xf0a2384a42428501, 1)}:\nCompiled: System of length 1\n 3 variables: a, b, c\n\n a*b*c\n\n\njulia> (g ∘ f)([x,y,z])\n1-element Array{Expression,1}:\n (x + z)*(y + z)*(x + y)\n\n\n\n\n\n","category":"function"},{"location":"systems_homotopies/#FixedParameterSystem-1","page":"Systems and Homotopies","title":"FixedParameterSystem","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"FixedParameterSystem\nfix_parameters","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation.FixedParameterSystem","page":"Systems and Homotopies","title":"HomotopyContinuation.FixedParameterSystem","text":"FixedParameterSystem(F:AbstractSystem, parameters)\n\nConstruct a system from the given AbstractSystem F with the given parameters fixed.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation.fix_parameters","page":"Systems and Homotopies","title":"HomotopyContinuation.fix_parameters","text":"fix_parameters(F::AbstractSystem, p)\n\nFix the parameters of the given system F. Returns a FixedParameterSystem.\n\n\n\n\n\n","category":"function"},{"location":"systems_homotopies/#ModelKitSystem-1","page":"Systems and Homotopies","title":"ModelKitSystem","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"ModelKitSystem","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation.ModelKitSystem","page":"Systems and Homotopies","title":"HomotopyContinuation.ModelKitSystem","text":"ModelKitSystem(F:System)\n\nConstruct a system from the given System F. The difference to F is that this compiles a straight line programm for the fast evaluation of F and that ModelKitSystem <: AbstractSystem.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#RandomizedSystem-1","page":"Systems and Homotopies","title":"RandomizedSystem","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"RandomizedSystem","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation.RandomizedSystem","page":"Systems and Homotopies","title":"HomotopyContinuation.RandomizedSystem","text":"RandomizedSystem(F::Union{System,AbstractSystem}, k::Integer) <: AbstractSystem\n\nGiven a n  N system F with n  N this constructs the system mathfrakR(F k)(x) = I AF(x) where I is a k  k identity matrix and A is random complex k  n matrix. See Chapter 13.5 in [SW05] for more details.\n\nRandomizedSystem(F::Union{System,AbstractSystem}, A::Matrix{ComplexF64})\n\nExplicitly provide the used randomization matrix A.\n\n[SW05]: Sommese, A. J., & Wampler, C. W. (2005). The Numerical Solution of Systems of Polynomials Arising in Engineering and Science. World Scientific.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#Homotopies-1","page":"Systems and Homotopies","title":"Homotopies","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"Homotopies (AbstractHomotopy) are at the heart of homotopy continuation. A homotopy is a parameterized family H(xt) of polynomial systems. By convention, homotopies are tracked from t=1 to t=0, i.e., H(x1) is considered the start system and H(x0) is the target system.","category":"page"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AbstractHomotopy","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation.AbstractHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation.AbstractHomotopy","text":"AbstractHomotopy\n\nAn abstract type representing a homotopy H(xt).\n\nThe following homotopies are available:\n\nAffineChartHomotopy\nAffineSubspaceHomotopy\nModelKitHomotopy\nParameterHomotopy\nStraightLineHomotopy\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#AffineChartHomotopy-1","page":"Systems and Homotopies","title":"AffineChartHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AffineChartHomotopy\non_affine_chart(F::Homotopy, dims)","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation.AffineChartHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation.AffineChartHomotopy","text":"AffineChartHomotopy(H::AbstractHomotopy, v::PVector{T,N})\n\nGiven a homotopy H(xt) (ℙ^m_1    ℙ^m_N)  ℂ  ℂⁿ this creates a new affine homotopy H which operates on the affine chart defined by the vector v  ℙ^m_1    ℙ^m_N and the augmented conditions vᵀx = 1.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation.on_affine_chart-Tuple{Homotopy,Any}","page":"Systems and Homotopies","title":"HomotopyContinuation.on_affine_chart","text":"on_affine_chart(H::Union{Homotopy,AbstractHomotopy}, proj_dims)\n\nConstruct an AffineChartHomotopy on a randomly generated chart v. Each entry is drawn idepdently from a univariate normal distribution.\n\n\n\n\n\n","category":"method"},{"location":"systems_homotopies/#AffineSubspaceHomotopy-1","page":"Systems and Homotopies","title":"AffineSubspaceHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"AffineSubspaceHomotopy\nset_subspaces!","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation.AffineSubspaceHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation.AffineSubspaceHomotopy","text":"AffineSubspaceHomotopy(F::System, V::AffineSubspace, W::AffineSubspace)\nAffineSubspaceHomotopy(F::AbstractSystem, V::AffineSubspace, W::AffineSubspace)\n\nCreates a homotopy H(xt) = (F  γ(t))(x) where γ(t) is a family of affine subspaces such that H(x1) = (F  V)(x) and H(x0) = (F  W)(x). Here γ(t) is the geodesic between V and W in the affine Grassmanian, i.e., it is the curve of minimal length connecting V and W. See also AffineSubspace and geodesic and the references therein.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#HomotopyContinuation.set_subspaces!","page":"Systems and Homotopies","title":"HomotopyContinuation.set_subspaces!","text":"set_subspaces!(H::AffineSubspaceHomotopy, start::AffineSubspace, target::AffineSubspace)\n\nUpdate the homotopy H to track from the affine subspace start to target.\n\n\n\n\n\n","category":"function"},{"location":"systems_homotopies/#ModelKitHomotopy-1","page":"Systems and Homotopies","title":"ModelKitHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"ModelKitHomotopy","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation.ModelKitHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation.ModelKitHomotopy","text":"ModelKitHomotopy(H::Homotopy, parameters = nothing)\n\nConstruct a homotopy from the given homotopy H with the given parameters fixed. The difference to H is that this compiles a straight line programm for the fast evaluation of H and that ModelKitHomotopy <: AbstractHomotopy.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#ParameterHomotopy-1","page":"Systems and Homotopies","title":"ParameterHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"ParameterHomotopy","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation.ParameterHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation.ParameterHomotopy","text":"ParameterHomotopy(F::Union{AbstractSystem,System}; start_parameters, target_parameters)\nParameterHomotopy(F::Union{AbstractSystem,System}, start_parameters, target_parameters)\n\nConstruct the parameter homotopy H(xt) = F(x t p + (1 - t) q) where p is start_parameters and q is target_parameters.\n\n\n\n\n\n","category":"type"},{"location":"systems_homotopies/#StraightLineHomotopy-1","page":"Systems and Homotopies","title":"StraightLineHomotopy","text":"","category":"section"},{"location":"systems_homotopies/#","page":"Systems and Homotopies","title":"Systems and Homotopies","text":"StraightLineHomotopy","category":"page"},{"location":"systems_homotopies/#HomotopyContinuation.StraightLineHomotopy","page":"Systems and Homotopies","title":"HomotopyContinuation.StraightLineHomotopy","text":"StraightLineHomotopy(G::System, F::System; gamma = 1.0)\nStraightLineHomotopy(G::AbstractSystem, F::AbstractSystem; gamma = 1.0)\n\nConstructs the straight line homotopy H(x t) = γ t G(x) + (1-t) F(x) where γ is gamma.\n\n\n\n\n\n","category":"type"},{"location":"solve_examples/#Solve-Examples-1","page":"Examples","title":"Solve Examples","text":"","category":"section"},{"location":"solve_examples/#A-First-Example-(no-start-system)-1","page":"Examples","title":"A First Example (no start system)","text":"","category":"section"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"We can solve the system F(xy) = (x^2+y^2+1 2x+3y-1) in the following way","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"using HomotopyContinuation #hide\n@var x y\nF = System([x^2+y^2+1, 2x+3y-1], variables = [x, y])\nsolve(F; show_progress = false) #hide\nsolve(F)","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"Here, the call","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"F = System([x^2+y^2+1, 2x+3y-1], variables = [x, y])","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"also determines the ordering of the variables in the solution vectors. By default, variables are ordered lexciographically. If this is okay, you can also call solve without first constructing a system, i.e.,","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"solve([x^2+y^2+1, 2x+3y-1])","category":"page"},{"location":"solve_examples/#Parameter-Homotopy-1","page":"Examples","title":"Parameter Homotopy","text":"","category":"section"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"Using the syntax","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"solve(F, startsolutions; start_parameters, target_parameters)","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"We can track the given start solutions alogn the parameter homotopy","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"H(x t) = F(x tp₁+(1-t)p₀)","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"where p₁ (=start_parameters) and p₀ (=target_parameters) are vectors of parameter values for F where F is a System depending on parameters.","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"Assume we want to perform a parameter homotopy H(xt) = F(x t1 0+(1-t)2 4) where","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"F(x a) = (x₁^2-a₁ x₁x₂-a₁+a₂)","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"and let's say we are only interested in tracking the solution 11. This can be accomplished as follows","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"using HomotopyContinuation #hide\n@var x[1:2] a[1:2]\nF = System([x[1]^2-a[1], x[1]*x[2]-a[1]+a[2]], parameters = a)\nstart_solutions = [[1, 1]]\np₁ = [1, 0]\np₀ = [2, 4]\nsolve(F, start_solutions; start_parameters=p₁, target_parameters=p₀, show_progress=false) #hide\nsolve(F, start_solutions; start_parameters=p₁, target_parameters=p₀)","category":"page"},{"location":"solve_examples/#Start-Target-Homotopy-1","page":"Examples","title":"Start Target Homotopy","text":"","category":"section"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"solve(G, F, start_solutions; options...)","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"This constructs the homotopy H(xt) = tG(x)+(1-t)F(x) to compute solutions of the system F. start_solutions is a list of solutions of G which are tracked to solutions of F.","category":"page"},{"location":"solve_examples/#","page":"Examples","title":"Examples","text":"using HomotopyContinuation #hide\n@var x y\nG = System([x^2+1,y+1])\nF = System([x^2+y^2+1, 2x+3y-1])\nsolve(G, F, [[im, -1], [-im, -1]]; show_progress = false) #hide\nsolve(G, F, [[im, -1], [-im, -1]])","category":"page"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"HomotopyContinuation.jl is a package for the numerical solution of systems of polynomial equations.","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"This documentation is a purely technical description of the package functionality. You can find tutorials, examples, how-to guides and explanations on our homepage JuliaHomotopyContinuation.org.","category":"page"},{"location":"#Contents-1","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Problem formulation","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"model_kit.md\",\n    \"linear_affine.md\",\n    \"systems_homotopies.md\",\n]\nDepth = 2","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Solving Systems","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"solve.md\",\n    \"result.md\",\n    \"solve_examples.md\",\n    \"start_systems.md\",\n]\nDepth = 2","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Trackers","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"endgame_tracker.md\",\n    \"tracker.md\",\n]\nDepth = 2","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Miscellaneous","category":"page"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"misc.md\",\n]\nDepth = 2","category":"page"}]
}
