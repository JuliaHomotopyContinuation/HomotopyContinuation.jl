<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solving general systems ¬∑ Homotopy Continuation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../index.html"><img class="logo" src="../assets/logo.png" alt="Homotopy Continuation logo"/></a><h1>Homotopy Continuation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li class="current"><a class="toctext" href>Solving general systems</a><ul class="internal"><li><a class="toctext" href="#Result-1">Result</a></li><li><a class="toctext" href="#Estimate-the-complexity-1">Estimate the complexity</a></li></ul></li><li><a class="toctext" href="../monodromy/">Solving paremeterized systems with monodromy</a></li><li><a class="toctext" href="../sorting/">Sorting arrays of solutions</a></li><li><a class="toctext" href="../path_tracker/">PathTracker</a></li><li><a class="toctext" href="../core_tracker/">CoreTracker</a></li><li><a class="toctext" href="../newton/">Newton&#39;s method</a></li><li><a class="toctext" href="../homotopies/">Homotopies</a></li><li><a class="toctext" href="../predictors-correctors/">Predictors and correctors</a></li><li><a class="toctext" href="../systems/">Data structures for polynomial systems</a></li><li><a class="toctext" href="../norms_distances/">Norms and distances</a></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>Solving general systems</a></li></ul><a class="edit-page" href="https://github.com/JuliaHomotopyContinuation/HomotopyContinuation.jl/blob/master/docs/src/solving.md"><span class="fa">ÔÇõ</span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>Solving general systems</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Solving-general-polynomial-systems-1" href="#Solving-general-polynomial-systems-1">Solving general polynomial systems</a></h1><p>The <a href="#HomotopyContinuation.solve"><code>solve</code></a> function is the most convenient way to solve general polynomial systems. For the mathematical background take a look at our <a href="https://www.juliahomotopycontinuation.org/guides/how-does-it-work/">How does it work?</a> guide.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.solve" href="#HomotopyContinuation.solve"><code>HomotopyContinuation.solve</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">solve(args...; options...)::Result</code></pre><p>The solve function takes many different arguments and options depending on your specific situation, but in the it always returns a <a href="#HomotopyContinuation.Result"><code>Result</code></a> containing the result of the computations. In the following we show the different inputs <code>solve</code> takes and at the end we list all possible options.</p><p><strong>Total Degree Homotopy</strong></p><pre><code class="language-none">solve(F; options...)</code></pre><p>Solve the system <code>F</code> using a start system computed from the degrees of the entries of <code>F</code>. The number of paths to track is equal to the total degree <code>d1‚ãØdn</code>, where <code>di</code> is the degree of the <code>i</code>th entry of <code>F</code>. <code>F</code> can be</p><ul><li><code>Vector{&lt;:MultivariatePolynomials.AbstractPolynomial}</code> (e.g. constructed by <code>@polyvar</code>)</li><li>A composition of polynomial systems constructed by <a href="../reference/#HomotopyContinuation.compose"><code>compose</code></a>.</li><li><a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a> (the system has to represent a <strong>homogeneous</strong> polynomial system.)</li></ul><p><strong>Example</strong></p><p>We can solve the system <span>$F(x,y) = (x^2+y^2+1, 2x+3y-1)$</span> in the following way:</p><pre><code class="language-julia">julia&gt; @polyvar x y;
julia&gt; solve([x^2+y^2+1, 2x+3y-1])
Result with 2 solutions
==================================
‚Ä¢ 2 non-singular solutions (0 real)
‚Ä¢ 0 singular solutions (0 real)
‚Ä¢ 2 paths tracked
‚Ä¢ random seed: 661766</code></pre><p><strong>Polyhedral Homotopy</strong></p><pre><code class="language-none">solve(F; start_system = :polyhedral, only_torus=false, options...)</code></pre><p>Solve the system <code>F</code> using a start system computed from the Newton Polytopes of the entries <code>F</code>. The number of paths to track is equal to the mixed volume of the Newton Polytopes of the entries of <code>F</code>. The mixed volume is at most the total degree of <code>F</code>. <code>F</code> can be</p><ul><li><code>Vector{&lt;:MultivariatePolynomials.AbstractPolynomial}</code> (e.g. constructed by <code>@polyvar</code>)</li><li>A composition of polynomial systems constructed by <a href="../reference/#HomotopyContinuation.compose"><code>compose</code></a>.</li><li><a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a> (the system has to represent a <strong>homogeneous</strong> polynomial system.)</li></ul><p>If <code>only_torus == true</code> then only solutions in the algebraic torus <span>$(‚ÑÇ\setminus \{0\})^n$</span> will be computed.</p><p><strong>Example</strong></p><p>We can solve the system <span>$F(x,y) = (x^2+y^2+1, 2x+3y-1)$</span> in the following way:</p><pre><code class="language-julia">julia&gt; @polyvar x y;
julia&gt; solve([x^2+y^2+1, 2x+3y-1]; start_system = :polyhedral)
Result with 2 solutions
==================================
‚Ä¢ 2 non-singular solutions (0 real)
‚Ä¢ 0 singular solutions (0 real)
‚Ä¢ 2 paths tracked
‚Ä¢ random seed: 222880

# Homogeneous Systems

If `F` has is homogeneous, we return results in projective space

### Examples</code></pre><p>julia julia&gt; @polyvar x y z; julia&gt; solve([x^2+y^2+z^2, 2x+3y-z]) Result with 2 solutions ================================== ‚Ä¢ 2 non-singular solutions (0 real) ‚Ä¢ 0 singular solutions (0 real) ‚Ä¢ 2 paths tracked ‚Ä¢ random seed: 291729</p><pre><code class="language-none">
If your polynomial system is already homogeneous, but you would like to consider it as an affine system
you can do</code></pre><p>julia @polyvar x y z solve([x^2+y^2+z^2, 2x+3y-z], homvar=z)</p><pre><code class="language-none">This yields the same result as `solve([x^2+y^2+1, 2x+3y-1])`.

# Multihomogeneous Systems

By exploiting the multi-homogenous structure of a polynomial system it is possible
to decrease the number of paths necessary to track.</code></pre><p>julia @polyvar x y</p><p><strong>Use variable groups to only track 2 paths instead of 4</strong></p><p>solve([x*y - 6, x^2 - 5], variable_groups=[(x,), (y,)])</p><pre><code class="language-none">To check whether a certain variable grouping is beneficial you can use the [`bezout_number`](@ref)
function.


# Start Target Homotopy

    solve(G, F, start_solutions; options...)

This constructs the homotopy ``H(x,t) = tG(x)+(1-t)F(x)`` to compute solutions of the
system `F`. `start_solutions` is a list of solutions of `G` which are tracked to solutions
of `F`.

### Example</code></pre><p>julia @polyvar x y G = [x^2-1,y-1] F = [x^2+y^2+z^2, 2x+3y-z] solve(G, F, [[1, 1], [-1, 1]])</p><pre><code class="language-none">
# Parameter Homotopy

    solve(F, startsolutions; parameters, start_parameters, target_parameters, start_gamma=nothing, target_gamma=nothing)

Solve the parameter homotopy</code></pre><p>math H(x, t) = F(x, (tŒ≥‚ÇÅp‚ÇÅ+(1-t)Œ≥‚ÇÄp‚ÇÄ) / (tŒ≥‚ÇÅ+(1-t)Œ≥‚ÇÄ)),</p><pre><code class="language-none">where ``p‚ÇÅ`` (=`start_parameters`) and ``p‚ÇÄ`` (=`target_parameters`) are vectors of parameter values for ``F`` and
``Œ≥‚ÇÅ`` (=`start_gamma`) and ``Œ≥‚ÇÄ`` (=`target_gamma`) are complex numbers.
If `start_parameters` or `target_parameters` is `nothing`, it is assumed that `Œ≥‚ÇÅ` and `Œ≥‚ÇÄ` are ``1``.
The input `parameters` specifies the variables of `F` which should be considered as parameters.
Necessarily we have `length(parameters) == length(p‚ÇÅ) == length(p‚ÇÄ)`.

    solve(F, startsolutions; parameters, p‚ÇÅ, p‚ÇÄ, Œ≥‚ÇÅ=nothing, Œ≥‚ÇÄ=nothing)

This is a unicode variant where `Œ≥‚ÇÅ=start_parameters`, `Œ≥‚ÇÄ=target_parameters`,
    `Œ≥‚ÇÅ=start_gamma`, Œ≥‚ÇÄ=`target_gamma`.

### Example
We want to solve a parameter homotopy ``H(x,t) := F(x; t[1, 0]+(1-t)[2, 4])`` where</code></pre><p>math F(x; a) := (x‚ÇÅ^2-a‚ÇÅ, x‚ÇÅx‚ÇÇ-a‚ÇÅ+a‚ÇÇ)</p><pre><code class="language-none">and let&#39;s say we are only intersted in tracking of ``[1,1]``.
This can be accomplished as follows</code></pre><p>julia @polyvar x[1:2] a[1:2] F = [x[1]^2-a[1], x[1]*x[2]-a[1]+a[2]] startsolutions = [[1, 1]] p‚ÇÅ = [1, 0] p‚ÇÄ = [3im, 0.5+2im] solve(F, startsolutions; parameters=a, start<em>parameters=p‚ÇÅ, target</em>parameters=p‚ÇÄ)</p><p><strong>If you like unicode this is also possible</strong></p><p>solve(F, startsolutions; parameters=a, p‚ÇÅ=p‚ÇÅ, p‚ÇÄ=p‚ÇÄ) ```</p><p><strong>Abstract Homotopy</strong></p><pre><code class="language-none">solve(H::AbstractHomotopy, start_solutions; options...)</code></pre><p>Solve the homotopy <code>H</code> by tracking the each solution of <span>$H(‚ãÖ, t)$</span> (as provided by <code>start_solutions</code>) from <span>$t=1$</span> to <span>$t=0$</span>. Note that <code>H</code> has to be a homotopy between <em>homogeneous</em> polynomial systems. If it should be considered as an affine system indicate which is the index of the homogenization variable, e.g. <code>solve(H, startsolutions, homvar=3)</code> if the third variable is the homogenization variable.</p><p><strong>Options</strong></p><p><strong>General options:</strong></p><ul><li><code>seed::Int</code>: The random seed used during the computations.</li><li><code>show_progress=true</code>: Whether a progress bar should be printed to standard out.</li><li><code>threading=true</code>: Enable or disable multi-threading.</li><li><code>path_result_details=:default</code>: The amount of information computed in each path result. Possible values are <code>:minimal</code> (minimal details), <code>:default</code> (default) and <code>:extensive</code> (all information possible).</li><li><code>homvar::Union{Int,MultivariatePolynomials.AbstractVariable}</code>: This considers the <em>homogeneous</em> system <code>F</code> as an affine system which was homogenized by <code>homvar</code>. If <code>F</code> is an <code>AbstractSystem</code> <code>homvar</code> is the index (i.e. <code>Int</code>) of the homogenization variable. If <code>F</code> is an <code>AbstractVariables</code> (e.g. created by <code>@polyvar x</code>) <code>homvar</code> is the actual variable used in the system <code>F</code>.</li><li><code>system::AbstractSystem</code>: A constructor to assemble a <a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a>. The default is <a href="../systems/#HomotopyContinuation.SPSystem"><code>SPSystem</code></a>. This constructor is only applied to the input of <code>solve</code>. The constructor is called with <code>system(polynomials, variables)</code> where <code>polynomials</code> is a vector of <code>MultivariatePolynomials.AbstractPolynomial</code>s and <code>variables</code> determines the variable ordering. If you experience significant compilation times, consider to change system to <code>FPSystem</code>.</li><li><code>homotopy::AbstractHomotopy</code>: A constructor to construct a <a href="../homotopies/#HomotopyContinuation.AbstractHomotopy"><code>AbstractHomotopy</code></a> for the totaldegree and start target homotopy. The default is <a href="../homotopies/#HomotopyContinuation.StraightLineHomotopy"><code>StraightLineHomotopy</code></a>. The constructor is called with <code>homotopy(start, target)</code> where <code>start</code> and <code>target</code> are homogeneous <a href="../systems/#HomotopyContinuation.AbstractSystem"><code>AbstractSystem</code></a>s.</li><li><code>affine_tracking::Bool=true</code>: Indicate whether path tracking should happen in affine space rather than projective space. Currently this is only supported for parameter homotopies.</li><li><code>path_jumping_check::Bool=true</code>: Enable a check whether one of the paths jumped to another one.</li></ul><p><strong>Path tracking specific options:</strong></p><ul><li><code>accuracy=1e-7</code>: The accuracy required during the path tracking.</li><li><code>corrector::AbstractCorrector</code>: The corrector used during in the predictor-corrector scheme. The default is <a href="../predictors-correctors/#HomotopyContinuation.NewtonCorrector"><code>NewtonCorrector</code></a>.</li><li><code>initial_step_size=0.1</code>: The size of the first step.</li><li><code>max_corrector_iters=2</code>: The maximal number of correction steps in a single step.</li><li><code>max_lost_digits::Real</code>: The tracking is terminated if we estimate that we loose more than <code>max_lost_digits</code> in the linear algebra steps. This threshold depends on the <code>precision</code> argument.</li><li><code>max_refinement_iters=5</code>: The maximal number of correction steps used to refine the final value.</li><li><code>max_steps=1_000</code>: The maximal number of iterations the path tracker has available. Note that this changes to <code>10_000</code> for parameter homotopies.</li><li><code>max_step_size=Inf</code>: The maximal step size.</li><li><code>min_step_size=1e-14</code>: The minimal step size.</li><li><code>precision::PrecisionOption=PRECISION_FIXED_64</code>: The precision used for evaluating the residual in Newton&#39;s method.</li><li><code>predictor::AbstractPredictor</code>: The predictor used during in the predictor-corrector scheme. The default is <a href="../predictors-correctors/#HomotopyContinuation.Heun"><code>Heun</code></a>()`.</li><li><code>refinement_accuracy=1e-8</code>: The precision required for the final value.</li><li><code>simple_step_size_alg=false</code>: Use a more simple step size algorithm.</li><li><code>steps_jacobian_info_update::Int=1</code>: Every n-th step a linear system will be solved using a QR factorization to obtain an estimate for the condition number of the Jacobian.</li><li><code>terminate_ill_conditioned::Bool=true</code>: Indicates whether the path tracking should be terminated for ill-conditioned paths. A path is considerd ill-conditioned if the condition number of the Jacobian is larger than ‚âà1e14 or if it is larger than 1e<code>max_lost_digits</code>.</li></ul><p><strong>Endgame specific options:</strong></p><ul><li><code>accuracy_eg::Float64=min(accuracy, 1e-5))</code>: It is possible to change the accuracy during the path tracking. Usually you want lower the accuracy.</li><li><code>cond_eg_start::Float64=1e4</code>: The endgame is only started if the condition of the Jacobian is larger than this threshold.</li><li><code>max_winding_number::Int=12</code>: This limits the maximal number of loops taken in applying Cauchy&#39;s formula.</li><li><code>min_cond_at_infinity::Float64=1e7</code>: A path is declared as going to infinity only if it&#39;s Jacobian is also larger than this threshold.</li><li><code>samples_per_loop::Int=12</code>: To compute singular solutions Cauchy&#39;s integral formula is used. The accuracy of the solutions increases with the number of samples per loop.</li><li><code>t_eg_start::Float64=0.1</code>: The endgame starts only if <code>t</code> is smaller than this threshold.</li><li><code>tol_val_inf_accurate::Float64=1e-4</code>: A valuation which would result in a path declared as going to infinity is only accepted if the estimated accuracy of the valuation is less than this threshold.</li><li><code>tol_val_finite_accurate::Float64=1e-3</code>: A valuation which would result in a proper solution is only accepted if the estimated accuracy of the valuation is less than this threshold. This is only affects solutions where the path has at some point near 0 a condition number larger than <code>cond_eg_start</code>.</li></ul><p>It is recommended to also take a look at the <a href="../path_tracker/#HomotopyContinuation.PathTracker"><code>PathTracker</code></a> documentation for some context.</p><p><strong>Overdetermined system specific options:</strong></p><ul><li><code>overdetermined_min_accuracy=1e-5</code>: The minimal accuracy a non-singular solution needs to have to be considered a solution of the original system.</li><li><code>overdetermined_min_residual=1e-3</code>: The minimal residual a singular solution needs to have to be considered a solution of the original system.</li></ul></div></div></section><h2><a class="nav-anchor" id="Result-1" href="#Result-1">Result</a></h2><p>A call to <a href="#HomotopyContinuation.solve"><code>solve</code></a> returns a <a href="#HomotopyContinuation.Result"><code>Result</code></a>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.Result" href="#HomotopyContinuation.Result"><code>HomotopyContinuation.Result</code></a> ‚Äî <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">Result{V&lt;:AbstractVector}</code></pre><p>The result of <code>solve</code>. This is a wrapper around the results of each single path (<a href="../path_tracker/#HomotopyContinuation.PathResult"><code>PathResult</code></a>) and it contains some additional informations like a random seed to replicate the result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.seed" href="#HomotopyContinuation.seed"><code>HomotopyContinuation.seed</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">seed(result)</code></pre><p>The random seed used in the computation.</p></div></div></section><p>The nonsingular solutions are obtained as follows.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nonsingular" href="#HomotopyContinuation.nonsingular"><code>HomotopyContinuation.nonsingular</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nonsingular(result::Results; conditions...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is non-singular. This is just a shorthand for <code>results(R; onlynonsingular=true, conditions...)</code>. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></div></section><p>The singular solutions are returned by using the following.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.singular" href="#HomotopyContinuation.singular"><code>HomotopyContinuation.singular</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">singular(R::Results; tol=1e10, multiple_results=false, kwargs...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is singular. A solution is labeled singular if the condition number is greater than <code>singulartol</code>, or if the winding number is &gt; 1. If <code>multiple_results=false</code> only one point from each cluster of multiple solutions is returned. If If <code>multiple_results=true</code> all singular solutions in <code>R</code> are returned. For the possible <code>kwargs</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></div></section><p>In order to analyse a <code>Result</code> we provide the following additional helper functions</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.results" href="#HomotopyContinuation.results"><code>HomotopyContinuation.results</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">results(result; onlyreal=false, realtol=1e-6, onlynonsingular=false,
            onlysigular=false, singulartol=1e10, onlyfinite=true, multiple_results=false)</code></pre><p>Return all <code>PathResult</code>s for which the given conditions apply.</p><p><strong>Example</strong></p><pre><code class="language-julia">R = solve(F)

# This gives us all PathResults considered non-singular and real (but still as a complex vector).
realsolutions = results(R, onlyreal=true, onlynonsingular=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.mapresults" href="#HomotopyContinuation.mapresults"><code>HomotopyContinuation.mapresults</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mapresults(f::Function, result; conditions...)</code></pre><p>Apply the function <code>f</code> to all <code>PathResult</code>s for which the given conditions apply. For the possible conditions see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia"># This gives us all solutions considered real (but still as a complex vector).
realsolutions = mapresults(solution, R, onlyreal=true)</code></pre></div></div><div><div><pre><code class="language-none">mapresults(f, result::MonodromyResult; onlyreal=false, realtol=1e-6)</code></pre><p>Apply the function <code>f</code> to all entries of <code>MonodromyResult</code> for which the given conditions apply.</p><p><strong>Example</strong></p><pre><code class="language-julia"># This gives us all solutions considered real (but still as a complex vector).
realsolutions = mapresults(solution, R, onlyreal=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.solutions" href="#HomotopyContinuation.solutions"><code>HomotopyContinuation.solutions</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">solutions(result; conditions...)</code></pre><p>Return all solution (as <code>Vector</code>s) for which the given conditions apply. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; @polyvar x y
julia&gt; result = solve([(x-2)y, y+x+3]);
julia&gt; solutions(result)
[[2.0+0.0im, -5.0+0.0im], [-3.0+0.0im, 0.0+0.0im]]</code></pre></div></div><div><div><pre><code class="language-none">solutions(loop::Loop)</code></pre><p>Get the solutions of the loop.</p></div></div><div><div><pre><code class="language-julia">solutions(result::MonodromyResult; onlyreal=false, realtol=1e-6)</code></pre><p>Return all solutions (as <code>SVector</code>s) for which the given conditions apply.</p><p><strong>Example</strong></p><pre><code class="language-julia">realsolutions = solutions(R, onlyreal=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.realsolutions" href="#HomotopyContinuation.realsolutions"><code>HomotopyContinuation.realsolutions</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">realsolutions(result; tol=1e-6, conditions...)</code></pre><p>Return all real solution (as <code>Vector</code>s of reals) for which the given conditions apply. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>. Note that <code>onlyreal</code> is always <code>true</code> and <code>realtol</code> is now <code>tol</code>.</p><p><strong>Example</strong></p><pre><code class="language-julia">julia&gt; @polyvar x y
julia&gt; result = solve([(x-2)y, y+x+3]);
julia&gt; realsolutions(result)
[[2.0, -5.0], [-3.0, 0.0]]</code></pre></div></div><div><div><pre><code class="language-none">realsolutions(res::MonodromyResult; tol=1e-6)</code></pre><p>Returns the solutions of <code>res</code> whose imaginary part has norm less than 1e-6.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.finite" href="#HomotopyContinuation.finite"><code>HomotopyContinuation.finite</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">finite(result::AffineResults; conditions...)</code></pre><p>Return all <code>PathResult</code>s for which the solution is finite. This is just a shorthand for <code>results(R; onlyfinite=true, conditions...)</code>. For the possible <code>conditions</code> see <a href="#HomotopyContinuation.results"><code>results</code></a>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="Base.real-Tuple{Union{Array{#s508,1} where #s508&lt;:PathResult, Result}}" href="#Base.real-Tuple{Union{Array{#s508,1} where #s508&lt;:PathResult, Result}}"><code>Base.real</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">real(result, tol=1e-6)</code></pre><p>Get all results where the solutions are real with the given tolerance <code>tol</code>. See <a href="../path_tracker/#Base.isreal-Tuple{PathResult}"><code>isreal</code></a> for details regarding the determination of &#39;realness&#39;.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.atinfinity" href="#HomotopyContinuation.atinfinity"><code>HomotopyContinuation.atinfinity</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">atinfinity(result::AffineResult)</code></pre><p>Get all results where the solutions is at infinity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.failed" href="#HomotopyContinuation.failed"><code>HomotopyContinuation.failed</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">failed(result)</code></pre><p>Get all results where the path tracking failed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.multiplicities!-Tuple{Result}" href="#HomotopyContinuation.multiplicities!-Tuple{Result}"><code>HomotopyContinuation.multiplicities!</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">multiplicities!(result::Result; tol=1e-6)</code></pre><p>Compute the multiplicities of the solutions in <code>result</code> with respect to the given tolerance.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.multiplicities-Tuple{Union{Array{#s508,1} where #s508&lt;:PathResult, Result}}" href="#HomotopyContinuation.multiplicities-Tuple{Union{Array{#s508,1} where #s508&lt;:PathResult, Result}}"><code>HomotopyContinuation.multiplicities</code></a> ‚Äî <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">multiplicities(V::Results; tol=1e-6)</code></pre><p>Returns a <code>Vector</code> of <code>Vector{PathResult}</code>s grouping the <code>PathResult</code>s whose solutions appear with multiplicities <em>greater</em> 1 in &#39;V&#39;. Two solutions are regarded as equal, when their pairwise distance is less than &#39;tol&#39;.</p></div></div></section><p>If you are interested in the number of solutions of a certain kind we also provide the following helper functions.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nresults" href="#HomotopyContinuation.nresults"><code>HomotopyContinuation.nresults</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nresults(result; onlyreal=false, realtol=1e-6, onlynonsingular=false, singulartol=1e10, onlyfinite=true)</code></pre><p>The number of solutions which satisfy the corresponding predicates.</p><p><strong>Example</strong></p><pre><code class="language-julia">result = solve(F)
# Get all non-singular results where all imaginary parts are smaller than 1e-8
nresults(result, onlyreal=true, realtol=1e-8, onlynonsingular=true)</code></pre></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nfinite" href="#HomotopyContinuation.nfinite"><code>HomotopyContinuation.nfinite</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nfinite(result)</code></pre><p>The number of finite solutions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nreal" href="#HomotopyContinuation.nreal"><code>HomotopyContinuation.nreal</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nreal(result; tol=1e-6)</code></pre><p>The number of real solutions where all imaginary parts of each solution are smaller than <code>tol</code>.</p></div></div><div><div><pre><code class="language-none">nreal(res::MonodromyResult; tol=1e-6)</code></pre><p>Counts how many solutions of <code>res</code> have imaginary part norm less than 1e-6.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nsingular" href="#HomotopyContinuation.nsingular"><code>HomotopyContinuation.nsingular</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nsingular(result; singulartol=1e10, multiplicitytol=1e-5, counting_multiplicities=false, kwargs...)</code></pre><p>The number of singular solutions. A solution is considered singular if its windingnumber is larger than 1 or the condition number is larger than <code>tol</code>. If <code>counting_multiplicities=true</code> the number of singular solutions times their multiplicities is returned.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nnonsingular" href="#HomotopyContinuation.nnonsingular"><code>HomotopyContinuation.nnonsingular</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nnonsingular(result; tol=1e-10)</code></pre><p>The number of non-singular solutions.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.natinfinity" href="#HomotopyContinuation.natinfinity"><code>HomotopyContinuation.natinfinity</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">natinfinity(result)</code></pre><p>The number of solutions at infinity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.nfailed" href="#HomotopyContinuation.nfailed"><code>HomotopyContinuation.nfailed</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">nafailed(result)</code></pre><p>The number of failed paths.</p></div></div></section><p>Also make sure to check the documentation for <a href="../path_tracker/#HomotopyContinuation.PathResult"><code>PathResult</code></a>.</p><h2><a class="nav-anchor" id="Estimate-the-complexity-1" href="#Estimate-the-complexity-1">Estimate the complexity</a></h2><p>We provide methods to compute the maximal number of solutions of polynomial systems.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.bezout_number" href="#HomotopyContinuation.bezout_number"><code>HomotopyContinuation.bezout_number</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">bezout_number(F::MPPolys; variable_groups=[variables(F)], homvars=nothing, parameters=nothing)
bezout_number(multidegrees, groups::VariableGroups)</code></pre><p>Compute the multi-homogeneous bezout number associated to the given system and variable groups.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="MixedSubdivisions.mixed_volume" href="#MixedSubdivisions.mixed_volume"><code>MixedSubdivisions.mixed_volume</code></a> ‚Äî <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">mixed_volume(F::Vector{&lt;:MP.AbstractPolynomialLike}; show_progress=true, algorithm=:regeneration)
mixed_volume(ùë®::Vector{&lt;:Matrix}; show_progress=true, algorithm=:regeneration)</code></pre><p>Compute the mixed volume of the given polynomial system <code>F</code> resp. represented by the support <code>ùë®</code>. There are two possible values for <code>algorithm</code>:</p><ul><li><code>:total_degree</code>: Use the total degree homotopy algorithm described in Section 7.1</li><li><code>:regeneration</code>: Use the tropical regeneration algorithm described in Section 7.2</li></ul></div></div></section><footer><hr/><a class="previous" href="../"><span class="direction">Previous</span><span class="title">Introduction</span></a><a class="next" href="../monodromy/"><span class="direction">Next</span><span class="title">Solving paremeterized systems with monodromy</span></a></footer></article></body></html>
