<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Solving parametrized systems with monodromy · HomotopyContinuation.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="HomotopyContinuation.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">HomotopyContinuation.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Solving polynomial systems</span><ul><li><a class="tocitem" href="../solving/">The solve function</a></li><li><a class="tocitem" href="../solver/">The Solver struct</a></li></ul></li><li class="is-active"><a class="tocitem" href>Solving parametrized systems with monodromy</a><ul class="internal"><li><a class="tocitem" href="#Basic-usage-1"><span>Basic usage</span></a></li><li><a class="tocitem" href="#Monodromy-Result-1"><span>Monodromy Result</span></a></li><li><a class="tocitem" href="#Analyse-a-MonodromyResult-1"><span>Analyse a MonodromyResult</span></a></li><li><a class="tocitem" href="#Verification-of-completeness-1"><span>Verification of completeness</span></a></li><li><a class="tocitem" href="#Group-actions-1"><span>Group actions</span></a></li><li><a class="tocitem" href="#Strategies-1"><span>Strategies</span></a></li></ul></li><li><a class="tocitem" href="../input/">Input</a></li><li><span class="tocitem">Tracking paths</span><ul><li><a class="tocitem" href="../path_tracker/">Path Tracker</a></li><li><a class="tocitem" href="../core_tracker/">Core Tracker</a></li></ul></li><li><a class="tocitem" href="../homotopies/">Homotopies</a></li><li><a class="tocitem" href="../systems/">Polynomial systems</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Solving parametrized systems with monodromy</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Solving parametrized systems with monodromy</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaHomotopyContinuation/HomotopyContinuation.jl/blob/master/docs/src/monodromy.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Solving-parametrized-systems-with-monodromy-1"><a class="docs-heading-anchor" href="#Solving-parametrized-systems-with-monodromy-1">Solving parametrized systems with monodromy</a><a class="docs-heading-anchor-permalink" href="#Solving-parametrized-systems-with-monodromy-1" title="Permalink"></a></h1><p>Next to <a href="../solving/#HomotopyContinuation.solve"><code>solve</code></a>, HomotopyContinuation.jl provides the function <a href="#HomotopyContinuation.monodromy_solve"><code>monodromy_solve</code></a>. Instead of taking two systems <code>f</code> and <code>g</code> and tracking an array of start solutions from <code>f</code> to <code>g</code>, <a href="#HomotopyContinuation.monodromy_solve"><code>monodromy_solve</code></a> takes as input a single system with parameters <code>p</code> and together with a start solution <code>s</code>. Then by tracking <code>s</code> around loops in the parameters <code>p</code>, <a href="#HomotopyContinuation.monodromy_solve"><code>monodromy_solve</code></a> tries to find new solutions until a stopping criterion is reached. Make sure to check out our <a href="https://www.juliahomotopycontinuation.org/guides/monodromy/">monodromy guide</a> for a more in depth introduction into this method.</p><h2 id="Basic-usage-1"><a class="docs-heading-anchor" href="#Basic-usage-1">Basic usage</a><a class="docs-heading-anchor-permalink" href="#Basic-usage-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.monodromy_solve" href="#HomotopyContinuation.monodromy_solve"><code>HomotopyContinuation.monodromy_solve</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">monodromy_solve(F, [sols, p]; parameters=..., options..., pathtrackerkwargs...)</code></pre><p>Solve a polynomial system <code>F(x;p)</code> with specified parameters and initial solutions <code>sols</code> by monodromy techniques. This makes loops in the parameter space of <code>F</code> to find new solutions. If <code>F</code> the parameters <code>p</code> only occur <em>linearly</em> in <code>F</code> it is eventually possible to compute a <em>start pair</em> <span>$(x₀, p₀)$</span> automatically. In this case <code>sols</code> and <code>p</code> can be omitted and the automatically generated parameters can be obtained with the <a href="#HomotopyContinuation.parameters-Tuple{MonodromyResult}"><code>parameters</code></a> function from the <a href="#HomotopyContinuation.MonodromyResult"><code>MonodromyResult</code></a>.</p><p><strong>Options</strong></p><ul><li><code>check_startsolutions=true</code>: If <code>true</code>, we do a Newton step for each entry of <code>sols</code>for checking if it is a valid startsolutions. Solutions which are not valid are sorted out.</li><li><code>distance_function=euclidean_distance</code>: The distance function used for <a href="../reference/#HomotopyContinuation.UniquePoints"><code>UniquePoints</code></a>.</li><li><code>done_callback=always_false</code>: A callback to end the computation early. This function takes 2 arguments. The first one is the new solution <code>x</code> and the second one are all current solutions (including <code>x</code>). Return <code>true</code> if the compuation is done.</li><li><code>equivalence_classes=true</code>: This only applies if there is at least one group action supplied. We then consider two solutions in the same equivalence class if we can transform one to the other by the supplied group actions. We only track one solution per equivalence class.</li><li><code>identical_tol::Float64=1e-6</code>: The tolerance with which it is decided whether two solutions are identical.</li><li><code>group_action=nothing</code>: A function taking one solution and returning other solutions if there is a constructive way to obtain them, e.g. by symmetry.</li><li><code>group_actions=nothing</code>: If there is more than one group action you can use this to chain the application of them. For example if you have two group actions <code>foo</code> and <code>bar</code> you can set <code>group_actions=[foo, bar]</code>. See <a href="#HomotopyContinuation.GroupActions"><code>GroupActions</code></a> for details regarding the application rules.</li><li><code>max_loops_no_progress::Int=10</code>: The maximal number of iterations (i.e. loops generated) without any progress.</li><li><code>min_solutions</code>: The minimal number of solutions before a stopping heuristic is applied. By default this is half of <code>target_solutions_count</code> if applicable otherwise 1.</li><li><code>parameter_sampler=independent_normal</code>: A function taking the parameter <code>p</code> and returning a new random parameter <code>q</code>. By default each entry of the parameter vector is drawn independently from the univariate normal distribution.</li><li><code>resuse_loops::Symbol=:all</code>: Strategy to reuse other loops for new found solutions. <code>:all</code> propagates a new solution through all other loops, <code>:random</code> picks a random loop, <code>:none</code> doesn&#39;t reuse a loop.</li><li><code>show_progress=true</code>: Enable a progress meter.</li><li><code>strategy</code>: The strategy used to create loops. If <code>F</code> only depends linearly on <code>p</code> this will be <a href="#HomotopyContinuation.Petal"><code>Petal</code></a>. Otherwise this will be <a href="#HomotopyContinuation.Triangle"><code>Triangle</code></a> with weights if <code>F</code> is a real system.</li><li><code>target_solutions_count=nothing</code>: The computations are stopped if this number of solutions is reached.</li><li><code>threading = true</code>: Enable multithreading of the path tracking.</li><li><code>timeout=float(typemax(Int))</code>: The maximal number of <em>seconds</em> the computation is allowed to run.</li></ul></div></section></article><h2 id="Monodromy-Result-1"><a class="docs-heading-anchor" href="#Monodromy-Result-1">Monodromy Result</a><a class="docs-heading-anchor-permalink" href="#Monodromy-Result-1" title="Permalink"></a></h2><p>A call to <a href="#HomotopyContinuation.monodromy_solve"><code>monodromy_solve</code></a> returns a <a href="#HomotopyContinuation.MonodromyResult"><code>MonodromyResult</code></a>:</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.MonodromyResult" href="#HomotopyContinuation.MonodromyResult"><code>HomotopyContinuation.MonodromyResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">MonodromyResult</code></pre><p>The monodromy result contains the result of the <code>monodromy_solve</code> computation.</p></div></section></article><h2 id="Analyse-a-MonodromyResult-1"><a class="docs-heading-anchor" href="#Analyse-a-MonodromyResult-1">Analyse a MonodromyResult</a><a class="docs-heading-anchor-permalink" href="#Analyse-a-MonodromyResult-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.solutions-Tuple{MonodromyResult}" href="#HomotopyContinuation.solutions-Tuple{MonodromyResult}"><code>HomotopyContinuation.solutions</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solutions(result::MonodromyResult; only_real=false, real_tol=1e-6)</code></pre><p>Return all solutions (as <code>SVector</code>s) for which the given conditions apply.</p><p><strong>Example</strong></p><pre><code class="language-julia">real_solutions = solutions(R, only_real=true)</code></pre></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.parameters-Tuple{MonodromyResult}" href="#HomotopyContinuation.parameters-Tuple{MonodromyResult}"><code>HomotopyContinuation.parameters</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">parameters(r::MonodromyResult)</code></pre><p>Return the parameters corresponding to the given result <code>r</code>.</p></div></section></article><h2 id="Verification-of-completeness-1"><a class="docs-heading-anchor" href="#Verification-of-completeness-1">Verification of completeness</a><a class="docs-heading-anchor-permalink" href="#Verification-of-completeness-1" title="Permalink"></a></h2><p>It is possible to verify after the computation that <a href="#HomotopyContinuation.monodromy_solve"><code>monodromy_solve</code></a> has found all solutions.</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.verify_solution_completeness" href="#HomotopyContinuation.verify_solution_completeness"><code>HomotopyContinuation.verify_solution_completeness</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">verify_solution_completeness(F, res::MonodromyResult;
                             parameters=..., trace_tol=1e-6, options...)</code></pre><p>Verify that the monodromy computation found all solutions by <a href="#HomotopyContinuation.monodromy_solve"><code>monodromy_solve</code></a>. This uses a trace test as described in <sup class="footnote-reference"><a id="citeref-LRS18" href="#footnote-LRS18">[LRS18]</a></sup>. The trace is a numerical value which is 0 if all solutions are found, for this the <code>trace_tol</code> keyword argument is used. The function returns <code>nothing</code> if some computation couldn&#39;t be carried out. Otherwise returns a boolean. Note that this function requires the computation of solutions to another polynomial system using monodromy. This routine can return <code>false</code> although all solutions are found if this additional solution set is not complete. The <code>options...</code> arguments can be everything which is accepted by <code>solve</code> and <code>monodromy_solve</code>.</p><p><strong>Example</strong></p><pre><code class="language-none">julia&gt; @polyvar x y a b c;

julia&gt; f = x^2+y^2-1;

julia&gt; l = a*x+b*y+c;

julia&gt; res = monodromy_solve([f,l], [-0.6-0.8im, -1.2+0.4im], [1,2,3]; parameters=[a,b,c])
MonodromyResult
==================================
• 2 solutions (0 real)
• return code → heuristic_stop
• 44 tracked paths
• seed → 367230

julia&gt; verify_solution_completeness([f,l], res; parameters=[a,b,c], trace_tol = 1e-8)
[ Info: Compute additional witnesses for completeness...
[ Info: Found 2 additional witnesses
[ Info: Compute trace...
[ Info: Norm of trace: 1.035918995391323e-15
true</code></pre><pre><code class="language-none">verify_solution_completeness(F, S, p; parameters=..., kwargs...)</code></pre><p>Verify the solution completeness using the computed solutions <code>S</code> to the parameter <code>p</code>.</p><pre><code class="language-none">verify_solution_completeness(TTS, S, W₁₀, p₀::Vector{&lt;:Number}, l₀)</code></pre><p>Use the already computeded additional witnesses <code>W₁₀</code>. You want to obtain <code>TTS</code>, <code>W₁₀</code> and <code>l₀</code> as the output from <a href="#HomotopyContinuation.solution_completeness_witnesses"><code>solution_completeness_witnesses</code></a>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.solution_completeness_witnesses" href="#HomotopyContinuation.solution_completeness_witnesses"><code>HomotopyContinuation.solution_completeness_witnesses</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">solution_completeness_witnesses(F, S, p; parameters=..., kwargs...)</code></pre><p>Compute the additional necessary witnesses. Returns a triple <code>(W₁₀, TTS, l)</code> containing the additional witnesses <code>W₁₀</code>, a trace test system <code>TTS</code> and the parameters <code>l</code> for <code>TTS</code>.</p></div></section></article><h2 id="Group-actions-1"><a class="docs-heading-anchor" href="#Group-actions-1">Group actions</a><a class="docs-heading-anchor-permalink" href="#Group-actions-1" title="Permalink"></a></h2><p>If there is a group acting on the solution set of the polynomial system this can provided with the <code>group_action</code> keyword for single group actions or with the <code>group_actions</code> keyword for compositions of group actions. These will be internally transformed into <code>GroupActions</code>.</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.GroupActions" href="#HomotopyContinuation.GroupActions"><code>HomotopyContinuation.GroupActions</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">GroupActions(actions::Function...)</code></pre><p>Store a bunch of group actions <code>(f1, f2, f3, ...)</code>. Each action has to return a tuple. The actions are applied in the following sense</p><ol><li>f1 is applied on the original solution <code>s</code></li><li>f2 is applied on <code>s</code> and the results of 1</li><li>f3 is applied on <code>s</code> and the results of 1) and 2)</li></ol><p>and so on</p><p><strong>Example</strong></p><pre><code class="language-julia-repl">julia&gt; f1(s) = (s * s,);

julia&gt; f2(s) = (2s, -s, 5s);

julia&gt; f3(s) = (s + 1,);

julia&gt; GroupActions(f1)(3)
(3, 9)

julia&gt; GroupActions(f1, f2)(3)
(3, 9, 6, -3, 15, 18, -9, 45)

julia&gt; GroupActions(f1,f2, f3)(3)
(3, 9, 6, -3, 15, 18, -9, 45, 4, 10, 7, -2, 16, 19, -8, 46)</code></pre></div></section></article><p>To help with the more common group actions we provide some helper functions:</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.SymmetricGroup" href="#HomotopyContinuation.SymmetricGroup"><code>HomotopyContinuation.SymmetricGroup</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">SymmetricGroup(n)</code></pre><p>Group action of the symmetric group S(n).</p></div></section></article><h2 id="Strategies-1"><a class="docs-heading-anchor" href="#Strategies-1">Strategies</a><a class="docs-heading-anchor-permalink" href="#Strategies-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.Triangle" href="#HomotopyContinuation.Triangle"><code>HomotopyContinuation.Triangle</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Triangle(;useweights=true)</code></pre><p>A triangle is a loop consisting of the main node and two addtional nodes. If <code>weights</code> is true the edges are equipped with additional random weights. Note that this is usually only necessary for real parameters.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.Petal" href="#HomotopyContinuation.Petal"><code>HomotopyContinuation.Petal</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">Petal()</code></pre><p>A petal is a loop consisting of the main node and one other node connected by two edges with different random weights.</p></div></section></article><section class="footnotes is-size-7"><ul><li class="footnote" id="footnote-LRS18"><a class="tag is-link" href="#citeref-LRS18">LRS18</a>Leykin, Anton, Jose Israel Rodriguez, and Frank Sottile. &quot;Trace test.&quot; Arnold Mathematical Journal 4.1 (2018): 113-125.</li></ul></section></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../solver/">« The Solver struct</a><a class="docs-footer-nextpage" href="../input/">Input »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Sunday 1 December 2019 14:32">Sunday 1 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
