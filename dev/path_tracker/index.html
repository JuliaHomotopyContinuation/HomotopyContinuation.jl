<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>PathTracker · Homotopy Continuation</title><link href="https://cdnjs.cloudflare.com/ajax/libs/normalize/4.2.0/normalize.min.css" rel="stylesheet" type="text/css"/><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.2.0/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link href="../assets/documenter.css" rel="stylesheet" type="text/css"/></head><body><nav class="toc"><a href="../"><img class="logo" src="../assets/logo.png" alt="Homotopy Continuation logo"/></a><h1>Homotopy Continuation</h1><select id="version-selector" onChange="window.location.href=this.value" style="visibility: hidden"></select><form class="search" id="search-form" action="../search/"><input id="search-query" name="q" type="text" placeholder="Search docs"/></form><ul><li><a class="toctext" href="../">Introduction</a></li><li><a class="toctext" href="../solving/">Solving general systems</a></li><li><a class="toctext" href="../monodromy/">Solving parametrized systems with monodromy</a></li><li class="current"><a class="toctext" href>PathTracker</a><ul class="internal"><li><a class="toctext" href="#PathResult-1">PathResult</a></li><li><a class="toctext" href="#Low-level-API-1">Low-level API</a></li></ul></li><li><a class="toctext" href="../core_tracker/">CoreTracker</a></li><li><a class="toctext" href="../homotopies/">Homotopies</a></li><li><a class="toctext" href="../systems/">Polynomial systems</a></li><li><a class="toctext" href="../reference/">Reference</a></li></ul></nav><article id="docs"><header><nav><ul><li><a href>PathTracker</a></li></ul><a class="edit-page" href="https://github.com/JuliaHomotopyContinuation/HomotopyContinuation.jl/blob/master/docs/src/path_tracker.md"><span class="fa"></span> Edit on GitHub</a></nav><hr/><div id="topbar"><span>PathTracker</span><a class="fa fa-bars" href="#"></a></div></header><h1><a class="nav-anchor" id="Path-Tracker-1" href="#Path-Tracker-1">Path Tracker</a></h1><p>The <a href="../solving/#HomotopyContinuation.solve"><code>solve</code></a> routine is only a thin wrapper around <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a>. Therefore you can also use <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a> directly. This is for example a good choice if you have to solve the same problem many times.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.PathTracker" href="#HomotopyContinuation.PathTracker"><code>HomotopyContinuation.PathTracker</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PathTracker</code></pre><p>The <code>PathTracker</code> combines the path tracking (with <a href="../core_tracker/#HomotopyContinuation.CoreTracker"><code>CoreTracker</code></a>) with an <em>endgame</em> routine. The <em>endgame</em>  is the name for special algorithms the end of the path tracking. These enable to detect if a path is diverging or if it ends in a singular solution. The <code>PathTracker</code> is more opinionated than the <code>CoreTracker</code> and implements additional logic to handle numerical difficult solutions. In particular it always reparametrizes a solution path to use a logarithmic time scale, i.e., <span>$x(t) → x(e^{-s})$</span> and we track for <span>$s$</span> from <span>$0$</span> to <span>$∞$</span>.</p><p>In order to construct a <code>PathTracker</code> it is recommended to use the <a href="#HomotopyContinuation.pathtracker"><code>pathtracker</code></a> and <a href="#HomotopyContinuation.pathtracker_startsolutions"><code>pathtracker_startsolutions</code></a> helper functions. With a <code>PathTracker</code> constructed you can track a single path using the <a href="../core_tracker/#HomotopyContinuation.track"><code>track</code></a> method. The result of this will be a <a href="#HomotopyContinuation.PathResult"><code>PathResult</code></a>.</p><p>The <code>PathTracker</code> assumes that the provided homotopy <code>H</code> is defined in such a way that <code>H(x,1)</code> is the start system and <code>H(x,0)</code> the target system. During the path tracking an approximation of the valuation of a Puiseux series expansion of the solution is computed. This is used to decide whether a path is diverging. Before a certain treshold (<code>s_always_consider_valuation</code>) this approximation is only trusted if a path gives some sign of ill-conditioning. To compute singular solutions the <em>Cauchy endgame</em> is used which is based on Cauchy&#39;s integral formula. For this we have to track solutions along a loop around the origin. The number of loops necessary to arrive back at the start point is called the <em>winding number</em>.</p><p><strong>Options</strong></p><p>The path tracker accepts all options which <a href="../core_tracker/#HomotopyContinuation.CoreTracker"><code>CoreTracker</code></a> accepts. Furthermore the following options are accepted:</p><ul><li><code>at_infinity_check</code>: This is true if the provided start system is an affine polynomial system.</li><li><code>endgame_start</code> (default <code>2.0</code>): The value of <code>s</code> where the endgame is started earliest.</li><li><code>max_winding_number</code> (default <code>12</code>): The maximal winding number tried in the Cauchy endgame.</li><li><code>min_accuracy</code> (default <code>1e-5</code>): The <code>PathTracker</code> automatically lowers the desired accuracy automatically to <code>min_accuracy</code> if path tracking would fail othwerwise (since the desired cannot be reached)</li><li><code>min_cond_eg</code> (default <code>1e5</code>): The minimal condition number before the Cauchy endgame is started or a path is cut off.</li><li><code>min_step_size_before_eg</code> (default <code>exp2(-40)</code>): The minimal allowed step size before the endgame starts.</li><li><code>min_step_size_eg</code> (default <code>exp2(-120)</code>): The minimal allowed step size during the endgame. This is also control what is considered <code>∞</code> for the path tracking.</li><li><code>s_always_consider_valuation</code> (default <code>-log(1e-16)</code>) A threshold after which we always consider the valuation.</li><li><code>samples_per_loop (default</code>8`): The number of samples used during the endgame.</li><li><code>precision_strategy</code> (default <code>:adaptive_finite</code>): This controls whether <code>H(x,t)</code> is possibly evaluated with higher than machine precision during the endgame (the Jacobian is always computed with machine precision). The <code>:adaptive_finite</code> allows this only if we are optimistic that we can still obtain a finite solution. Other options are <code>:adaptive_never</code> where this is never allowed and <code>:adaptive_always</code> where it is always enabled. ``</li></ul></div></div></section><p>The easiest way to construct a <code>PathTracker</code>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.pathtracker_startsolutions" href="#HomotopyContinuation.pathtracker_startsolutions"><code>HomotopyContinuation.pathtracker_startsolutions</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pathtracker_startsolutions(args...; kwargs...)</code></pre><p>Construct a <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a> and start solutions in the same way <a href="../solving/#HomotopyContinuation.solve"><code>solve</code></a> does it. This also takes the same input arguments as <code>solve</code>. This is convenient if you want to investigate single paths.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.pathtracker" href="#HomotopyContinuation.pathtracker"><code>HomotopyContinuation.pathtracker</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">pathtracker(args...; kwargs...)</code></pre><p>Construct a <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a> in the same way <a href="../solving/#HomotopyContinuation.solve"><code>solve</code></a> does it. This also takes the same input arguments as <code>solve</code> with the exception that you do not need to specify startsolutions.</p><p><strong>Examples</strong></p><p><strong>Obtain single solution</strong></p><p>We want to construct a path tracker to track a parametrized system <code>f</code> with parameters <code>p</code> from the parameters <code>a</code> to <code>b</code>.</p><pre><code class="language-julia">tracker = pathtracker(f, parameters=p, p₁=a, p₀=b)</code></pre><p>You then can obtain a single solution at <code>b</code> by using</p><pre><code class="language-julia">x_b = solution(track(tracker, x_a))</code></pre></div></div></section><p>To track a single path you can use the <a href="../core_tracker/#HomotopyContinuation.track"><code>track</code></a> and <a href="../core_tracker/#HomotopyContinuation.track!-Tuple{CoreTracker,AbstractArray{T,1} where T,Number,Number}"><code>track!</code></a> methods.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.track-Tuple{PathTracker,Any}" href="#HomotopyContinuation.track-Tuple{PathTracker,Any}"><code>HomotopyContinuation.track</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">track(tracker::PathTracker, x₁;
        path_number=nothing,
        details::Symbol=:default,
        start_parameters = nothing,
        target_parameters = nothing)</code></pre><p>Track the path <code>x(t)</code> with start solution <code>x₁</code> from <span>$1$</span> towards <span>$0$</span>. Returns a <a href="#HomotopyContinuation.PathResult"><code>PathResult</code></a>.</p><p>The <code>details</code> options controls the level of details of the informations available in the <a href="#HomotopyContinuation.PathResult"><code>PathResult</code></a>. If <code>tracker</code> uses a parameter homotopy you can set the start and target parameters by setting the corresponding fields. To investigate the behaviour of a particular take a look at <a href="../reference/#HomotopyContinuation.path_info"><code>path_info</code></a>.</p></div></div></section><h2><a class="nav-anchor" id="PathResult-1" href="#PathResult-1">PathResult</a></h2><p>For each path we return a <a href="#HomotopyContinuation.PathResult"><code>PathResult</code></a> containing the detailed information about the single path.</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.PathResult" href="#HomotopyContinuation.PathResult"><code>HomotopyContinuation.PathResult</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">PathResult{V&lt;:AbstractVector}</code></pre><p>A <code>PathResult</code> is the result of tracking of a path with <a href="../core_tracker/#HomotopyContinuation.track"><code>track</code></a> using a <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>return_code</code>: See the list of return codes below.</li><li><code>solution::V</code>: The solution vector.</li><li><code>t::Float64</code>: The value of <code>t</code> at which <code>solution</code> was computed. Note that if <code>return_code</code> is <code>:at_infinity</code>, then <code>t</code> is the value when this was decided.</li><li><code>accuracy::Float64</code>: An approximation of <span>$||x-x̄||$</span> where <span>$x$</span> is the computed solution and <span>$x̄$</span> is the true solution.</li><li><code>residual::Float64</code>: The value of the infinity-norm of <code>H(solution, 0)</code>.</li><li><code>multiplicity::Union{Nothing, Int}</code> is the multiplicity of the <code>solution</code>. This is only assigned by <a href="../solving/#HomotopyContinuation.singular"><code>singular</code></a>.</li><li><code>condition_jacobian::Union{Nothing, Float64}</code>: This is the condition number of the row-equilibrated Jacobian at the solution. A high condition number indicates a singularity.</li><li><code>winding_number:Union{Nothing, Int}</code>: The estimated winding number. This is a lower bound on the multiplicity of the solution.</li><li><code>start_solution::Union{Nothing, Int}</code>: The start solution of the path.</li><li><code>accepted_steps::Int</code>: The number of accepted steps during the path tracking.</li><li><code>rejected_steps::Int</code>: The number of rejected steps during the path tracking.</li><li><code>valuation::Union{Nothing, Vector{Float64}}</code>: An approximation of the valuation of the Puiseux series expansion of <code>x(t)</code>.</li><li><code>valuation_accuracy::Union{Nothing, Vector{Float64}}</code>: An estimate of the accuracy of the valuation of the Puiseux series expansion of <code>x(t)</code>.</li></ul><p><strong>Return codes</strong></p><p>These is the list of possible return codes:</p><ul><li><code>:success</code>: The <code>PathTracker</code> obtained a solution.</li><li><code>:at_infinity</code>: The <code>PathTracker</code> stopped the tracking of the path since it determined that that path is diverging towards infinity.</li><li><code>:terminated_callback</code>: One of the optional <code>PathTracker</code> callbacks terminated the tracking.</li><li><code>:terminated_max_iters</code>: The <code>PathTracker</code> terminated since it reached the limit accuracy.</li><li><code>:terminated_invalid_startvalue</code>: The <code>PathTracker</code> terminated since the provided start value is invalid.</li><li><code>:terminated_step_size_too_small</code>: The <code>PathTracker</code> terminated since the step size became smaller than the provided threshold.</li><li><code>:terminated_accuracy_limit</code>: The <code>PathTracker</code> terminated since the problem was too ill-conditioned to be tracked further with the desired minimal accuracy.</li><li><code>:terminated_ill_conditioned</code>: The <code>PathTracker</code> terminated since the Jacobian of the homotopy was too ill-conditioned.</li><li><code>:post_check_failed</code>: The verification of a non-singular solution failed.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-none"> PathResult(tracker::PathTracker,
            start_solution=nothing,
            path_number::Union{Nothing,Int}=nothing;
            details=:default)</code></pre><p>Construct a <code>PathResult</code> using the current state of the <code>PathTracker</code>. Possible values for <code>details</code> are <code>:minimal</code> (minimal details), <code>:default</code> (default) and <code>:extensive</code> (all information possible).</p></div></div></section><p>The following helper functions are provided</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.solution-Tuple{PathResult}" href="#HomotopyContinuation.solution-Tuple{PathResult}"><code>HomotopyContinuation.solution</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">solution(r::PathResult)</code></pre><p>Get the solution of the path.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.accuracy-Tuple{PathResult}" href="#HomotopyContinuation.accuracy-Tuple{PathResult}"><code>HomotopyContinuation.accuracy</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">accuracy(r::PathResult)</code></pre><p>Get the accuracy of the solution. This is an estimate of the (relative) distance to the true solution.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.residual-Tuple{PathResult}" href="#HomotopyContinuation.residual-Tuple{PathResult}"><code>HomotopyContinuation.residual</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">residual(r::PathResult)</code></pre><p>Get the residual of the solution <span>$x$</span> of the path, i.e., <span>$||H(x, 0)||₂$</span>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.winding_number-Tuple{PathTracker}" href="#HomotopyContinuation.winding_number-Tuple{PathTracker}"><code>HomotopyContinuation.winding_number</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">winding_number(tracker::PathTracker)</code></pre><p>Obtain the estimate of the winding number computed by the <code>PathTracker</code>. Returns <code>nothing</code> if the Cauchy endgame was not run.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.multiplicity-Tuple{PathResult}" href="#HomotopyContinuation.multiplicity-Tuple{PathResult}"><code>HomotopyContinuation.multiplicity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">multiplicity(P::PathResult)</code></pre><p>Returns the multiplicity of <code>P</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.condition_jacobian-Tuple{PathResult}" href="#HomotopyContinuation.condition_jacobian-Tuple{PathResult}"><code>HomotopyContinuation.condition_jacobian</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">condition_jacobian(r::PathResult)</code></pre><p>Return the condition number of the Jacobian of the result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="LinearAlgebra.cond-Tuple{PathResult}" href="#LinearAlgebra.cond-Tuple{PathResult}"><code>LinearAlgebra.cond</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">cond(r::PathResult)</code></pre><p>Return the condition number of the Jacobian of the result.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.start_solution-Tuple{PathResult}" href="#HomotopyContinuation.start_solution-Tuple{PathResult}"><code>HomotopyContinuation.start_solution</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">start_solution(r::PathResult)</code></pre><p>Get the start solution of the path.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.is_real-Tuple{PathResult}" href="#HomotopyContinuation.is_real-Tuple{PathResult}"><code>HomotopyContinuation.is_real</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_real(r::PathResult; tol=1e-6)</code></pre><p>We consider a result as <code>real</code> if the 2-norm of the imaginary part of the solution is at most <code>tol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.is_success-Tuple{PathResult}" href="#HomotopyContinuation.is_success-Tuple{PathResult}"><code>HomotopyContinuation.is_success</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_success(r::PathResult)</code></pre><p>Checks whether the path is successfull.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.is_failed-Tuple{PathResult}" href="#HomotopyContinuation.is_failed-Tuple{PathResult}"><code>HomotopyContinuation.is_failed</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_failed(r::PathResult)</code></pre><p>Checks whether the path failed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.is_affine-Tuple{PathResult}" href="#HomotopyContinuation.is_affine-Tuple{PathResult}"><code>HomotopyContinuation.is_affine</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_affine(pathresult)</code></pre><p>Return`s true if the solution is an affine vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.is_projective-Tuple{PathResult}" href="#HomotopyContinuation.is_projective-Tuple{PathResult}"><code>HomotopyContinuation.is_projective</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_projective(r::PathResult)</code></pre><p>Return`s true if the solution is a projective vector.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.is_at_infinity-Tuple{PathResult}" href="#HomotopyContinuation.is_at_infinity-Tuple{PathResult}"><code>HomotopyContinuation.is_at_infinity</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_at_infinity(r::PathResult)</code></pre><p>Checks whether the path goes to infinity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.is_singular-Tuple{PathResult}" href="#HomotopyContinuation.is_singular-Tuple{PathResult}"><code>HomotopyContinuation.is_singular</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_singular(r::PathResult; tol=1e10)</code></pre><p>Checks whether the path result is singular. This is true if the multiplicity is larger than  1 or if the condition number of the Jacobian is larger than <code>tol</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.is_nonsingular-Tuple{PathResult}" href="#HomotopyContinuation.is_nonsingular-Tuple{PathResult}"><code>HomotopyContinuation.is_nonsingular</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">is_nonsingular(r::PathResult; tol=1e10)</code></pre><p>Checks whether the path result is non-singular. This is true if it is not singular.</p></div></div></section><h2><a class="nav-anchor" id="Low-level-API-1" href="#Low-level-API-1">Low-level API</a></h2><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.track!-Tuple{PathTracker,Any}" href="#HomotopyContinuation.track!-Tuple{PathTracker,Any}"><code>HomotopyContinuation.track!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">track!(tracker::PathTracker, x₁)::PathTrackerStatus.states</code></pre><p>Track the path <code>x(t)</code> with start solution <code>x₁</code> from <span>$1$</span> towards <span>$0$</span>. Returns a <a href="#HomotopyContinuation.PathTrackerStatus.states"><code>PathTrackerStatus.states</code></a>.</p></div></div></section><p>In the case that you track paths of parameter homotopy you can also change the parameters using</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.start_parameters!-Tuple{PathTracker,Any}" href="#HomotopyContinuation.start_parameters!-Tuple{PathTracker,Any}"><code>HomotopyContinuation.start_parameters!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">start_parameters!(tracker::PathTracker, p)</code></pre><p>Set the start parameters of the homotopy in in <code>tracker</code> to <code>p</code>.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.target_parameters!-Tuple{PathTracker,Any}" href="#HomotopyContinuation.target_parameters!-Tuple{PathTracker,Any}"><code>HomotopyContinuation.target_parameters!</code></a> — <span class="docstring-category">Method</span>.</div><div><div><pre><code class="language-julia">target_parameters!(tracker::PathTracker, p)</code></pre><p>Set the target parameters of the homotopy in in <code>tracker</code> to <code>p</code>.</p></div></div></section><p>The return type of <a href="../core_tracker/#HomotopyContinuation.track!-Tuple{CoreTracker,AbstractArray{T,1} where T,Number,Number}"><code>track!</code></a> is a <a href="#HomotopyContinuation.PathTrackerStatus.states"><code>PathTrackerStatus.states</code></a>:</p><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.PathTrackerStatus.states" href="#HomotopyContinuation.PathTrackerStatus.states"><code>HomotopyContinuation.PathTrackerStatus.states</code></a> — <span class="docstring-category">Type</span>.</div><div><div><pre><code class="language-julia">enum PathTrackerStatus</code></pre><p>The possible states a <a href="@ref"><code>PathTracker</code></a> can be in:</p><ul><li><code>PathTrackerStatus.tracking</code></li><li><code>PathTrackerStatus.success</code></li><li><code>PathTrackerStatus.at_infinity</code></li><li><code>PathTrackerStatus.excess_solution</code></li><li><code>PathTrackerStatus.post_check_failed</code></li><li><code>PathTrackerStatus.terminated_accuracy_limit</code></li><li><code>PathTrackerStatus.terminated_ill_conditioned</code></li><li><code>PathTrackerStatus.terminated_invalid_startvalue</code></li><li><code>PathTrackerStatus.terminated_max_winding_number</code></li><li><code>PathTrackerStatus.terminated_max_iters</code></li><li><code>PathTrackerStatus.terminated_step_size_too_small</code></li></ul></div></div><a class="source-link" target="_blank" href="https://github.com/JuliaLang/julia/blob/b5ccd0f2ef29f86e1c95f09e148793e9d3bf15ea/base/#L0-L16">source</a></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.is_success" href="#HomotopyContinuation.is_success"><code>HomotopyContinuation.is_success</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">is_success(S::CoreTrackerStatus.states)</code></pre><p>Returns <code>true</code> if <code>S</code> indicates a success in the path tracking.</p></div></div><div><div><pre><code class="language-julia">is_success(result::CoreTrackerResult)</code></pre><p>Returns <code>true</code> if the path tracking was successfull.</p></div></div><div><div><pre><code class="language-none">is_success(status::PathTrackerStatus.states)</code></pre><p>Returns <code>true</code> if <code>status</code> indicates a success in tracking.</p></div></div><div><div><pre><code class="language-julia">is_success(r::PathResult)</code></pre><p>Checks whether the path is successfull.</p></div></div><div><div><pre><code class="language-none">is_success(result::MonodromyResult)</code></pre><p>Returns true if the monodromy computation achieved its target solution count.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.is_at_infinity" href="#HomotopyContinuation.is_at_infinity"><code>HomotopyContinuation.is_at_infinity</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">is_success(status::PathTrackerStatus.states)</code></pre><p>Returns <code>true</code> if <code>status</code> indicates that a path diverged towards infinity.</p></div></div><div><div><pre><code class="language-julia">is_at_infinity(r::PathResult)</code></pre><p>Checks whether the path goes to infinity.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.is_invalid_startvalue" href="#HomotopyContinuation.is_invalid_startvalue"><code>HomotopyContinuation.is_invalid_startvalue</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">is_invalid_startvalue(S::CoreTrackerStatus.states)</code></pre><p>Returns <code>true</code> if <code>S</code> indicates that the path tracking got terminated since the start value was not a zero.</p></div></div><div><div><pre><code class="language-none">is_invalid_startvalue(status::PathTrackerStatus.states)</code></pre><p>Returns <code>true</code> if the provided start value was not valid.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.is_failed" href="#HomotopyContinuation.is_failed"><code>HomotopyContinuation.is_failed</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">is_failed(r::PathResult)</code></pre><p>Checks whether the path failed.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.is_terminated_callback" href="#HomotopyContinuation.is_terminated_callback"><code>HomotopyContinuation.is_terminated_callback</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">is_terminated_callback(status::PathTrackerStatus.states)</code></pre><p>Returns <code>true</code> if the provided callback indicated a termination of the path.</p></div></div></section><section class="docstring"><div class="docstring-header"><a class="docstring-binding" id="HomotopyContinuation.is_tracking" href="#HomotopyContinuation.is_tracking"><code>HomotopyContinuation.is_tracking</code></a> — <span class="docstring-category">Function</span>.</div><div><div><pre><code class="language-julia">is_tracking(S::CoreTrackerStatus.states)</code></pre><p>Returns <code>true</code> if <code>S</code> indicates that the path tracking is not yet finished.</p></div></div><div><div><pre><code class="language-none">is_tracking(status::PathTrackerStatus.states)</code></pre><p>Returns <code>true</code> if <code>status</code> indicates the tracking is not going on.</p></div></div></section><footer><hr/><a class="previous" href="../monodromy/"><span class="direction">Previous</span><span class="title">Solving parametrized systems with monodromy</span></a><a class="next" href="../core_tracker/"><span class="direction">Next</span><span class="title">CoreTracker</span></a></footer></article></body></html>
