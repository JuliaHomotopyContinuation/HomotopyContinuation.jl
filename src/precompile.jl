# Use
#    @warnpcfail precompile(args...)
# if you want to be warned when a precompile directive fails
macro warnpcfail(ex::Expr)
    modl = __module__
    file = __source__.file === nothing ? "?" : String(__source__.file)
    line = __source__.line
    quote
        $(esc(ex)) || @warn """precompile directive
     $($(Expr(:quote, ex)))
 failed. Please report an issue in $($modl) (after checking for duplicates) or remove this directive.""" _file =
            $file _line = $line
    end
end


const __bodyfunction__ = Dict{Method,Any}()

# Find keyword "body functions" (the function that contains the body
# as written by the developer, called after all missing keyword-arguments
# have been assigned values), in a manner that doesn't depend on
# gensymmed names.
# `mnokw` is the method that gets called when you invoke it without
# supplying any keywords.
function __lookup_kwbody__(mnokw::Method)
    function getsym(arg)
        isa(arg, Symbol) && return arg
        @assert isa(arg, GlobalRef)
        return arg.name
    end

    f = get(__bodyfunction__, mnokw, nothing)
    if f === nothing
        fmod = mnokw.module
        # The lowered code for `mnokw` should look like
        #   %1 = mkw(kwvalues..., #self#, args...)
        #        return %1
        # where `mkw` is the name of the "active" keyword body-function.
        ast = Base.uncompressed_ast(mnokw)
        if isa(ast, Core.CodeInfo) && length(ast.code) >= 2
            callexpr = ast.code[end-1]
            if isa(callexpr, Expr) && callexpr.head == :call
                fsym = callexpr.args[1]
                if isa(fsym, Symbol)
                    f = getfield(fmod, fsym)
                elseif isa(fsym, GlobalRef)
                    if fsym.mod === Core && fsym.name === :_apply
                        f = getfield(mnokw.module, getsym(callexpr.args[2]))
                    elseif fsym.mod === Core && fsym.name === :_apply_iterate
                        f = getfield(mnokw.module, getsym(callexpr.args[3]))
                    else
                        f = getfield(fsym.mod, fsym.name)
                    end
                else
                    f = missing
                end
            else
                f = missing
            end
        else
            f = missing
        end
        __bodyfunction__[mnokw] = f
    end
    return f
end

function _precompile_()
    ccall(:jl_generating_output, Cint, ()) == 1 || return nothing
    Base.precompile(Tuple{AffineChartSystem{InterpretedSystem,1},Vector{Variable}})
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:options,),Tuple{EndgameOptions}},
            Type{EndgameTracker},
            Tracker{CoefficientHomotopy{InterpretedSystem},Matrix{ComplexF64}},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:options,),Tuple{EndgameOptions}},
            Type{EndgameTracker},
            Tracker{ParameterHomotopy{InterpretedSystem},Matrix{ComplexF64}},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:options,),Tuple{EndgameOptions}},
            Type{EndgameTracker},
            Tracker{
                StraightLineHomotopy{
                    FixedParameterSystem{InterpretedSystem,Float64},
                    InterpretedSystem,
                },
                Matrix{ComplexF64},
            },
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:options,),Tuple{TrackerOptions}},
            Type{Tracker},
            CoefficientHomotopy{InterpretedSystem},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:options,),Tuple{TrackerOptions}},
            Type{Tracker},
            ToricHomotopy{InterpretedSystem},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{
                (
                    :return_code,
                    :solution,
                    :t,
                    :singular,
                    :accuracy,
                    :residual,
                    :condition_jacobian,
                    :winding_number,
                    :last_path_point,
                    :valuation,
                    :start_solution,
                    :path_number,
                    :ω,
                    :μ,
                    :extended_precision,
                    :accepted_steps,
                    :rejected_steps,
                    :steps_eg,
                    :extended_precision_used,
                ),
                Tuple{
                    Symbol,
                    Vector{ComplexF64},
                    Float64,
                    Bool,
                    Float64,
                    Float64,
                    Float64,
                    Nothing,
                    Tuple{Vector{ComplexF64},Float64},
                    Vector{Float64},
                    Vector{ComplexF64},
                    Int64,
                    Float64,
                    Float64,
                    Bool,
                    Int64,
                    Int64,
                    Int64,
                    Bool,
                },
            },
            Type{PathResult},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{
                (
                    :return_code,
                    :solution,
                    :t,
                    :singular,
                    :accuracy,
                    :residual,
                    :condition_jacobian,
                    :winding_number,
                    :last_path_point,
                    :valuation,
                    :start_solution,
                    :path_number,
                    :ω,
                    :μ,
                    :extended_precision,
                    :accepted_steps,
                    :rejected_steps,
                    :steps_eg,
                    :extended_precision_used,
                ),
                Tuple{
                    Symbol,
                    Vector{ComplexF64},
                    Float64,
                    Bool,
                    Float64,
                    Float64,
                    Float64,
                    Nothing,
                    Tuple{Vector{ComplexF64},Float64},
                    Vector{Float64},
                    Vector{ComplexF64},
                    Nothing,
                    Float64,
                    Float64,
                    Bool,
                    Int64,
                    Int64,
                    Int64,
                    Bool,
                },
            },
            Type{PathResult},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:seed, :start_system),Tuple{UInt32,Nothing}},
            Type{Result},
            Vector{PathResult},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:seed, :start_system),Tuple{UInt32,Nothing}},
            Type{Solver},
            EndgameTracker{ParameterHomotopy{InterpretedSystem},Matrix{ComplexF64}},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:seed, :start_system),Tuple{UInt32,Symbol}},
            Type{Result},
            Vector{PathResult},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:seed, :start_system),Tuple{UInt32,Symbol}},
            Type{Solver},
            EndgameTracker{
                StraightLineHomotopy{
                    FixedParameterSystem{InterpretedSystem,Float64},
                    InterpretedSystem,
                },
                Matrix{ComplexF64},
            },
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:seed, :start_system),Tuple{UInt32,Symbol}},
            Type{Solver},
            OverdeterminedTracker{
                PolyhedralTracker{
                    ToricHomotopy{InterpretedSystem},
                    CoefficientHomotopy{InterpretedSystem},
                    Matrix{ComplexF64},
                },
                ExcessSolutionCheck{
                    RandomizedSystem{InterpretedSystem},
                    MatrixWorkspace{Matrix{ComplexF64}},
                },
            },
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:seed, :start_system),Tuple{UInt32,Symbol}},
            Type{Solver},
            PolyhedralTracker{
                ToricHomotopy{InterpretedSystem},
                CoefficientHomotopy{InterpretedSystem},
                Matrix{ComplexF64},
            },
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:tracker_options, :options),Tuple{TrackerOptions,EndgameOptions}},
            Type{EndgameTracker},
            ParameterHomotopy{InterpretedSystem},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:tracker_options, :options),Tuple{TrackerOptions,EndgameOptions}},
            Type{EndgameTracker},
            StraightLineHomotopy{
                FixedParameterSystem{InterpretedSystem,Float64},
                InterpretedSystem,
            },
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:variables, :parameters),Tuple{Vector{Variable},Vector{Variable}}},
            Type{System},
            Vector{Matrix{Int32}},
            Vector{Vector{Variable}},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(Type)),
            NamedTuple{(:γ,),Tuple{ComplexF64}},
            Type{StraightLineHomotopy},
            FixedParameterSystem{InterpretedSystem,Float64},
            InterpretedSystem,
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(monodromy_solve)),
            NamedTuple{
                (:show_progress, :threading, :catch_interrupt),
                Tuple{Bool,Bool,Bool},
            },
            typeof(monodromy_solve),
            MonodromySolver{
                EndgameTracker{ParameterHomotopy{InterpretedSystem},Matrix{ComplexF64}},
                Vector{ComplexF64},
                UniquePoints{ComplexF64,Int64,EuclideanNorm,Nothing},
                MonodromyOptions{EuclideanNorm,Nothing},
            },
            Vector{Vector{ComplexF64}},
            Vector{ComplexF64},
            UInt32,
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(monodromy_solve)),
            NamedTuple{
                (:target_solutions_count, :max_loops_no_progress, :compile),
                Tuple{Int64,Int64,Bool},
            },
            typeof(monodromy_solve),
            System,
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(newton)),
            NamedTuple{(:atol, :rtol),Tuple{Float64,Float64}},
            typeof(newton),
            StartPairSystem{
                InterpretedSystem,
                FiniteDiff.JacobianCache{
                    Vector{ComplexF64},
                    Vector{ComplexF64},
                    Vector{ComplexF64},
                    UnitRange{Int64},
                    Nothing,
                    Val{:forward}(),
                    ComplexF64,
                },
            },
            Vector{ComplexF64},
            Nothing,
            InfNorm,
            NewtonCache{Matrix{ComplexF64}},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(polyhedral)),
            NamedTuple{(:compile,),Tuple{Bool}},
            typeof(polyhedral),
            Vector{Matrix{Int32}},
            Vector{Vector{ComplexF64}},
            Vector{Vector{Float64}},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(polyhedral)),
            NamedTuple{(:compile,),Tuple{Bool}},
            typeof(polyhedral),
            Vector{Matrix{Int32}},
            Vector{Vector{ComplexF64}},
            Vector{Vector},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(polyhedral)),
            NamedTuple{(:compile,),Tuple{Bool}},
            typeof(polyhedral),
            Vector{Matrix{Int32}},
            Vector{Vector{ComplexF64}},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(polyhedral)),
            NamedTuple{(:compile,),Tuple{Bool}},
            typeof(polyhedral),
            Vector{Matrix{Int32}},
            Vector{Vector{Float64}},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(polyhedral)),
            NamedTuple{(:compile,),Tuple{Bool}},
            typeof(polyhedral),
            Vector{Matrix{Int32}},
            Vector{Vector},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(solve)),
            NamedTuple{(:compile, :start_system),Tuple{Bool,Symbol}},
            typeof(solve),
            System,
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(solve)),
            NamedTuple{(:compile,),Tuple{Bool}},
            typeof(solve),
            System,
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(solve)),
            NamedTuple{
                (:start_parameters, :target_parameters, :compile),
                Tuple{Vector{ComplexF64},Vector{Float64},Bool},
            },
            typeof(solve),
            System,
            Vector{Vector{ComplexF64}},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(solve)),
            NamedTuple{
                (:stop_early_cb, :show_progress, :threading, :catch_interrupt),
                Tuple{typeof(always_false),Bool,Bool,Bool},
            },
            typeof(solve),
            Solver{EndgameTracker{ParameterHomotopy{InterpretedSystem},Matrix{ComplexF64}}},
            Vector{Vector{ComplexF64}},
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(solve)),
            NamedTuple{
                (:stop_early_cb, :show_progress, :threading, :catch_interrupt),
                Tuple{typeof(always_false),Bool,Bool,Bool},
            },
            typeof(solve),
            Solver{
                EndgameTracker{
                    StraightLineHomotopy{
                        FixedParameterSystem{InterpretedSystem,Float64},
                        InterpretedSystem,
                    },
                    Matrix{ComplexF64},
                },
            },
            TotalDegreeStartSolutionsIterator{
                Base.Iterators.ProductIterator{Tuple{UnitRange{Int64},UnitRange{Int64}}},
            },
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(solve)),
            NamedTuple{
                (:stop_early_cb, :show_progress, :threading, :catch_interrupt),
                Tuple{typeof(always_false),Bool,Bool,Bool},
            },
            typeof(solve),
            Solver{
                OverdeterminedTracker{
                    PolyhedralTracker{
                        ToricHomotopy{InterpretedSystem},
                        CoefficientHomotopy{InterpretedSystem},
                        Matrix{ComplexF64},
                    },
                    ExcessSolutionCheck{
                        RandomizedSystem{InterpretedSystem},
                        MatrixWorkspace{Matrix{ComplexF64}},
                    },
                },
            },
            PolyhedralStartSolutionsIterator,
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(solve)),
            NamedTuple{
                (:stop_early_cb, :show_progress, :threading, :catch_interrupt),
                Tuple{typeof(always_false),Bool,Bool,Bool},
            },
            typeof(solve),
            Solver{
                PolyhedralTracker{
                    ToricHomotopy{InterpretedSystem},
                    CoefficientHomotopy{InterpretedSystem},
                    Matrix{ComplexF64},
                },
            },
            PolyhedralStartSolutionsIterator,
        },
    )
    Base.precompile(
        Tuple{
            Core.kwftype(typeof(total_degree_start_solutions)),
            NamedTuple{(:homogeneous,),Tuple{Bool}},
            typeof(total_degree_start_solutions),
            Vector{Int64},
        },
    )
    Base.precompile(
        Tuple{
            HomotopyContinuation.ModelKit.var"##buildvar#28",
            Bool,
            typeof(HomotopyContinuation.ModelKit.buildvar),
            Expr,
        },
    )
    Base.precompile(
        Tuple{
            HomotopyContinuation.ModelKit.var"##buildvar#28",
            Bool,
            typeof(HomotopyContinuation.ModelKit.buildvar),
            Symbol,
        },
    )
    Base.precompile(Tuple{HomotopyContinuation.ModelKit.var"##s51#137",Any,Any,Any,Any})
    Base.precompile(
        Tuple{HomotopyContinuation.ModelKit.var"##s51#140",Any,Any,Any,Any,Any,Any},
    )
    Base.precompile(
        Tuple{
            HomotopyContinuation.ModelKit.var"##s95#295",
            Any,
            Any,
            Any,
            Any,
            Any,
            Any,
            Any,
            Any,
            Any,
        },
    )
    Base.precompile(Tuple{RandomizedSystem{InterpretedSystem},Vector{Variable}})
    Base.precompile(
        Tuple{
            Type{ExcessSolutionCheck},
            RandomizedSystem{InterpretedSystem},
            NewtonCache{MatrixWorkspace{Matrix{ComplexF64}}},
        },
    )
    Base.precompile(
        Tuple{
            Type{HomotopyContinuation.ModelKit.IRStatement},
            HomotopyContinuation.ModelKit.OpType,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
        },
    )
    Base.precompile(
        Tuple{
            Type{HomotopyContinuation.ModelKit.IRStatement},
            HomotopyContinuation.ModelKit.OpType,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Symbol,
        },
    )
    Base.precompile(
        Tuple{
            Type{HomotopyContinuation.ModelKit.IRStatement},
            HomotopyContinuation.ModelKit.OpType,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Int32,
        },
    )
    Base.precompile(
        Tuple{
            Type{HomotopyContinuation.ModelKit.IRStatement},
            HomotopyContinuation.ModelKit.OpType,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Symbol,
            HomotopyContinuation.ModelKit.IRStatementRef,
        },
    )
    Base.precompile(
        Tuple{
            Type{HomotopyContinuation.ModelKit.IRStatement},
            HomotopyContinuation.ModelKit.OpType,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Symbol,
        },
    )
    Base.precompile(
        Tuple{
            Type{HomotopyContinuation.ModelKit.IRStatement},
            HomotopyContinuation.ModelKit.OpType,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Symbol,
            Symbol,
        },
    )
    Base.precompile(
        Tuple{
            Type{HomotopyContinuation.ModelKit.IRStatement},
            HomotopyContinuation.ModelKit.OpType,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Int32,
            Symbol,
            HomotopyContinuation.ModelKit.IRStatementRef,
        },
    )
    Base.precompile(
        Tuple{
            Type{HomotopyContinuation.ModelKit.IRStatement},
            HomotopyContinuation.ModelKit.OpType,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Int32,
            Symbol,
            Symbol,
        },
    )
    Base.precompile(
        Tuple{
            Type{HomotopyContinuation.ModelKit.IRStatement},
            HomotopyContinuation.ModelKit.OpType,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Int32,
            Symbol,
        },
    )
    Base.precompile(
        Tuple{
            Type{HomotopyContinuation.ModelKit.IRStatement},
            HomotopyContinuation.ModelKit.OpType,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Int64,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
        },
    )
    Base.precompile(
        Tuple{
            Type{HomotopyContinuation.ModelKit.IRStatement},
            HomotopyContinuation.ModelKit.OpType,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Symbol,
            Float64,
        },
    )
    Base.precompile(
        Tuple{
            Type{HomotopyContinuation.ModelKit.IRStatement},
            HomotopyContinuation.ModelKit.OpType,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Symbol,
            Symbol,
            HomotopyContinuation.ModelKit.IRStatementRef,
        },
    )
    Base.precompile(
        Tuple{
            Type{HomotopyContinuation.ModelKit.Instruction},
            NTuple{4,Int32},
            HomotopyContinuation.ModelKit.OpType,
            Int64,
        },
    )
    Base.precompile(
        Tuple{
            Type{Jacobian},
            MatrixWorkspace{Matrix{ComplexF64}},
            Base.RefValue{Int64},
            Base.RefValue{Int64},
        },
    )
    Base.precompile(
        Tuple{
            Type{MatrixWorkspace},
            Matrix{ComplexF64},
            Vector{Float64},
            Base.RefValue{Bool},
            LinearAlgebra.LU{ComplexF64,Matrix{ComplexF64}},
            LinearAlgebra.QR{ComplexF64,Matrix{ComplexF64}},
            Vector{Float64},
            Base.RefValue{Bool},
            Vector{Complex{DoubleF64}},
            Vector{ComplexF64},
            Vector{Complex{DoubleF64}},
            Vector{ComplexF64},
            Vector{ComplexF64},
            Vector{Float64},
        },
    )
    Base.precompile(
        Tuple{
            Type{MonodromySolver},
            Vector{EndgameTracker{ParameterHomotopy{InterpretedSystem},Matrix{ComplexF64}}},
            Vector{MonodromyLoop{Vector{ComplexF64}}},
            UniquePoints{ComplexF64,Int64,EuclideanNorm,Nothing},
            ReentrantLock,
            MonodromyOptions{EuclideanNorm,Nothing},
            MonodromyStatistics,
            Matrix{ComplexF64},
            ReentrantLock,
        },
    )
    Base.precompile(
        Tuple{
            Type{NewtonCache},
            Vector{ComplexF64},
            Vector{ComplexF64},
            Vector{Complex{DoubleF64}},
            MatrixWorkspace{Matrix{ComplexF64}},
            Vector{ComplexF64},
        },
    )
    Base.precompile(
        Tuple{
            Type{OverdeterminedTracker},
            PolyhedralTracker{
                ToricHomotopy{InterpretedSystem},
                CoefficientHomotopy{InterpretedSystem},
                Matrix{ComplexF64},
            },
            ExcessSolutionCheck{
                RandomizedSystem{InterpretedSystem},
                MatrixWorkspace{Matrix{ComplexF64}},
            },
        },
    )
    Base.precompile(
        Tuple{
            Type{OverdeterminedTracker},
            PolyhedralTracker{
                ToricHomotopy{InterpretedSystem},
                CoefficientHomotopy{InterpretedSystem},
                Matrix{ComplexF64},
            },
            RandomizedSystem{InterpretedSystem},
        },
    )
    Base.precompile(
        Tuple{
            Type{PolyhedralStartSolutionsIterator},
            Vector{Matrix{Int32}},
            Vector{Vector{ComplexF64}},
        },
    )
    Base.precompile(
        Tuple{
            Type{PolyhedralTracker},
            Tracker{ToricHomotopy{InterpretedSystem},Matrix{ComplexF64}},
            EndgameTracker{CoefficientHomotopy{InterpretedSystem},Matrix{ComplexF64}},
            Vector{Matrix{Int32}},
            Vector{Vector{Int32}},
        },
    )
    Base.precompile(Tuple{Type{System},Vector{Expression},Vector{Variable}})
    Base.precompile(Tuple{Type{System},Vector{Expression}})
    Base.precompile(
        Tuple{
            Type{TotalDegreeStartSolutionsIterator},
            Vector{Int64},
            Bool,
            Base.Iterators.ProductIterator{Tuple{UnitRange{Int64},UnitRange{Int64}}},
        },
    )
    Base.precompile(
        Tuple{
            Type{TrackerState},
            Vector{ComplexF64},
            Vector{ComplexF64},
            Vector{ComplexF64},
            SegmentStepper,
            Float64,
            Float64,
            Float64,
            Float64,
            Float64,
            Float64,
            Float64,
            Bool,
            Bool,
            Bool,
            Bool,
            WeightedNorm{InfNorm},
            Bool,
            Jacobian{Matrix{ComplexF64}},
            Float64,
            HomotopyContinuation.TrackerCode.codes,
            Int64,
            Int64,
            Int64,
            Int64,
            Int64,
        },
    )
    Base.precompile(
        Tuple{
            Type{Tracker},
            CoefficientHomotopy{InterpretedSystem},
            Predictor,
            NewtonCorrector,
            TrackerState{Matrix{ComplexF64}},
            TrackerOptions,
        },
    )
    Base.precompile(
        Tuple{
            Type{Tracker},
            ParameterHomotopy{InterpretedSystem},
            Predictor,
            NewtonCorrector,
            TrackerState{Matrix{ComplexF64}},
            TrackerOptions,
        },
    )
    Base.precompile(
        Tuple{
            Type{Tracker},
            StraightLineHomotopy{
                FixedParameterSystem{InterpretedSystem,Float64},
                InterpretedSystem,
            },
            Predictor,
            NewtonCorrector,
            TrackerState{Matrix{ComplexF64}},
            TrackerOptions,
        },
    )
    Base.precompile(
        Tuple{
            Type{Tracker},
            ToricHomotopy{InterpretedSystem},
            Predictor,
            NewtonCorrector,
            TrackerState{Matrix{ComplexF64}},
            TrackerOptions,
        },
    )
    Base.precompile(Tuple{typeof(*),Expression,Variable})
    Base.precompile(Tuple{typeof(*),Variable,Variable})
    Base.precompile(Tuple{typeof(-),Expression,Expression})
    Base.precompile(Tuple{typeof(-),Variable,Variable})
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.add_op!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            HomotopyContinuation.ModelKit.OpType,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Vararg{
                Union{Nothing,HomotopyContinuation.ModelKit.IRStatementRef,Number,Symbol},
            },
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.add_op!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            HomotopyContinuation.ModelKit.OpType,
            Int32,
            Vararg{
                Union{Nothing,HomotopyContinuation.ModelKit.IRStatementRef,Number,Symbol},
            },
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.add_op!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            HomotopyContinuation.ModelKit.OpType,
            Int64,
            Vararg{
                Union{Nothing,HomotopyContinuation.ModelKit.IRStatementRef,Number,Symbol},
            },
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.add_op!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            HomotopyContinuation.ModelKit.OpType,
            Symbol,
            Vararg{
                Union{Nothing,HomotopyContinuation.ModelKit.IRStatementRef,Number,Symbol},
            },
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.execute_taylor_instructions!_impl),
            Int64,
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.expr_to_ir_statements!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Expression,
            Dict{Symbol,Expression},
            Dict{Symbol,HomotopyContinuation.ModelKit.IRStatementRef},
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.free!),
            HomotopyContinuation.ModelKit.ExprVec,
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.free!),
            HomotopyContinuation.ModelKit.ExpressionMap,
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.free!),
            HomotopyContinuation.ModelKit.ExpressionSet,
        },
    )
    Base.precompile(Tuple{typeof(HomotopyContinuation.ModelKit.is_minus_one),Int32})
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.mulmuladd!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Symbol,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Symbol,
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.mulmuladd!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Symbol,
            Symbol,
            HomotopyContinuation.ModelKit.IRStatementRef,
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.mulmuladd!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Symbol,
            Symbol,
            Symbol,
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.mulmuladd!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Int32,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Int32,
            HomotopyContinuation.ModelKit.IRStatementRef,
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.mulmuladd!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Int32,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Symbol,
            HomotopyContinuation.ModelKit.IRStatementRef,
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.mulmuladd!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Int32,
            Symbol,
            Int32,
            Symbol,
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.mulmuladd!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Symbol,
            HomotopyContinuation.ModelKit.IRStatementRef,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Symbol,
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.mulmuladd!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Symbol,
            Symbol,
            HomotopyContinuation.ModelKit.IRStatementRef,
            Symbol,
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.mulmuladd!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Symbol,
            Symbol,
            Symbol,
            HomotopyContinuation.ModelKit.IRStatementRef,
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.mulmuladd!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Symbol,
            Symbol,
            Symbol,
            Symbol,
        },
    )
    Base.precompile(Tuple{typeof(HomotopyContinuation.ModelKit.number_or_nothing),Float64})
    Base.precompile(Tuple{typeof(HomotopyContinuation.ModelKit.number_or_nothing),Int32})
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.submul!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Any,
            Any,
            Any,
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.sum_products!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Vector{Tuple{Any,Any}},
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.sum_products!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Vector{Tuple{Any,Nothing}},
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.sum_products!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Vector{Tuple{Any,Symbol}},
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.sum_products!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Vector{Tuple{Float64,HomotopyContinuation.ModelKit.IRStatementRef}},
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.sum_products!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Vector{Tuple{HomotopyContinuation.ModelKit.IRStatementRef,Any}},
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.sum_products!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Vector{Tuple{HomotopyContinuation.ModelKit.IRStatementRef,Nothing}},
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.sum_products!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Vector{Tuple{HomotopyContinuation.ModelKit.IRStatementRef,Symbol}},
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.sum_products!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Vector{Tuple{Int32,Any}},
        },
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.sum_products!),
            HomotopyContinuation.ModelKit.IntermediateRepresentation,
            Vector{Tuple{Symbol,Any}},
        },
    )
    Base.precompile(
        Tuple{typeof(HomotopyContinuation.ModelKit.taylor_cos_impl),Int64,Int64},
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.taylor_op_call),
            HomotopyContinuation.ModelKit.OpType,
        },
    )
    Base.precompile(
        Tuple{typeof(HomotopyContinuation.ModelKit.taylor_op_pow_int_impl),Int64,Int64},
    )
    Base.precompile(
        Tuple{typeof(HomotopyContinuation.ModelKit.taylor_op_sqr_impl),Int64,Int64},
    )
    Base.precompile(
        Tuple{typeof(HomotopyContinuation.ModelKit.taylor_sin_impl),Int64,Int64},
    )
    Base.precompile(
        Tuple{
            typeof(HomotopyContinuation.ModelKit.taylor_tuple),
            Vector{HomotopyContinuation.ModelKit.IRStatementRef},
        },
    )
    Base.precompile(
        Tuple{typeof(HomotopyContinuation.ModelKit.to_smallest_eltype),Vector{ComplexF64}},
    )
    Base.precompile(
        Tuple{typeof(HomotopyContinuation.ModelKit.to_smallest_eltype),Vector{Number}},
    )
    Base.precompile(
        Tuple{typeof(HomotopyContinuation.ModelKit.to_smallest_eltype),Vector{Real}},
    )
    Base.precompile(Tuple{typeof(always_false),Vector{PathResult}})
    Base.precompile(Tuple{typeof(fix_parameters),InterpretedSystem,Vector{Float64}})
    Base.precompile(Tuple{typeof(independent_normal),Vector{ComplexF64}})
    Base.precompile(
        Tuple{
            typeof(newton),
            InterpretedSystem,
            Vector{ComplexF64},
            Vector{ComplexF64},
            InfNorm,
            NewtonCache{MatrixWorkspace{Matrix{ComplexF64}}},
        },
    )
    Base.precompile(
        Tuple{typeof(parameters),MonodromyResult{Vector{ComplexF64},Vector{ComplexF64}}},
    )
    Base.precompile(Tuple{typeof(polyhedral_system),Vector{Matrix{Int32}}})
    Base.precompile(Tuple{typeof(size),AffineChartSystem{InterpretedSystem,1}})
    Base.precompile(
        Tuple{typeof(solutions),MonodromyResult{Vector{ComplexF64},Vector{ComplexF64}}},
    )
    Base.precompile(
        Tuple{typeof(variables),String,UnitRange{Int64},Vararg{UnitRange{Int64}}},
    )
    isdefined(HomotopyContinuation, Symbol("#227#228")) && Base.precompile(
        Tuple{getfield(HomotopyContinuation, Symbol("#227#228")),Vector{ComplexF64}},
    )
    isdefined(HomotopyContinuation.ModelKit, Symbol("#145#146")) && Base.precompile(
        Tuple{getfield(HomotopyContinuation.ModelKit, Symbol("#145#146")),Symbol},
    )
    let fbody = try
            __lookup_kwbody__(
                which(
                    solve,
                    (
                        Solver{
                            EndgameTracker{
                                ParameterHomotopy{InterpretedSystem},
                                Matrix{ComplexF64},
                            },
                        },
                        Vector{Vector{ComplexF64}},
                    ),
                ),
            )
        catch missing
        end
        if !ismissing(fbody)
            precompile(
                fbody,
                (
                    Function,
                    Bool,
                    Bool,
                    Bool,
                    typeof(solve),
                    Solver{
                        EndgameTracker{
                            ParameterHomotopy{InterpretedSystem},
                            Matrix{ComplexF64},
                        },
                    },
                    Vector{Vector{ComplexF64}},
                ),
            )
        end
    end
    let fbody = try
            __lookup_kwbody__(
                which(
                    solve,
                    (
                        Solver{
                            EndgameTracker{
                                StraightLineHomotopy{
                                    FixedParameterSystem{InterpretedSystem,Float64},
                                    InterpretedSystem,
                                },
                                Matrix{ComplexF64},
                            },
                        },
                        Vector{Vector{ComplexF64}},
                    ),
                ),
            )
        catch missing
        end
        if !ismissing(fbody)
            precompile(
                fbody,
                (
                    Function,
                    Bool,
                    Bool,
                    Bool,
                    typeof(solve),
                    Solver{
                        EndgameTracker{
                            StraightLineHomotopy{
                                FixedParameterSystem{InterpretedSystem,Float64},
                                InterpretedSystem,
                            },
                            Matrix{ComplexF64},
                        },
                    },
                    Vector{Vector{ComplexF64}},
                ),
            )
        end
    end
    let fbody = try
            __lookup_kwbody__(
                which(
                    solve,
                    (
                        Solver{
                            OverdeterminedTracker{
                                PolyhedralTracker{
                                    ToricHomotopy{InterpretedSystem},
                                    CoefficientHomotopy{InterpretedSystem},
                                    Matrix{ComplexF64},
                                },
                                ExcessSolutionCheck{
                                    RandomizedSystem{InterpretedSystem},
                                    MatrixWorkspace{Matrix{ComplexF64}},
                                },
                            },
                        },
                        Vector{Tuple{MixedCell,Vector{ComplexF64}}},
                    ),
                ),
            )
        catch missing
        end
        if !ismissing(fbody)
            precompile(
                fbody,
                (
                    Function,
                    Bool,
                    Bool,
                    Bool,
                    typeof(solve),
                    Solver{
                        OverdeterminedTracker{
                            PolyhedralTracker{
                                ToricHomotopy{InterpretedSystem},
                                CoefficientHomotopy{InterpretedSystem},
                                Matrix{ComplexF64},
                            },
                            ExcessSolutionCheck{
                                RandomizedSystem{InterpretedSystem},
                                MatrixWorkspace{Matrix{ComplexF64}},
                            },
                        },
                    },
                    Vector{Tuple{MixedCell,Vector{ComplexF64}}},
                ),
            )
        end
    end
    let fbody = try
            __lookup_kwbody__(
                which(
                    solve,
                    (
                        Solver{
                            PolyhedralTracker{
                                ToricHomotopy{InterpretedSystem},
                                CoefficientHomotopy{InterpretedSystem},
                                Matrix{ComplexF64},
                            },
                        },
                        Vector{Tuple{MixedCell,Vector{ComplexF64}}},
                    ),
                ),
            )
        catch missing
        end
        if !ismissing(fbody)
            precompile(
                fbody,
                (
                    Function,
                    Bool,
                    Bool,
                    Bool,
                    typeof(solve),
                    Solver{
                        PolyhedralTracker{
                            ToricHomotopy{InterpretedSystem},
                            CoefficientHomotopy{InterpretedSystem},
                            Matrix{ComplexF64},
                        },
                    },
                    Vector{Tuple{MixedCell,Vector{ComplexF64}}},
                ),
            )
        end
    end
    let fbody = try
            __lookup_kwbody__(which(solve, (System,)))
        catch missing
        end
        if !ismissing(fbody)
            precompile(
                fbody,
                (
                    Bool,
                    Bool,
                    Bool,
                    Nothing,
                    Function,
                    Nothing,
                    typeof(identity),
                    Nothing,
                    Nothing,
                    Base.Pairs{
                        Symbol,
                        Any,
                        Tuple{Symbol,Symbol},
                        NamedTuple{(:compile, :start_system),Tuple{Bool,Symbol}},
                    },
                    typeof(solve),
                    System,
                ),
            )
        end
    end
    let fbody = try
            __lookup_kwbody__(which(solve, (System,)))
        catch missing
        end
        if !ismissing(fbody)
            precompile(
                fbody,
                (
                    Bool,
                    Bool,
                    Bool,
                    Nothing,
                    Function,
                    Nothing,
                    typeof(identity),
                    Nothing,
                    Nothing,
                    Base.Pairs{
                        Symbol,
                        Bool,
                        Tuple{Symbol},
                        NamedTuple{(:compile,),Tuple{Bool}},
                    },
                    typeof(solve),
                    System,
                ),
            )
        end
    end
    let fbody = try
            __lookup_kwbody__(which(solve, (System, Vararg{Any})))
        catch missing
        end
        if !ismissing(fbody)
            precompile(
                fbody,
                (
                    Bool,
                    Bool,
                    Bool,
                    Vector{Float64},
                    Function,
                    Nothing,
                    typeof(identity),
                    Nothing,
                    Nothing,
                    Base.Pairs{
                        Symbol,
                        Any,
                        Tuple{Symbol,Symbol},
                        NamedTuple{
                            (:start_parameters, :compile),
                            Tuple{Vector{ComplexF64},Bool},
                        },
                    },
                    typeof(solve),
                    System,
                    Vararg{Any},
                ),
            )
        end
    end
end
