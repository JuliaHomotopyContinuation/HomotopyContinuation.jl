var documenterSearchIndex = {"docs":
[{"location":"systems/#Systems","page":"Systems","title":"Systems","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"Systems (AbstractSystem) are the basic building blocks of homotopies.","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"AbstractSystem","category":"page"},{"location":"systems/#HomotopyContinuation.ModelKit.AbstractSystem","page":"Systems","title":"HomotopyContinuation.ModelKit.AbstractSystem","text":"AbstractSystem\n\nAn abstract type representing a polynomial system F(x p) where x are variables and p are possible parameters.\n\n\n\n\n\n","category":"type"},{"location":"systems/","page":"Systems","title":"Systems","text":"Although they sound similar, AbstractSystems and System share different purposes. AbstractSystems are intented for the fast numerical evaluation of a fixed system. Whereas a System is intended for formulating your problem symbolically. A System can be converted to two different basic AbstractSystems, a CompiledSystem (fast, but introduce compilation overhead) and an InterpretedSystem (slower, but not compilation overhead).","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"CompiledSystem\nInterpretedSystem\nMixedSystem\nfixed(::System)","category":"page"},{"location":"systems/#HomotopyContinuation.ModelKit.CompiledSystem","page":"Systems","title":"HomotopyContinuation.ModelKit.CompiledSystem","text":"CompiledSystem <: AbstractSystem\n\nAn AbstractSystem which automatically compiles a straight line program for the fast evaluation of a system F and its Jacobian. For large systems the compilation can take some time and require a large amount of memory. If this is a problem consider InterpretedSystem.\n\nCompiledSystem(F::System; optimizations = true)\n\nConstruct a CompiledSystem from the given System F. If optimizations = true then optimize is called on F before compiling.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.ModelKit.InterpretedSystem","page":"Systems","title":"HomotopyContinuation.ModelKit.InterpretedSystem","text":"InterpretedSystem <: AbstractSystem\n\nAn AbstractSystem which automatically generates a program for the fast evaluation of F and its Jacobian. The program is however, not compiled but rather interpreted. See also CompiledSystem.\n\nInterpretedSystem(F::System; optimizations = true)\n\nConstruct an InterpretedSystem from the given System F. If optimizations = true then optimize is called on F before compiling.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.MixedSystem","page":"Systems","title":"HomotopyContinuation.MixedSystem","text":"MixedSystem\n\nA data structure which uses for evaluate! and evaluate_and_jacobian! a CompiledSystem and for taylor! an InterpretedSystem.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.fixed-Tuple{System}","page":"Systems","title":"HomotopyContinuation.fixed","text":"fixed(F::System; compile::Union{Bool,Symbol} = mixed)\n\nConstructs either a CompiledSystem (if compile = :all), an InterpretedSystem (if compile = :none) or a MixedSystem (compile = :mixed).\n\n\n\n\n\n","category":"method"},{"location":"systems/","page":"Systems","title":"Systems","text":"It is also possible to set the default compile flag.","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"set_default_compile","category":"page"},{"location":"systems/#HomotopyContinuation.set_default_compile","page":"Systems","title":"HomotopyContinuation.set_default_compile","text":"set_default_compile(mode::Symbol)\n\nSet the default value for the compile flag in solve and other functions. Possible values are :mixed (default), :all and :none.\n\n\n\n\n\n","category":"function"},{"location":"systems/#Interface","page":"Systems","title":"Interface","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"An AbstractSystem needs to implement the following methods:","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"Base.size(F::AbstractSystem)\nModelKit.variables(F::AbstractSystem)::Vector{Variable}\nModelKit.parameters(F::AbstractSystem) = Variable[]\nModelKit.variable_groups(::AbstractSystem)::Union{Nothing,Vector{Vector{Variable}}} = nothing\n # this has to work with x::Vector{Variable}\n(F::AbstractSystem)(x, p = nothing)\n # this has to work with x::Vector{ComplexF64} and x::Vector{ComplexDF64}\nevaluate!(u, F::AbstractSystem, x, p = nothing)\n# this has only to work with x::Vector{ComplexF64}\nevaluate_and_jacobian!(u, U, F::AbstractSystem, x, p = nothing)","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"If the system should be used in context of a parameter homotopy it is also necessary to implement","category":"page"},{"location":"systems/","page":"Systems","title":"Systems","text":"taylor!(u, ::Val{1}, F::AbstractSystem, x, p::TaylorVector{2})","category":"page"},{"location":"systems/#AffineChartSystem","page":"Systems","title":"AffineChartSystem","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"AffineChartSystem\non_affine_chart(F::System, dims)","category":"page"},{"location":"systems/#HomotopyContinuation.AffineChartSystem","page":"Systems","title":"HomotopyContinuation.AffineChartSystem","text":"AffineChartSystem(F::AbstractSystem, v::PVector{T,N})\n\nGiven a system F(x) (ℙ^m_1    ℙ^m_N)  ℂⁿ this creates a new affine system F which operates on the affine chart defined by the vector v  ℙ^m_1    ℙ^m_N and the augmented conditions vᵀx = 1.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.on_affine_chart-Tuple{System,Any}","page":"Systems","title":"HomotopyContinuation.on_affine_chart","text":"on_affine_chart(F::Union{System,AbstractSystem}, dimensions)\n\nConstruct an AffineChartSystem on a randomly generated chart v. Each entry is drawn idepdently from a univariate normal distribution.\n\n\n\n\n\n","category":"method"},{"location":"systems/#CompositionSystem","page":"Systems","title":"CompositionSystem","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"CompositionSystem\ncompose","category":"page"},{"location":"systems/#HomotopyContinuation.CompositionSystem","page":"Systems","title":"HomotopyContinuation.CompositionSystem","text":"CompositionSystem(G::AbstractSystem, F::AbstractSystem)\n\nConstruct the system G(F(xp)p). Note that the parameters are passed to G and F are identical.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.compose","page":"Systems","title":"HomotopyContinuation.compose","text":"compose(G::Union{AbstractSystem,System}, F::Union{AbstractSystem,System})\n\nConstruct the composition G(F(x)). You can also use the infix operator ∘ (written by \\circ).\n\nExample\n\njulia> @var a b c x y z\n\njulia> g = System([a * b * c]);\n\njulia> f = System([x+y, y + z, x + z]);\n\njulia> compose(g, f)\nComposition G ∘ F:\nF:\nModelKitSystem{(0xbb16b481c0808501, 1)}:\nCompiled: System of length 3\n 3 variables: x, y, z\n\n x + y\n y + z\n x + z\n\nG:\nModelKitSystem{(0xf0a2384a42428501, 1)}:\nCompiled: System of length 1\n 3 variables: a, b, c\n\n a*b*c\n\n\njulia> (g ∘ f)([x,y,z])\n1-element Array{Expression,1}:\n (x + z)*(y + z)*(x + y)\n\n\n\n\n\n","category":"function"},{"location":"systems/#FixedParameterSystem","page":"Systems","title":"FixedParameterSystem","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"FixedParameterSystem\nfix_parameters(F::AbstractSystem, p)","category":"page"},{"location":"systems/#HomotopyContinuation.FixedParameterSystem","page":"Systems","title":"HomotopyContinuation.FixedParameterSystem","text":"FixedParameterSystem(F:AbstractSystem, parameters)\n\nConstruct a system from the given AbstractSystem F with the given parameters fixed.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.fix_parameters-Tuple{AbstractSystem,Any}","page":"Systems","title":"HomotopyContinuation.fix_parameters","text":"fix_parameters(F::Union{System,AbstractSystem}, p; compile::Union{Bool,Symbol} = mixed)\n\nFix the parameters of the given system F. Returns a FixedParameterSystem.\n\n\n\n\n\n","category":"method"},{"location":"systems/#RandomizedSystem","page":"Systems","title":"RandomizedSystem","text":"","category":"section"},{"location":"systems/","page":"Systems","title":"Systems","text":"RandomizedSystem","category":"page"},{"location":"systems/#HomotopyContinuation.RandomizedSystem","page":"Systems","title":"HomotopyContinuation.RandomizedSystem","text":"RandomizedSystem(F::Union{System,AbstractSystem}, k::Integer) <: AbstractSystem\n\nGiven a n  N system F with n  N this constructs the system mathfrakR(F k)(x) = I AF(x) where I is a k  k identity matrix and A is random complex k  n matrix. See Chapter 13.5 in [SW05] for more details.\n\nRandomizedSystem(F::Union{System,AbstractSystem}, A::Matrix{ComplexF64})\n\nExplicitly provide the used randomization matrix A.\n\n[SW05]: Sommese, A. J., & Wampler, C. W. (2005). The Numerical Solution of Systems of Polynomials Arising in Engineering and Science. World Scientific.\n\n\n\n\n\n","category":"type"},{"location":"endgame_tracker/#EndgameTracker","page":"EndgameTracker","title":"EndgameTracker","text":"","category":"section"},{"location":"endgame_tracker/","page":"EndgameTracker","title":"EndgameTracker","text":"EndgameTracker is a data structure to track for a given AbstractHomotopy H(xt) a solution x from t₁  0 to 0, i.e.,  H(xt₁) = 0 and x with H(x0) = 0 is returned. This is done by following an implicitly defined path x(t) using Tracker. In contrast to Tracker this also has an endgame to handle diverging paths and singular solutions.","category":"page"},{"location":"endgame_tracker/","page":"EndgameTracker","title":"EndgameTracker","text":"AbstractPathTracker","category":"page"},{"location":"endgame_tracker/#HomotopyContinuation.AbstractPathTracker","page":"EndgameTracker","title":"HomotopyContinuation.AbstractPathTracker","text":"AbstractPathTracker\n\nSupertype for path trackers.\n\n\n\n\n\n","category":"type"},{"location":"endgame_tracker/#Constructor-and-Options","page":"EndgameTracker","title":"Constructor and Options","text":"","category":"section"},{"location":"endgame_tracker/","page":"EndgameTracker","title":"EndgameTracker","text":"EndgameTracker\nEndgameOptions","category":"page"},{"location":"endgame_tracker/#HomotopyContinuation.EndgameTracker","page":"EndgameTracker","title":"HomotopyContinuation.EndgameTracker","text":"EndgameTracker(tracker::Tracker; options = EndgameOptions())\nEndgameTracker(H::AbstractHomotopy; options = EndgameOptions())\n\nA EndgameTracker combines a Tracker with an endgame. That is, while a Tracker assumes that the solution path is non-singular and convergent, the endgame allows to handle singular endpoints as well as diverging paths. To compute singular solutions the Cauchy endgame used, for divering paths a strategy based on the valuation of local Puiseux series expansion of the path is used. See [BT20] for a detailed description. By convention, a EndgameTracker always tracks from t=1 to t = 0. See EndgameOptions for the possible options.\n\n[BT20]: Breiding, P. and Timme, S. \"Tropical Endgame\", In preparation (2020)\n\n\n\n\n\n","category":"type"},{"location":"endgame_tracker/#HomotopyContinuation.EndgameOptions","page":"EndgameTracker","title":"HomotopyContinuation.EndgameOptions","text":"EndgameOptions(; options...)\n\nOptions controlling the behaviour of a EndgameTracker.\n\nOptions\n\nat_infinity_check = true: Whether divering paths should be truncated.\nendgame_start = 0.1: The point t in time where the endgame starts. Set it to 0.0 to disable the endgame.\nonly_nonsingular = false: If true don't run the Cauchy endgame to handle singular solutions.\nzero_is_at_infinity = false: Whether paths going to a solution where at least one coordinates is zero should also be considered diverging.\n\nParameters\n\nThese parameters control the behaviour during the endgame. See [BT20] for details.\n\nmax_endgame_steps = 2000: The maximal number of steps performed during the endgame.\nmax_winding_number = 6: The maximal winding number which is attempted in the\n\nCauchy endgame.\n\nmin_cond = 1e6: The minimal condition number after which an endgame strategy is considered to be applied.\nmin_cond_growth = 1e4: The minimal condition number growth after which an  endgame strategy is considered to be applied.\nmin_coord_growth = 100: The minimal relative growth of a coordinate necessary to to be considered going to infininity (resp. zero).\nval_at_infinity_tol = 1e-3: Tolerance on the valuation which has to be satisfied before a path is considered to diverge / go to infinity.\nval_finite_tol = 1e-3: Tolerance on the valuation which has to be satisfied before the Cauchy endgame is started.\n\n[BT20]: Breiding, P. and Timme, S. \"Tropical Endgame\", In preparation (2020)\n\n\n\n\n\n","category":"type"},{"location":"endgame_tracker/#Tracking","page":"EndgameTracker","title":"Tracking","text":"","category":"section"},{"location":"endgame_tracker/","page":"EndgameTracker","title":"EndgameTracker","text":"track(::EndgameTracker, ::AbstractVector, ::Real)","category":"page"},{"location":"endgame_tracker/#HomotopyContinuation.track-Tuple{EndgameTracker,AbstractArray{T,1} where T,Real}","page":"EndgameTracker","title":"HomotopyContinuation.track","text":"track(endgame_tracker::EndgameTracker, x::AbstractVector, t::Real = 1.0;\n      path_number = nothing, debug = false)\n\nTrack the given start solution x from t towards 0 using the given endgame_tracker. Returns a PathResult.\n\ntrack(endgame_tracker::EndgameTracker, r::PathResult, t::Real = 1.0;\n      path_number = nothing, debug = false)\n\nTrack solution(r) from t towards 0 using the given endgame_tracker.\n\n\n\n\n\n","category":"method"},{"location":"start_systems/#Start-Systems","page":"Start systems","title":"Start Systems","text":"","category":"section"},{"location":"start_systems/#Total-Degree","page":"Start systems","title":"Total Degree","text":"","category":"section"},{"location":"start_systems/","page":"Start systems","title":"Start systems","text":"total_degree","category":"page"},{"location":"start_systems/#HomotopyContinuation.total_degree","page":"Start systems","title":"HomotopyContinuation.total_degree","text":"total_degree(\n    F::System;\n    parameters = nothing,\n    gamma = cis(2π * rand()),\n    tracker_options = TrackerOptions(),\n    endgame_options = EndgameOptions(),\n)\n\nSolve the system F using a total degree homotopy. This returns a path tracker (EndgameTracker or OverdeterminedTracker) and an iterator to compute the start solutions. If the system F has declared variable_groups then a multi-homogeneous a start system following [Wam93] will be constructed.\n\n[Wam93]: An efficient start system for multi-homogeneous polynomial continuation, Wampler, C.W. Numer. Math. (1993) 66: 517. https://doi.org/10.1007/BF01385710\n\n\n\n\n\n","category":"function"},{"location":"start_systems/#Mixed-Volume-(Polyhedral-Homotopy)","page":"Start systems","title":"Mixed Volume (Polyhedral Homotopy)","text":"","category":"section"},{"location":"start_systems/","page":"Start systems","title":"Start systems","text":"polyhedral\nPolyhedralTracker","category":"page"},{"location":"start_systems/#HomotopyContinuation.polyhedral","page":"Start systems","title":"HomotopyContinuation.polyhedral","text":"polyhedral(F::Union{System, AbstractSystem};\n    only_non_zero = false,\n    endgame_options = EndgameOptions(),\n    tracker_options = TrackerOptions())\n\nSolve the system F in two steps: first solve a generic system derived from the support of F using a polyhedral homotopy as proposed in [HS95], then perform a coefficient-parameter homotopy towards F. This returns a path tracker (PolyhedralTracker or OverdeterminedTracker) and an iterator to compute the start solutions.\n\nIf only_non_zero is true, then only the solutions with non-zero coordinates are computed. In this case the number of paths to track is equal to the mixed volume of the Newton polytopes of F.\n\nIf only_non_zero is false, then all isolated solutions of F are computed. In this case the number of paths to track is equal to the mixed volume of the convex hulls of supp(F_i)  0 where supp(F_i) is the support of F_i. See also [LW96].\n\nfunction polyhedral(\n    support::AbstractVector{<:AbstractMatrix},\n    coefficientss::AbstractVector{<:AbstractVector{<:Number}};\n    kwargs...,\n)\n\nIt is also possible to provide directly the support and coefficients of the system F to be solved.\n\n[HS95]: Birkett Huber and Bernd Sturmfels. “A Polyhedral Method for Solving Sparse Polynomial Systems.” Mathematics of Computation, vol. 64, no. 212, 1995, pp. 1541–1555\n\n[LW96]: T.Y. Li and Xiaoshen Wang. \"The BKK root count in C^n\". Math. Comput. 65, 216 (October 1996), 1477–1484.\n\nExample\n\nWe consider a system f which has in total 6 isolated solutions, but only 3 where all coordinates are non-zero.\n\n@var x y\nf = System([2y + 3 * y^2 - x * y^3, x + 4 * x^2 - 2 * x^3 * y])\ntracker, starts = polyhedral(f; only_non_zero = false)\n# length(starts) == 8\ncount(is_success, track.(tracker, starts)) # 6\n\ntracker, starts = polyhedral(f; only_non_zero = true)\n# length(starts) == 3\ncount(is_success, track.(tracker, starts)) # 3\n\n\n\n\n\n","category":"function"},{"location":"start_systems/#HomotopyContinuation.PolyhedralTracker","page":"Start systems","title":"HomotopyContinuation.PolyhedralTracker","text":"PolyhedralTracker <: AbstractPathTracker\n\nThis tracker realises the two step approach of the polyhedral homotopy. See also [polyhedral].\n\n\n\n\n\n","category":"type"},{"location":"start_systems/#Overdetermined","page":"Start systems","title":"Overdetermined","text":"","category":"section"},{"location":"start_systems/","page":"Start systems","title":"Start systems","text":"OverdeterminedTracker\nsquare_up\nexcess_solution_check!\nexcess_solution_check","category":"page"},{"location":"start_systems/#HomotopyContinuation.OverdeterminedTracker","page":"Start systems","title":"HomotopyContinuation.OverdeterminedTracker","text":"OverdeterminedTracker(tracker::AbstractPathTracker, F::RandomizedSystem)\n\nWraps the given AbstractPathTracker tracker to apply excess_solution_check for the given randomized system F on each path result.\n\n\n\n\n\n","category":"type"},{"location":"start_systems/#HomotopyContinuation.square_up","page":"Start systems","title":"HomotopyContinuation.square_up","text":"square_up(F::Union{System, AbstractSystem})\n\nCreates the RandomizedSystem mathfrakR(F(x) N) where N is the number of variables of F.\n\n\n\n\n\n","category":"function"},{"location":"start_systems/#HomotopyContinuation.excess_solution_check!","page":"Start systems","title":"HomotopyContinuation.excess_solution_check!","text":"excess_solution_check!(path_result::PathResult,\n                       F::RandomizedSystem,\n                       newton_cache = NewtonCache(F.system))\n\nAssigns to the PathResult path_result the return_code :excess_solution if the path_result is a solution of the randomized system F but not of the polynomial system underlying F. This is performed by using Newton's method for non-singular solutions and comparing the residuals of the solutions for singular solutions.\n\n\n\n\n\n","category":"function"},{"location":"start_systems/#HomotopyContinuation.excess_solution_check","page":"Start systems","title":"HomotopyContinuation.excess_solution_check","text":"excess_solution_check(F::RandomizedSystem)\n\nReturns a function λ(::PathResult) which performs the excess solution check. The call excess_solution_check(F)(path_result) is identical to excess_solution_check!(F, path_result). See also excess_solution_check!.\n\n\n\n\n\n","category":"function"},{"location":"result/#Results","page":"Results","title":"Results","text":"","category":"section"},{"location":"result/","page":"Results","title":"Results","text":"A call to solve returns a Result:","category":"page"},{"location":"result/","page":"Results","title":"Results","text":"Result\nseed(::Result)\npath_results(::Result)","category":"page"},{"location":"result/#HomotopyContinuation.Result","page":"Results","title":"HomotopyContinuation.Result","text":"Result\n\nThe result of solve. This is a wrapper around the results of each single path (PathResult) and it contains some additional information like a random seed to replicate the result.\n\n\n\n\n\n","category":"type"},{"location":"result/#HomotopyContinuation.seed-Tuple{Result}","page":"Results","title":"HomotopyContinuation.seed","text":"seed(::Result)\n\nReturns the seed to replicate the result.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.path_results-Tuple{Result}","page":"Results","title":"HomotopyContinuation.path_results","text":"path_results(::Result)\n\nReturns the stored PathResults.\n\n\n\n\n\n","category":"method"},{"location":"result/#Filtering-results-and-solutions","page":"Results","title":"Filtering results and solutions","text":"","category":"section"},{"location":"result/","page":"Results","title":"Results","text":"results\nsolutions\nBase.real(::Result)\nreal_solutions\nnonsingular\nsingular\nat_infinity\nfailed","category":"page"},{"location":"result/#HomotopyContinuation.results","page":"Results","title":"HomotopyContinuation.results","text":"results(\n    result;\n    only_real = false,\n    real_tol = 1e-6,\n    only_nonsingular = false,\n    only_singular = false,\n    only_finite = true,\n    multiple_results = false,\n)\nresults(f, result; options...)\n\nReturn all PathResults for which satisfy the given conditions and apply, if provided, the function f.\n\n\n\n\n\nresults(result::MonodromyResult)\n\nReturns the computed PathResults.\n\n\n\n\n\nresults(W::WitnessSet)\n\nGet the results stored in W.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.solutions","page":"Results","title":"HomotopyContinuation.solutions","text":"solutions(result; only_nonsingular = true, conditions...)\n\nReturns all solutions for which the given conditions apply, see results for the possible conditions.\n\nExample\n\njulia> @var x y\njulia> F = System([(x-2)y, y+x+3]);\njulia> solutions(solve(F))\n2-element Array{Array{Complex{Float64},1},1}:\n [2.0 + 0.0im, -5.0 + 0.0im]\n [-3.0 + 0.0im, 0.0 + 0.0im]\n\n\n\n\n\nsolutions(result::MonodromyResult)\n\nReturn all solutions.\n\n\n\n\n\nsolutions(W::WitnessSet)\n\nGet the solutions stored in W.\n\n\n\n\n\n","category":"function"},{"location":"result/#Base.real-Tuple{Result}","page":"Results","title":"Base.real","text":"real(result, tol=1e-6)\n\nGet all results where the solutions are real with the given tolerance tol. See is_real for details regarding the determination of 'realness'.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.real_solutions","page":"Results","title":"HomotopyContinuation.real_solutions","text":"real_solutions(result; tol=1e-6, conditions...)\n\nReturn all real solution for which the given conditions apply. For the possible conditions see results. Note that only_real is always true and real_tol is now tol.\n\nExample\n\njulia> @var x y;\njulia> F = System([(x-2)y, y+x+3]);\njulia> real_solutions(solve(F))\n2-element Array{Array{Float64,1},1}:\n [2.0, -5.0]\n [-3.0, 0.0]\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nonsingular","page":"Results","title":"HomotopyContinuation.nonsingular","text":"nonsingular(result; conditions...)\n\nReturn all PathResults for which the solution is non-singular. This is just a shorthand for results(R; only_nonsingular=true, conditions...). For the possible conditions see results.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.singular","page":"Results","title":"HomotopyContinuation.singular","text":"singular(result; multiple_results=false, kwargs...)\n\nReturn all [PathResult]s for which the solution is singular. If multiple_results=false only one point from each cluster of multiple solutions is returned. If multiple_results = true all singular solutions in R are returned. For the possible kwargs see results.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.at_infinity","page":"Results","title":"HomotopyContinuation.at_infinity","text":"at_infinity(result)\n\nGet all results where the solutions is at infinity.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.failed","page":"Results","title":"HomotopyContinuation.failed","text":"failed(result)\n\nGet all results where the path tracking failed.\n\n\n\n\n\n","category":"function"},{"location":"result/#Counting","page":"Results","title":"Counting","text":"","category":"section"},{"location":"result/","page":"Results","title":"Results","text":"nresults\nnsolutions\nnreal\nnnonsingular\nnsingular\nnat_infinity\nnexcess_solutions\nnfailed","category":"page"},{"location":"result/#HomotopyContinuation.nresults","page":"Results","title":"HomotopyContinuation.nresults","text":"nresults(\n    result;\n    only_real = false,\n    real_tol = 1e-6,\n    only_nonsingular = false,\n    only_singular = false,\n    only_finite = true,\n    multiple_results = false,\n)\n\nCount the number of results which satisfy the corresponding conditions. See also results.\n\n\n\n\n\nnresults(result::MonodromyResult)\n\nReturns the number of results computed.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nsolutions","page":"Results","title":"HomotopyContinuation.nsolutions","text":"nsolutions(result; only_nonsingular = true, options...)\n\nThe number of solutions. See results for the possible options.\n\n\n\n\n\nnsolutions(result::MonodromyResult)\n\nReturns the number solutions of the result.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nreal","page":"Results","title":"HomotopyContinuation.nreal","text":"nreal(result; tol=1e-6)\n\nThe number of real solutions. See also is_real.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nnonsingular","page":"Results","title":"HomotopyContinuation.nnonsingular","text":"nnonsingular(result)\n\nThe number of non-singular solutions. See also is_singular.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nsingular","page":"Results","title":"HomotopyContinuation.nsingular","text":"nsingular(\n    result;\n    counting_multiplicities = false,\n    kwargs...,\n)\n\nThe number of singular solutions. A solution is considered singular if its winding number is larger than 1 or the condition number is larger than tol. If counting_multiplicities=true the number of singular solutions times their multiplicities is returned.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nat_infinity","page":"Results","title":"HomotopyContinuation.nat_infinity","text":"nat_infinity(result)\n\nThe number of solutions at infinity.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nexcess_solutions","page":"Results","title":"HomotopyContinuation.nexcess_solutions","text":"nexcess_solutions(result)\n\nThe number of exess solutions. See also excess_solution_check.\n\n\n\n\n\n","category":"function"},{"location":"result/#HomotopyContinuation.nfailed","page":"Results","title":"HomotopyContinuation.nfailed","text":"nfailed(result)\n\nThe number of failed paths.\n\n\n\n\n\n","category":"function"},{"location":"result/#PathResult","page":"Results","title":"PathResult","text":"","category":"section"},{"location":"result/","page":"Results","title":"Results","text":"PathResult\nsolution(::PathResult)\nis_success(::PathResult)\nis_at_infinity(::PathResult)\nis_excess_solution(::PathResult)\nis_failed(::PathResult)\nis_finite(::PathResult)\nis_singular(::PathResult)\nis_nonsingular(::PathResult)\nis_real(::PathResult)\naccuracy(::PathResult)\nresidual(::PathResult)\nsteps(::PathResult)\naccepted_steps(::PathResult)\nrejected_steps(::PathResult)\nwinding_number(::PathResult)\npath_number(::PathResult)\nstart_solution(::PathResult)\nmultiplicity(::PathResult)\nlast_path_point(::PathResult)\nvaluation(::PathResult)","category":"page"},{"location":"result/#HomotopyContinuation.PathResult","page":"Results","title":"HomotopyContinuation.PathResult","text":"PathResult\n\nA PathResult is the result of tracking of a path with track using an AbstractPathTracker ( e.g. EndgameTracker)\n\nFields\n\nGeneral solution information:\n\nreturn_code: See the list of return codes below.\nsolution::V: The solution vector.\nt::Float64: The value of t at which solution was computed. Note that if return_code is :at_infinity, then t is the value when this was decided.\naccuracy::Float64: An estimate the (relative) accuracy of the computed solution.\nresidual::Float64: The infinity norm of H(solution,t).\ncondition_jacobian::Float64: This is the condition number of the Jacobian at the solution. A high condition number indicates a singular solution or a solution on a positive dimensional component.\nsingular::Bool: Whether the solution is considered singular.\nwinding_number:Union{Nothing, Int}: The computed winding number. This is a lower bound on the multiplicity of the solution. It is nothing if the Cauchy endgame was not used.\nextended_precision::Bool: Indicate whether extended precision is necessary to achieve the accuracy of the solution.\npath_number::Union{Nothing,Int}: The number of the path (optional).\nstart_solution::Union{Nothing,V}: The start solution of the path (optional).\n\nPerformance information:\n\naccepted_steps::Int: The number of accepted steps during the path tracking.\nrejected_steps::Int: The number of rejected steps during the path tracking.\nextended_precision_used::Bool: Indicates whether extended precision was necessary to track the path.\n\nAdditional path and solution informations\n\nvaluation::Vector{Float64}: An approximation of the valuation of the Puiseux series expansion of x(t).\nlast_path_point::Tuple{V,Float64}: The last pair (xt) before the solution was computed. If the solution was computed with the Cauchy endgame, then the pair (xt) can be used to rerun the endgame.\n\nReturn codes\n\nPossible return codes are:\n\n:success: The EndgameTracker obtained a solution.\n:at_infinity: The EndgameTracker stopped the tracking of the path since it determined that that path is diverging towards infinity.\n:at_zero: The EndgameTracker stopped the tracking of the path since it determined that that path has a solution where at least one coordinate is 0. This only happens if the option zero_is_at_infinity is true.\n:excess_solution: For the solution of the system, the system had to be modified which introduced artificial solutions and this solution is one of them.\nvarious return codes indicating termination of the tracking\n\n\n\n\n\n","category":"type"},{"location":"result/#HomotopyContinuation.solution-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.solution","text":"solution(r::PathResult)\n\nGet the solution of the path.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_success-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_success","text":"is_success(r::PathResult)\n\nChecks whether the path is successfull.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_at_infinity-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_at_infinity","text":"is_at_infinity(r::PathResult)\n\nChecks whether the path goes to infinity.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_excess_solution-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_excess_solution","text":"is_excess_solution(r::PathResult)\n\nChecks whether the path is successfull.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_failed-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_failed","text":"is_failed(r::PathResult)\n\nChecks whether the path failed.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_finite-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_finite","text":"is_finite(r::PathResult)\n\nChecks whether the path result is finite.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_singular-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_singular","text":"is_singular(r::PathResult)\n\nChecks whether the path result r is singular.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_nonsingular-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_nonsingular","text":"is_nonsingular(r::PathResult)\n\nChecks whether the path result is non-singular. This is true if it is not singular.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.is_real-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.is_real","text":"is_real(r::PathResult; tol::Float64 = 1e-6)\n\nWe consider a result as real if the infinity-norm of the imaginary part of the solution is at most tol.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.accuracy-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.accuracy","text":"accuracy(r::PathResult)\n\nGet the accuracy of the solution. This is an estimate of the (relative) distance to the true solution.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.residual-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.residual","text":"residual(r::PathResult)\n\nGet the residual of the solution.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.steps-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.steps","text":"steps(r::PathResult)\n\nTotal number of steps the path tracker performed.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.accepted_steps-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.accepted_steps","text":"accepted_steps(r::PathResult)\n\nTotal number of steps the path tracker accepted.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.rejected_steps-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.rejected_steps","text":"rejected_steps(r::PathResult)\n\nTotal number of steps the path tracker rejected.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.winding_number-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.winding_number","text":"winding_number(r::PathResult)\n\nGet the winding number of the solution of the path. Returns nothing if it wasn't computed.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.path_number-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.path_number","text":"path_number(r::PathResult)\n\nGet the number of the path. Returns nothing if it wasn't provided.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.start_solution-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.start_solution","text":"start_solution(r::PathResult)\n\nGet the start solution of the path.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.multiplicity-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.multiplicity","text":"multiplicity(r::PathResult)\n\nGet the multiplicity of the solution of the path.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.last_path_point-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.last_path_point","text":"last_path_point(r::PathResult)\n\nReturns a tuple (x,t) containing the last zero of H(x, t) before the Cauchy endgame was used. Returns nothing if the endgame strategy was not invoked.\n\n\n\n\n\n","category":"method"},{"location":"result/#HomotopyContinuation.valuation-Tuple{PathResult}","page":"Results","title":"HomotopyContinuation.valuation","text":"valuation(r::PathResult)\n\nGet the computed valuation of the path.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#Homotopies","page":"Homotopies","title":"Homotopies","text":"","category":"section"},{"location":"homotopies/","page":"Homotopies","title":"Homotopies","text":"Homotopies (AbstractHomotopy) are at the heart of homotopy continuation. A homotopy is a parameterized family H(xt) of polynomial systems. By convention, homotopies are tracked from t=1 to t=0, i.e., H(x1) is considered the start system and H(x0) is the target system.","category":"page"},{"location":"homotopies/","page":"Homotopies","title":"Homotopies","text":"AbstractHomotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.ModelKit.AbstractHomotopy","page":"Homotopies","title":"HomotopyContinuation.ModelKit.AbstractHomotopy","text":"AbstractHomotopy\n\nAn abstract type representing a homotopy H(x t) where x are variables and t is space / time.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/","page":"Homotopies","title":"Homotopies","text":"As for AbstractSystems, AbstractHomotopy and Homotopy share different purposes. A Homotopy is intended for formulating your problem symbolically. A Homotopy can be converted to two different basic AbstractHomotopys, a CompiledHomotopy (fast, but introduce compilation overhead) and an InterpretedHomotopy (slower, but not compilation overhead).","category":"page"},{"location":"homotopies/","page":"Homotopies","title":"Homotopies","text":"CompiledHomotopy\nInterpretedHomotopy\nMixedHomotopy\nfixed(::Homotopy)","category":"page"},{"location":"homotopies/#HomotopyContinuation.ModelKit.CompiledHomotopy","page":"Homotopies","title":"HomotopyContinuation.ModelKit.CompiledHomotopy","text":"CompiledHomotopy <: AbstractHomotopy\n\nAn AbstractHomotopy which automatically compiles a straight line program for the fast evaluation of a homotopy H and its Jacobian. For large homotopies the compilation can take some time and require a large amount of memory. If this is a problem consider InterpretedHomotopy.\n\nCompiledSystem(F::System; optimizations = true)\n\nConstruct a CompiledSystem from the given System F. If optimizations = true then optimize is called on F before compiling.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.ModelKit.InterpretedHomotopy","page":"Homotopies","title":"HomotopyContinuation.ModelKit.InterpretedHomotopy","text":"InterpretedHomotopy <: AbstractHomotopy\n\nAn AbstractHomotopy which automatically generates a program for the fast evaluation of H and its Jacobian. The program is however, not compiled but rather interpreted. See also CompiledHomotopy.\n\nInterpretedHomotopy(H::Homotopy; optimizations = true)\n\nConstruct an InterpretedHomotopy from the given Homotopy H. If optimizations = true then optimize is called on H before compiling.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.MixedHomotopy","page":"Homotopies","title":"HomotopyContinuation.MixedHomotopy","text":"MixedHomotopy\n\nA data structure which uses for evaluate! and evaluate_and_jacobian! a CompiledHomotopy and for taylor! an InterpretedHomotopy.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.fixed-Tuple{Homotopy}","page":"Homotopies","title":"HomotopyContinuation.fixed","text":"fixed(H::Homotopy; compile::Union{Bool,Symbol} = mixed)\n\nConstructs either a CompiledHomotopy (if compile = :all), an InterpretedHomotopy (if compile = :none) or a MixedHomotopy (compile = :mixed).\n\n\n\n\n\n","category":"method"},{"location":"homotopies/","page":"Homotopies","title":"Homotopies","text":"Below you can find a list of all pre-defined homotopies. Additionally the following higher level constructors are exported.","category":"page"},{"location":"homotopies/","page":"Homotopies","title":"Homotopies","text":"parameter_homotopy\nlinear_subspace_homotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.parameter_homotopy","page":"Homotopies","title":"HomotopyContinuation.parameter_homotopy","text":"parameter_homotopy(F; start_parameters, target_parameters)\n\nConstruct a ParameterHomotopy. If F is homogeneous, then a random affine chart is chosen (via AffineChartHomotopy).\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#HomotopyContinuation.linear_subspace_homotopy","page":"Homotopies","title":"HomotopyContinuation.linear_subspace_homotopy","text":"linear_subspace_homotopy(F, V::LinearSubspace, W::LinearSubspace, intrinsic = nothing)\n\nConstructs an IntrinsicSubspaceHomotopy (if dim(V) < codim(V) or intrinsic = true) or ExtrinsicSubspaceHomotopy. Compared to the direct constructor, this also takes care of homogeneous systems.\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#AffineChartHomotopy","page":"Homotopies","title":"AffineChartHomotopy","text":"","category":"section"},{"location":"homotopies/","page":"Homotopies","title":"Homotopies","text":"AffineChartHomotopy\non_affine_chart(F::Homotopy, dims)","category":"page"},{"location":"homotopies/#HomotopyContinuation.AffineChartHomotopy","page":"Homotopies","title":"HomotopyContinuation.AffineChartHomotopy","text":"AffineChartHomotopy(H::AbstractHomotopy, v::PVector{T,N})\n\nGiven a homotopy H(xt) (ℙ^m_1    ℙ^m_N)  ℂ  ℂⁿ this creates a new affine homotopy H which operates on the affine chart defined by the vector v  ℙ^m_1    ℙ^m_N and the augmented conditions vᵀx = 1.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.on_affine_chart-Tuple{Homotopy,Any}","page":"Homotopies","title":"HomotopyContinuation.on_affine_chart","text":"on_affine_chart(H::Union{Homotopy,AbstractHomotopy}, proj_dims)\n\nConstruct an AffineChartHomotopy on a randomly generated chart v. Each entry is drawn idepdently from a univariate normal distribution.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#CoefficientHomotopy","page":"Homotopies","title":"CoefficientHomotopy","text":"","category":"section"},{"location":"homotopies/","page":"Homotopies","title":"Homotopies","text":"CoefficientHomotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.CoefficientHomotopy","page":"Homotopies","title":"HomotopyContinuation.CoefficientHomotopy","text":"CoefficientHomotopy(\n    F::Union{AbstractSystem,System};\n    start_coefficients,\n    target_coefficients,\n)\n\nConstruct the homotopy H(x t) = _a  Aᵢ (c_a t + (1-t)d_a) x^a where c_a are the start coefficients and d_a the target coefficients.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#FixedParameterHomotopy","page":"Homotopies","title":"FixedParameterHomotopy","text":"","category":"section"},{"location":"homotopies/","page":"Homotopies","title":"Homotopies","text":"FixedParameterHomotopy\nfix_parameters(H::AbstractHomotopy, p)","category":"page"},{"location":"homotopies/#HomotopyContinuation.FixedParameterHomotopy","page":"Homotopies","title":"HomotopyContinuation.FixedParameterHomotopy","text":"FixedParameterHomotopy(H:AbstractHomotopy, parameters)\n\nConstruct a homotopy from the given AbstractHomotopy H with the given parameters fixed.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.fix_parameters-Tuple{AbstractHomotopy,Any}","page":"Homotopies","title":"HomotopyContinuation.fix_parameters","text":"fix_parameters(H::Union{Homotopy,AbstractHomotopy}, p; compile::Union{Bool,Symbol} = mixed)\n\nFix the parameters of the given homotopy H. Returns a FixedParameterHomotopy.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#ExtrinsicSubspaceHomotopy","page":"Homotopies","title":"ExtrinsicSubspaceHomotopy","text":"","category":"section"},{"location":"homotopies/","page":"Homotopies","title":"Homotopies","text":"ExtrinsicSubspaceHomotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.ExtrinsicSubspaceHomotopy","page":"Homotopies","title":"HomotopyContinuation.ExtrinsicSubspaceHomotopy","text":"ExtrinsicSubspaceHomotopy\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#IntrinsicSubspaceHomotopy","page":"Homotopies","title":"IntrinsicSubspaceHomotopy","text":"","category":"section"},{"location":"homotopies/","page":"Homotopies","title":"Homotopies","text":"IntrinsicSubspaceHomotopy\nset_subspaces!","category":"page"},{"location":"homotopies/#HomotopyContinuation.IntrinsicSubspaceHomotopy","page":"Homotopies","title":"HomotopyContinuation.IntrinsicSubspaceHomotopy","text":"IntrinsicSubspaceHomotopy(F::System, V::LinearSubspace, W::LinearSubspace)\nIntrinsicSubspaceHomotopy(F::AbstractSystem, V::LinearSubspace, W::LinearSubspace)\n\nCreates a homotopy H(xt) = F(γ(t)x) where γ(t) is a family of affine subspaces such that γ(1) = V and γ(0) = W. Here γ(t) is the geodesic between V and W in the affine Grassmanian, i.e., it is the curve of minimal length connecting V and W. See also LinearSubspace and geodesic and the references therein.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.set_subspaces!","page":"Homotopies","title":"HomotopyContinuation.set_subspaces!","text":"set_subspaces!(H::IntrinsicSubspaceHomotopy, start::LinearSubspace, target::LinearSubspace)\n\nUpdate the homotopy H to track from the affine subspace start to target.\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#ParameterHomotopy","page":"Homotopies","title":"ParameterHomotopy","text":"","category":"section"},{"location":"homotopies/","page":"Homotopies","title":"Homotopies","text":"ParameterHomotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.ParameterHomotopy","page":"Homotopies","title":"HomotopyContinuation.ParameterHomotopy","text":"ParameterHomotopy(F::Union{AbstractSystem,System}; start_parameters, target_parameters)\nParameterHomotopy(F::Union{AbstractSystem,System}, start_parameters, target_parameters)\n\nConstruct the parameter homotopy H(xt) = F(x t p + (1 - t) q) where p is start_parameters and q is target_parameters.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#StraightLineHomotopy","page":"Homotopies","title":"StraightLineHomotopy","text":"","category":"section"},{"location":"homotopies/","page":"Homotopies","title":"Homotopies","text":"StraightLineHomotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.StraightLineHomotopy","page":"Homotopies","title":"HomotopyContinuation.StraightLineHomotopy","text":"StraightLineHomotopy(G::System, F::System; gamma = 1.0)\nStraightLineHomotopy(G::AbstractSystem, F::AbstractSystem; gamma = 1.0)\n\nConstructs the straight line homotopy H(x t) = γ t G(x) + (1-t) F(x) where γ is gamma.\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#Solving-parametrized-systems-with-monodromy","page":"Monodromy","title":"Solving parametrized systems with monodromy","text":"","category":"section"},{"location":"monodromy/","page":"Monodromy","title":"Monodromy","text":"Next to solve, HomotopyContinuation.jl provides the function monodromy_solve which uses the monodromy method to solve a parameterized system of polynomials. Often monodromy_solve allows to still compute all isolated solutions of system where the number of paths tracked in  solve](@ref) is already infeasible. Make sure to check out our monodromy guide for a more in depth introduction into this method.","category":"page"},{"location":"monodromy/","page":"Monodromy","title":"Monodromy","text":"monodromy_solve\nMonodromyOptions\nfind_start_pair","category":"page"},{"location":"monodromy/#HomotopyContinuation.monodromy_solve","page":"Monodromy","title":"HomotopyContinuation.monodromy_solve","text":"monodromy_solve(F, [sols, p]; options..., tracker_options = TrackerOptions())\n\nSolve a polynomial system F(x;p) with specified parameters and initial solutions sols by monodromy techniques. This makes loops in the parameter space of F to find new solutions. If F the parameters p only occur linearly in F it is eventually possible to compute a start pair (x₀ p₀) automatically. In this case sols and p can be omitted and the automatically generated parameters can be obtained with the parameters function from the MonodromyResult.\n\nmonodromy_solve(F, [sols, L]; dim, codim, intrinsic = nothing, options...,\n                              tracker_options = TrackerOptions())\n\nSolve the polynomial system [F(x); L(x)] = 0 where L is a [LinearSubspace](@ref). If sols and L are not provided it is necesary to provide dim or codim where (co)dim is the expected (co)dimension of a component of V(F). See also linear_subspace_homotopy for the intrinsic option.\n\nOptions\n\ncatch_interrupt = true: If true catches interruptions (e.g. issued by pressing Ctrl-C) and returns the partial result.\ncheck_startsolutions = true: If true, we do a Newton step for each entry of solsfor checking if it is a valid startsolutions. Solutions which are not valid are sorted out.\ncompile = mixed: If true then a System (resp. Homotopy) is compiled to a straight line program (CompiledSystem resp. CompiledHomotopy) for evaluation. This induces a compilation overhead. If false then the generated program is only interpreted (InterpretedSystem resp. InterpretedHomotopy). This is slower than the compiled version, but does not introduce compilation overhead.\ndistance = EuclideanNorm(): The distance function used for UniquePoints.\nloop_finished_callback = always_false: A callback to end the computation. This function is called with all current PathResults after a loop is exhausted. 2 arguments. Return true if the compuation should be stopped.\nequivalence_classes=true: This only applies if there is at least one group action supplied. We then consider two solutions in the same equivalence class if we can transform one to the other by the supplied group actions. We only track one solution per equivalence class.\ngroup_action = nothing: A function taking one solution and returning other solutions if there is a constructive way to obtain them, e.g. by symmetry.\ngroup_actions = nothing: If there is more than one group action you can use this to chain the application of them. For example if you have two group actions foo and bar you can set group_actions=[foo, bar]. See GroupActions for details regarding the application rules.\nmax_loops_no_progress = 5: The maximal number of iterations (i.e. loops generated) without any progress.\nmin_solutions: The minimal number of solutions before a stopping heuristic is applied. By default no lower limit is enforced.\nparameter_sampler = independent_normal: A function taking the parameter p and returning a new random parameter q. By default each entry of the parameter vector is drawn independently from Normal distribution.\npermutations = false: Whether to keep track of the permutations induced by the loops.\nresuse_loops = :all: Strategy to reuse other loops for new found solutions. :all propagates a new solution through all other loops, :random picks a random loop, :none doesn't reuse a loop.\ntarget_solutions_count: The computation is stopped if this number of solutions is reached.\nthreading = true: Enable multithreading of the path tracking.\ntimeout: The maximal number of seconds the computation is allowed to run.\ntrace_test = true: If true a trace test is performed to check whether all solutions are found. This is only applicable if monodromy is performed with a linear subspace. See also trace_test.\ntrace_test_tol = 1e-10: The tolerance for the trace test to be successfull. The trace is divided by the number of solutions before compared to the tracetesttol.\n\n\n\n\n\n","category":"function"},{"location":"monodromy/#HomotopyContinuation.MonodromyOptions","page":"Monodromy","title":"HomotopyContinuation.MonodromyOptions","text":"MonodromyOptions(; options...)\n\nOptions for monodromy_solve.\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#HomotopyContinuation.find_start_pair","page":"Monodromy","title":"HomotopyContinuation.find_start_pair","text":"find_start_pair(F; max_tries = 100, atol = 0.0, rtol = 1e-12)\n\nTry to find a pair (x,p) for the system F such that F(x,p) = 0 by randomly sampling a pair (x₀, p₀) and performing Newton's method in variable and parameter space.\n\n\n\n\n\n","category":"function"},{"location":"monodromy/","page":"Monodromy","title":"Monodromy","text":"It is also possible to verify (but not certify) that all solutions were found. Note that this computation can take substantially longer than the original monodromy_solve computation.","category":"page"},{"location":"monodromy/","page":"Monodromy","title":"Monodromy","text":"verify_solution_completeness","category":"page"},{"location":"monodromy/#HomotopyContinuation.verify_solution_completeness","page":"Monodromy","title":"HomotopyContinuation.verify_solution_completeness","text":"verify_solution_completeness(F::System, monodromy_result; options...)\nverify_solution_completeness(F::System, solutions, parameters;\n    trace_tol = 1e-14,\n    show_progress = true,\n    compile = COMPILE_DEFAULT[],\n    monodromy_options = (compile = compile,),\n    parameter_homotopy_options = (compile = compile,),\n)\n\nVerify that a monodromy computation found all solutions by monodromy_solve. This uses the trace test described in [dCR17] and [LRS18]. The trace is a numerical value which is 0 if all solutions are found, for this the trace_tol keyword argument is used. The function returns nothing if some computation couldn't be carried out. Otherwise returns a boolean. Note that this function requires the computation of solutions to another polynomial system using monodromy. This routine can return false although all solutions are found if this additional solution set is not complete.\n\nExample\n\n@var x y a b c;\nf = x^2+y^2-1;\nl = a*x+b*y+c;\nsys = System([f, l]; parameters = [a, b, c]);\nmres = monodromy_solve(sys, [-0.6-0.8im, -1.2+0.4im], [1,2,3]);\nshow(mres);\nverify_solution_completeness(sys, mres)\n\nMonodromyResult\n==================================\n• 2 solutions (0 real)\n• return code → heuristic_stop\n• 44 tracked paths\n• seed → 367230\njulia> verify_solution_completeness(sys, mres)\n[ Info: Certify provided solutions...\n[ Info: Got 2 dinstinct solutions.\n[ Info: Compute additional witnesses for completeness...\n┌ Info: MonodromyResult\n│ ===============\n│ • return_code → :heuristic_stop\n│ • 4 solutions\n│ • 28 tracked loops\n└ • random_seed → 0x21e7406a\n[ Info: Certify additional witnesses...\n[ Info: Computed 2 additional witnesses\n[ Info: Compute trace using two parameter homotopies...\n[ Info: Norm of trace: 9.33238819760471e-17\ntrue\n\n[dCR17]: del Campo, Abraham Martín, and Jose Israel Rodriguez. \"Critical points via monodromy and local methods.\" Journal of Symbolic Computation 79 (2017): 559-574.\n\n[LRS18]: Leykin, Anton, Jose Israel Rodriguez, and Frank Sottile. \"Trace test.\" Arnold Mathematical Journal 4.1 (2018): 113-125.\n\n\n\n\n\n","category":"function"},{"location":"monodromy/#Monodromy-Result","page":"Monodromy","title":"Monodromy Result","text":"","category":"section"},{"location":"monodromy/","page":"Monodromy","title":"Monodromy","text":"A call to monodromy_solve returns a MonodromyResult:","category":"page"},{"location":"monodromy/","page":"Monodromy","title":"Monodromy","text":"MonodromyResult\nsolutions(::MonodromyResult)\nnsolutions(result::MonodromyResult)\nparameters(::MonodromyResult)\nresults(result::MonodromyResult)\nnresults(result::MonodromyResult)\nis_success(result::MonodromyResult)\nis_heuristic_stop(result::MonodromyResult)\nseed(result::MonodromyResult)\npermutations(r::MonodromyResult)","category":"page"},{"location":"monodromy/#HomotopyContinuation.MonodromyResult","page":"Monodromy","title":"HomotopyContinuation.MonodromyResult","text":"MonodromyResult\n\nThe monodromy result contains the result of the monodromy_solve computation.\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#HomotopyContinuation.solutions-Tuple{MonodromyResult}","page":"Monodromy","title":"HomotopyContinuation.solutions","text":"solutions(result::MonodromyResult)\n\nReturn all solutions.\n\n\n\n\n\n","category":"method"},{"location":"monodromy/#HomotopyContinuation.nsolutions-Tuple{MonodromyResult}","page":"Monodromy","title":"HomotopyContinuation.nsolutions","text":"nsolutions(result::MonodromyResult)\n\nReturns the number solutions of the result.\n\n\n\n\n\n","category":"method"},{"location":"monodromy/#HomotopyContinuation.ModelKit.parameters-Tuple{MonodromyResult}","page":"Monodromy","title":"HomotopyContinuation.ModelKit.parameters","text":"parameters(result::MonodromyResult)\n\nReturn the parameters corresponding to the given result r.\n\n\n\n\n\n","category":"method"},{"location":"monodromy/#HomotopyContinuation.results-Tuple{MonodromyResult}","page":"Monodromy","title":"HomotopyContinuation.results","text":"results(result::MonodromyResult)\n\nReturns the computed PathResults.\n\n\n\n\n\n","category":"method"},{"location":"monodromy/#HomotopyContinuation.nresults-Tuple{MonodromyResult}","page":"Monodromy","title":"HomotopyContinuation.nresults","text":"nresults(result::MonodromyResult)\n\nReturns the number of results computed.\n\n\n\n\n\n","category":"method"},{"location":"monodromy/#HomotopyContinuation.is_success-Tuple{MonodromyResult}","page":"Monodromy","title":"HomotopyContinuation.is_success","text":"is_success(result::MonodromyResult)\n\nReturns true if the monodromy computation achieved its target solution count.\n\n\n\n\n\n","category":"method"},{"location":"monodromy/#HomotopyContinuation.is_heuristic_stop-Tuple{MonodromyResult}","page":"Monodromy","title":"HomotopyContinuation.is_heuristic_stop","text":"is_heuristic_stop(result::MonodromyResult)\n\nReturns true if the monodromy computation stopped due to the heuristic.\n\n\n\n\n\n","category":"method"},{"location":"monodromy/#HomotopyContinuation.seed-Tuple{MonodromyResult}","page":"Monodromy","title":"HomotopyContinuation.seed","text":"seed(result::MonodromyResult)\n\nReturn the random seed used for the computations.\n\n\n\n\n\n","category":"method"},{"location":"monodromy/#HomotopyContinuation.permutations-Tuple{MonodromyResult}","page":"Monodromy","title":"HomotopyContinuation.permutations","text":"permutations(r::MonodromyResult; reduced=true)\n\nReturn the permutations of the solutions that are induced by tracking over the loops. If reduced=false, then all permutations are returned. If reduced=true then permutations without repetitions are returned.\n\nIf a solution was not tracked in the loop, then the corresponding entry is 0.\n\nExample: monodromy loop for a varying line that intersects two circles.\n\nusing LinearAlgebra\n@var x[1:2] a b c\nc1 = (x - [2, 0]) ⋅ (x - [2, 0]) - 1\nc2 = (x - [-2, 0]) ⋅ (x - [-2, 0]) - 1\nF = [c1 * c2; a * x[1] + b * x[2] - c]\nS = monodromy_solve(F, [[1, 0]], [1, 1, 1], parameters = [a, b, c], permutations = true)\n\npermutations(S)\n\nwill return\n\n2×2 Array{Int64,2}:\n 1  2\n 2  1\n\nand permutations(S, reduced = false) returns\n\n2×12 Array{Int64,2}:\n 1  2  2  1  1  …  1  2  1  1  1\n 2  1  1  2  2     2  1  2  2  2\n\n\n\n\n\n","category":"method"},{"location":"monodromy/#Group-actions","page":"Monodromy","title":"Group actions","text":"","category":"section"},{"location":"monodromy/","page":"Monodromy","title":"Monodromy","text":"If there is a group acting on the solution set of the polynomial system this can provided with the group_action keyword for single group actions or with the group_actions keyword for compositions of group actions. These will be internally transformed into GroupActions.","category":"page"},{"location":"monodromy/","page":"Monodromy","title":"Monodromy","text":"GroupActions","category":"page"},{"location":"monodromy/#HomotopyContinuation.GroupActions","page":"Monodromy","title":"HomotopyContinuation.GroupActions","text":"GroupActions(actions::Function...)\n\nStore a bunch of group actions (f1, f2, f3, ...). Each action has to return a tuple. The actions are applied in the following sense\n\nf1 is applied on the original solution s\nf2 is applied on s and the results of 1\nf3 is applied on s and the results of 1) and 2)\n\nand so on\n\nExample\n\njulia> f1(s) = (s * s,);\n\njulia> f2(s) = (2s, -s, 5s);\n\njulia> f3(s) = (s + 1,);\n\njulia> GroupActions(f1)(3)\n(3, 9)\n\njulia> GroupActions(f1, f2)(3)\n(3, 9, 6, -3, 15, 18, -9, 45)\n\njulia> GroupActions(f1,f2, f3)(3)\n(3, 9, 6, -3, 15, 18, -9, 45, 4, 10, 7, -2, 16, 19, -8, 46)\n\n\n\n\n\n","category":"type"},{"location":"monodromy/","page":"Monodromy","title":"Monodromy","text":"To help with the more common group actions we provide some helper functions:","category":"page"},{"location":"monodromy/","page":"Monodromy","title":"Monodromy","text":"SymmetricGroup","category":"page"},{"location":"monodromy/#HomotopyContinuation.SymmetricGroup","page":"Monodromy","title":"HomotopyContinuation.SymmetricGroup","text":"SymmetricGroup(n)\n\nGroup action of the symmetric group S(n).\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#ModelKit","page":"ModelKit","title":"ModelKit","text":"","category":"section"},{"location":"model_kit/","page":"ModelKit","title":"ModelKit","text":"ModelKit is the symbolic input and modeling language of HomotopyContinuation.jl. It is designed such that you can easily create an efficient formulation of your problem.","category":"page"},{"location":"model_kit/#Expressions-and-Variables","page":"ModelKit","title":"Expressions and Variables","text":"","category":"section"},{"location":"model_kit/","page":"ModelKit","title":"ModelKit","text":"Expression\nVariable\n@var\n@unique_var\nvariables(prefix::Union{Symbol,String}, indices...)","category":"page"},{"location":"model_kit/#HomotopyContinuation.ModelKit.Expression","page":"ModelKit","title":"HomotopyContinuation.ModelKit.Expression","text":"Expression <: Number\n\nA symbolic expression.\n\njulia> expr = (Variable(:x) + 1)^2\n(1 + x)^2\n\njulia> Expression(2)\n2\n\njulia> Expression(Variable(:x))\nx\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation.ModelKit.Variable","page":"ModelKit","title":"HomotopyContinuation.ModelKit.Variable","text":"Variable(name::Union{String,Symbol}, indices...) <: Number\n\nA data structure representing a variable.\n\njulia> Variable(:a)\na\n\njulia> Variable(:x, 1)\nx₁\n\njulia> Variable(:x, 10, 5)\nx₁₀₋₅\n\nEquality and ordering\n\nVariables are identified by their name and indices. That is, two variables are equal if and only if they have the same name and indices.\n\njulia> Variable(:a) == Variable(:a)\ntrue\n\njulia> Variable(:a, 1) == Variable(:a, 2)\nfalse\n\nSimilarly, variables are first ordered lexicographically by their name and then by their indices.\n\njulia> Variable(:a, 1) < Variable(:a, 2)\ntrue\n\njulia> Variable(:a, 1) < Variable(:b, 1)\ntrue\n\njulia> a = [Variable(:a, i, j) for i in 1:2, j in 1:2]\n2×2 Array{Variable,2}:\n a₁₋₁  a₁₋₂\n a₂₋₁  a₂₋₂\n\njulia> sort(vec(a))\n4-element Array{Variable,1}:\n a₁₋₁\n a₂₋₁\n a₁₋₂\n a₂₋₂\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation.ModelKit.@var","page":"ModelKit","title":"HomotopyContinuation.ModelKit.@var","text":"@var variable1 variable2 ...\n\nDeclare variables with the given names and automatically create the variable bindings. The macro supports indexing notation to create Arrays of variables.\n\nExamples\n\njulia> @var a b x[1:2] y[1:2,1:3]\n(a, b, Variable[x₁, x₂], Variable[y₁₋₁ y₁₋₂ y₁₋₃; y₂₋₁ y₂₋₂ y₂₋₃])\n\njulia> a\na\n\njulia> b\nb\n\njulia> x\n2-element Array{Variable,1}:\n x₁\n x₂\n\njulia> y\n2×3 Array{Variable,2}:\n y₁₋₁  y₁₋₂  y₁₋₃\n y₂₋₁  y₂₋₂  y₂₋₃\n\n\n\n\n\n","category":"macro"},{"location":"model_kit/#HomotopyContinuation.ModelKit.@unique_var","page":"ModelKit","title":"HomotopyContinuation.ModelKit.@unique_var","text":"@unique_var variable1 variable2\n\nThis is similar to @var with the only difference that the macro automatically changes the names of the variables to ensure uniqueness. However, the binding is still to the declared name. This is useful to ensure that there are no name collisions.\n\nExamples\n\njulia> @unique_var a b\n(a#591, b#592)\n\njulia> a\na#591\n\njulia> b\nb#592\n\n\n\n\n\n","category":"macro"},{"location":"model_kit/#MultivariatePolynomials.variables-Tuple{Union{String, Symbol},Vararg{Any,N} where N}","page":"ModelKit","title":"MultivariatePolynomials.variables","text":"variables(prefix::Union{Symbol,String}, indices...)\n\nCreate an Array of variables with the given prefix and indices. The expression  @var x[1:3, 1:2] is equivalent to  x = variables(:x, 1:3, 1:2).\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#Methods","page":"ModelKit","title":"Methods","text":"","category":"section"},{"location":"model_kit/","page":"ModelKit","title":"ModelKit","text":"coefficients(f::Expression, vars::AbstractVector{Variable})\ncoeffs_as_dense_poly\ndegree(f::Expression, vars::AbstractVector{Variable})\ndegrees(::AbstractVector{Expression})\ndifferentiate(expr::ModelKit.Basic, vars::AbstractVector{Variable})\ndense_poly\nevaluate(expr::AbstractArray{<:ModelKit.Basic}, args...)\nexpand\nexponents_coefficients\nhorner\nnvariables(::Expression)\nmonomials(vars::AbstractVector{<:Union{Variable,Expression}}, d::Integer)\nsubs(ex::ModelKit.Basic, args...)\nrand_poly\nto_dict\nto_number\nvariables(::Expression)","category":"page"},{"location":"model_kit/#MultivariatePolynomials.coefficients-Tuple{Expression,AbstractArray{Variable,1}}","page":"ModelKit","title":"MultivariatePolynomials.coefficients","text":"coefficients(f::Expression, vars::AbstractVector{Variable}; expanded = false)\n\nReturn all coefficients of the given polynomial f for the given variables vars. If expanded = true then this assumes that the expression f is already expanded, e.g., with expand.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.coeffs_as_dense_poly","page":"ModelKit","title":"HomotopyContinuation.ModelKit.coeffs_as_dense_poly","text":"coeffs_as_dense_poly(f, vars, d; homogeneous = false)\n\nGiven a polynomial f this returns a vector c of coefficients such that subs(dense_poly(vars, d; homogeneous = homogeneous), c) == f.\n\nExample\n\n@var x[1:3]\nf, c = dense_poly(x, 3, coeff_name = :c)\ng = x[1]^3+x[2]^3+x[3]^3-1\ngc = coeffs_as_dense_poly(g, x, 3)\nsubs(f, c => gc) == g\n\ntrue\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#MultivariatePolynomials.degree-Tuple{Expression,AbstractArray{Variable,1}}","page":"ModelKit","title":"MultivariatePolynomials.degree","text":"degree(f::Expression, vars = variables(f); expanded = false)\n\nCompute the degree of the expression f  in vars. Unless expanded is true the expression is first expanded.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.degrees-Tuple{AbstractArray{Expression,1}}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.degrees","text":"degrees(f::AbstractVector{Expression}, vars = variables(f); expanded = false)\n\nCompute the degrees of the expressions f in vars. Unless expanded is true the expressions are first expanded.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#MultivariatePolynomials.differentiate-Tuple{Union{HomotopyContinuation.ModelKit.ExpressionRef, Expression, Variable},AbstractArray{Variable,1}}","page":"ModelKit","title":"MultivariatePolynomials.differentiate","text":"differentiate(expr::Expression, var::Variable, k = 1)\ndifferentiate(expr::AbstractVector{Expression}, var::Variable, k = 1)\n\nCompute the k-th derivative of expr with respect to the given variable var.\n\ndifferentiate(expr::Expression, vars::AbstractVector{Variable})\n\nCompute the partial derivatives of expr with respect to the given variable variables vars. Retuns a Vector containing the partial derivatives.\n\ndifferentiate(exprs::AbstractVector{Expression}, vars::AbstractVector{Variable})\n\nCompute the partial derivatives of exprs with respect to the given variable variables vars. Returns a Matrix where the each row contains the partial derivatives for a given expression.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.dense_poly","page":"ModelKit","title":"HomotopyContinuation.ModelKit.dense_poly","text":"dense_poly(vars::AbstractVector{Variable}, d::Integer;\n           homogeneous = false,\n           coeff_name::Symbol = gensym(:c))\n\nCreate a dense polynomial of degree d in the given variables variables where each coefficient is a parameter. Returns a tuple with the first argument being the polynomial and the second the parameters.\n\njulia> @var x y;\n\njulia> f, c = dense_poly([x, y], 2, coeff_name = :q);\n\njulia> f\n q₆ + x*q₄ + x^2*q₁ + y*q₅ + y^2*q₃ + x*y*q₂\n\njulia> c\n6-element Array{Variable,1}:\n q₁\n q₂\n q₃\n q₄\n q₅\n q₆\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation.ModelKit.evaluate-Tuple{AbstractArray{var\"#s22\",N} where N where var\"#s22\"<:Union{HomotopyContinuation.ModelKit.ExpressionRef, Expression, Variable},Vararg{Any,N} where N}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.evaluate","text":"evaluate(expr::Expression, subs...)\nevaluate(expr::AbstractArray{Expression}, subs...)\n\nEvaluate the given expression.\n\nExample\n\njulia> @var x y;\n\njulia> evaluate(x^2, x => 2)\n4\n\njulia> evaluate(x * y, [x,y] => [2, 3])\n6\n\njulia> evaluate([x^2, x * y], [x,y] => [2, 3])\n2-element Array{Int64,1}:\n 4\n 6\n\n# You can also use the callable syntax\njulia> [x^2, x * y]([x,y] => [2, 3])\n2-element Array{Int64,1}:\n 4\n 6\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.expand","page":"ModelKit","title":"HomotopyContinuation.ModelKit.expand","text":"expand(e::Expression)\n\nExpand a given expression.\n\njulia> @var x y\n(x, y)\n\njulia> expand((x + y) ^ 2)\n2*x*y + x^2 + y^2\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation.ModelKit.exponents_coefficients","page":"ModelKit","title":"HomotopyContinuation.ModelKit.exponents_coefficients","text":"exponents_coefficients(f::Expression, vars::AbstractVector{Variable}; expanded = false)\n\nReturn a matrix M containing the exponents for all occuring terms (one term per column) and a vector c containing the corresponding coefficients. Expands the given expression f unless expanded = true. Throws a PolynomialError if a rational expression is encountered.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation.ModelKit.horner","page":"ModelKit","title":"HomotopyContinuation.ModelKit.horner","text":"horner(f::Expression, vars = variables(f))\n\nRewrite f using a multi-variate horner schema.\n\nExample\n\njulia> @var u v c[1:3]\n(u, v, Variable[c₁, c₂, c₃])\n\njulia> f = c[1] + c[2] * v + c[3] * u^2 * v^2 + c[3]u^3 * v\nc₁ + v*c₂ + u^2*v^2*c₃ + u^3*v*c₃\n\njulia> horner(f)\nc₁ + v*(c₂ + u^3*c₃ + u^2*v*c₃)\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#MultivariatePolynomials.nvariables-Tuple{Expression}","page":"ModelKit","title":"MultivariatePolynomials.nvariables","text":"nvariables(expr::Expression; parameters = Variable[])\nnvariables(exprs::AbstractVector{Expression}; parameters = Variable[])\n\nObtain the number of variables used in the given expression not counting the the ones declared in parameters.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#MultivariatePolynomials.monomials-Tuple{AbstractArray{var\"#s22\",1} where var\"#s22\"<:Union{Expression, Variable},Integer}","page":"ModelKit","title":"MultivariatePolynomials.monomials","text":"monomials(variables::AbstractVector, d::Integer; affine = true)\n\nCreate all monomials of a given degree in the given variables.\n\njulia> @var x y\n(x, y)\n\njulia> monomials([x,y], 2; affine = false)\n3-element Array{Operation,1}:\n x ^ 2\n x * y\n y ^ 2\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#MultivariatePolynomials.subs-Tuple{Union{HomotopyContinuation.ModelKit.ExpressionRef, Expression, Variable},Vararg{Any,N} where N}","page":"ModelKit","title":"MultivariatePolynomials.subs","text":"subs(expr::Expression, subsitutions::Pair...)\nsubs(exprs::AbstractVector{<:Expression}, subsitutions::Pair...)\n\nApply the given substitutions to the given expressions.\n\nExamples\n\n@var x y\n\njulia> subs(x^2, x => y)\ny ^ 2\n\njulia> subs(x * y, [x,y] => [x+2,y+2])\n(x + 2) * (y + 2)\n\njulia> subs([x + y, x^2], x => y + 2, y => x + 2)\n2-element Array{Expression,1}:\n 4 + x + y\n (2 + y)^2\n\n# You can also use the callable syntax\njulia> (x * y)([x,y] => [x+2,y+2])\n (x + 2) * (y + 2)\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.rand_poly","page":"ModelKit","title":"HomotopyContinuation.ModelKit.rand_poly","text":"rand_poly(T = ComplexF64, vars::AbstractVector{Variable}, d::Integer; homogeneous::Bool = false)\n\nCreate a random dense polynomial of degree d in the given variables variables. Each coefficient is sampled independently via randn(T).\n\njulia> @var x y;\n\njulia> rand_poly(Float64, [x, y], 2)\n0.788764085756728 - 0.534507647623108*x - 0.778441366874946*y -\n 0.128891763280247*x*y + 0.878962738754971*x^2 + 0.550480741774464*y^2\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation.ModelKit.to_dict","page":"ModelKit","title":"HomotopyContinuation.ModelKit.to_dict","text":"to_dict(expr::Expression, vars::AbstractVector{Variable})\n\nReturn the coefficients of expr w.r.t. the given variables vars. Assumes that expr is expanded and representing a polynomial. Throws a PolynomialError if a rational expression is encountered.\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#HomotopyContinuation.ModelKit.to_number","page":"ModelKit","title":"HomotopyContinuation.ModelKit.to_number","text":"to_number(x::Expression)\n\nTries to unpack the Expression x to a native number type.\n\n```julia-repl julia> x = to_number(Expression(2)) 2\n\njulia> typeof(x) Int64\n\n\n\n\n\n","category":"function"},{"location":"model_kit/#MultivariatePolynomials.variables-Tuple{Expression}","page":"ModelKit","title":"MultivariatePolynomials.variables","text":"variables(expr::Expression; parameters = Variable[])\nvariables(exprs::AbstractVector{Expression}; parameters = Variable[])\n\nObtain all variables used in the given expression up to the ones declared in parameters.\n\nExample\n\njulia> @var x y a;\njulia> variables(x^2 + y)\n2-element Array{Variable,1}:\n x\n y\n\njulia> variables([x^2 + a, y]; parameters = [a])\n2-element Array{Variable,1}:\n x\n y\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#System","page":"ModelKit","title":"System","text":"","category":"section"},{"location":"model_kit/","page":"ModelKit","title":"ModelKit","text":"System\ndegrees(F::System)\nexpressions(F::System)\noptimize(::System)\nmulti_degrees(::System)\nnparameters(::System)\nnvariables(::System)\nparameters(::System)\nsupport_coefficients(::System)\nvariables(::System)\nvariable_groups(::System)","category":"page"},{"location":"model_kit/#HomotopyContinuation.ModelKit.System","page":"ModelKit","title":"HomotopyContinuation.ModelKit.System","text":"System(exprs::AbstractVector{Expression};\n            variables = variables(exprssion),\n            parameters = Variable[])\n\nCreate a system from the given Expressions exprs. The variables determine also the variable ordering. The parameters argument allows to declare certain Variables as parameters.\n\nSystem(support::AbstractVector{<:AbstractMatrix{<:Integer}},\n       coefficients::AbstractVector{<:AbstractVector};\n       variables,\n       parameters = Variable[])\n\nCreate a system from the given support and coefficients.\n\nExamples\n\njulia> @var x y;\njulia> F = System([x^2, y^2]; variables = [y, x])\nSystem of length 2\n 2 variables: y, x\n\n x^2\n y^2\n\n# Systems are callable.\n# This evaluates F at y=2 and x=3\njulia> F([2, 3])\n2-element Array{Int64,1}:\n 9\n 4\n\nIt is also possible to declare parameters.\n\njulia> @var x y a b;\njulia> F = System([x^2 + a, y^2 + b]; variables = [y, x], parameters = [a, b])\nSystem of length 2\n 2 variables: y, x\n 2 parameters: a, b\n\n a + x^2\n b + y^2\n\njulia> F([2, 3], [5, -2])\n 2-element Array{Int64,1}:\n  14\n   2\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation.ModelKit.degrees-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.degrees","text":"degrees(F::System)\n\nReturn the degrees of the given system.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.expressions-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.expressions","text":"expressions(F::System)\n\nReturns the expressions of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.optimize-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.optimize","text":"optimize(F::System)\n\nOptimize the evaluation cost of the given system F. This applies a multivariate horner schema to the given expressions. See also horner.\n\nExample\n\njulia> f\nSystem of length 4\n 4 variables: z₁, z₂, z₃, z₄\n\n z₁ + z₂ + z₃ + z₄\n z₂*z₁ + z₂*z₃ + z₃*z₄ + z₄*z₁\n z₂*z₃*z₁ + z₂*z₃*z₄ + z₂*z₄*z₁ + z₃*z₄*z₁\n -1 + z₂*z₃*z₄*z₁\n\njulia> optimize(f)\nSystem of length 4\n 4 variables: z₁, z₂, z₃, z₄\n\n z₁ + z₂ + z₃ + z₄\n (z₂ + z₄)*z₁ + (z₂ + z₄)*z₃\n z₁*(z₃*z₄ + (z₃ + z₄)*z₂) + z₂*z₃*z₄\n -1 + z₂*z₃*z₄*z₁\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.multi_degrees-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.multi_degrees","text":"multi_degrees(F::System)\n\nReturn the degrees with respect to the given variable groups.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.nparameters-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.nparameters","text":"nparameters(F::System)\n\nReturns the number of parameters of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#MultivariatePolynomials.nvariables-Tuple{System}","page":"ModelKit","title":"MultivariatePolynomials.nvariables","text":"nvariables(F::System)\n\nReturns the number of variables of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.parameters-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.parameters","text":"parameters(F::System)\n\nReturns the parameters of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.support_coefficients-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.support_coefficients","text":"support_coefficients(F::System)\n\nReturn the support of the system and the corresponding coefficients.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#MultivariatePolynomials.variables-Tuple{System}","page":"ModelKit","title":"MultivariatePolynomials.variables","text":"variables(F::System)\n\nReturns the variables of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.variable_groups-Tuple{System}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.variable_groups","text":"variable_groups(F::System)\n\nReturns the variable groups of the given system F.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#Homotopy","page":"ModelKit","title":"Homotopy","text":"","category":"section"},{"location":"model_kit/","page":"ModelKit","title":"ModelKit","text":"Homotopy\nexpressions(::Homotopy)\nnparameters(::Homotopy)\nnvariables(::Homotopy)\nparameters(::Homotopy)\nvariables(::Homotopy)","category":"page"},{"location":"model_kit/#HomotopyContinuation.ModelKit.Homotopy","page":"ModelKit","title":"HomotopyContinuation.ModelKit.Homotopy","text":"Homotopy(exprs, vars, t, parameters = Variable[])\n\nCreate a homotopy H(vars,t) from the given Expressions exprs where vars are the given variables and t is the dedicated variable parameterizing the family of systems. The parameters argument allows to declare certain Variables as parameters.\n\nExample\n\njulia> @var x y t;\n\njulia> H = Homotopy([x + t, y + 2t], [y, x], t)\nHomotopy in t of length 2\n 2 variables: y, x\n\n t + x\n 2*t + y\n\njulia> H([2, 3], 0)\n2-element Array{Int64,1}:\n 3\n 2\n\n\njulia> H([2, 3], 1)\n2-element Array{Int64,1}:\n 4\n 4\n\nIt is also possible to declare additional variables.\n\njulia> @var x y t a b;\njulia> H = Homotopy([x^2 + t*a, y^2 + t*b], [x, y], t, [a, b])\nHomotopy in t of length 2\n 2 variables: x, y\n 2 parameters: a, b\n\n a*t + x^2\n b*t + y^2\njulia> H([2, 3], 1, [5, 2])\n2-element Array{Int64,1}:\n 9\n 11\n\n\n\n\n\n","category":"type"},{"location":"model_kit/#HomotopyContinuation.ModelKit.expressions-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.expressions","text":"expressions(H::Homotopy)\n\nReturns the expressions of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.nparameters-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.nparameters","text":"nparameters(H::Homotopy)\n\nReturns the number of parameters of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#MultivariatePolynomials.nvariables-Tuple{Homotopy}","page":"ModelKit","title":"MultivariatePolynomials.nvariables","text":"nvariables(H::Homotopy)\n\nReturns the number of variables of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#HomotopyContinuation.ModelKit.parameters-Tuple{Homotopy}","page":"ModelKit","title":"HomotopyContinuation.ModelKit.parameters","text":"parameters(H::Homotopy)\n\nReturns the parameters of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"model_kit/#MultivariatePolynomials.variables-Tuple{Homotopy}","page":"ModelKit","title":"MultivariatePolynomials.variables","text":"variables(H::Homotopy)\n\nReturns the variables of the given homotopy H.\n\n\n\n\n\n","category":"method"},{"location":"certification/#Certification","page":"Certification","title":"Certification","text":"","category":"section"},{"location":"certification/","page":"Certification","title":"Certification","text":"We provide support for certifying non-singular solutions to polynomial systems. The details of the implementation described in the article","category":"page"},{"location":"certification/","page":"Certification","title":"Certification","text":"Breiding, P., Rose, K. and Timme, S. \"Certifying zeros of polynomial systems using interval arithmetic.\" arXiv:2011.05000","category":"page"},{"location":"certification/#Certify","page":"Certification","title":"Certify","text":"","category":"section"},{"location":"certification/","page":"Certification","title":"Certification","text":"certify","category":"page"},{"location":"certification/#HomotopyContinuation.certify","page":"Certification","title":"HomotopyContinuation.certify","text":"certify(F, solutions, [p, certify_cache]; options...)\ncertify(F, result, [p, certify_cache]; options...)\n\nAttempt to certify that the given approximate solutions correspond to true solutions of the polynomial system F(xp). The system F has to be an (affine) square polynomial system. Also attemps to certify for each solutions whether it approximates a real solution. The certification is done using interval arithmetic and the Krawczyk method[Moo77]. Returns a CertificationResult which additionall returns the number of distinct solutions. For more details of the implementation see [BRT20].\n\nOptions\n\nshow_progress = true: If true shows a progress bar of the certification process.\nmax_precision = 256: The maximal accuracy (in bits) that is used in the certification process.\ncompile = false: See the solve documentation.\n\nExample\n\nWe take the first example from our introduction guide.\n\n@var x y\n# define the polynomials\nf₁ = (x^4 + y^4 - 1) * (x^2 + y^2 - 2) + x^5 * y\nf₂ = x^2+2x*y^2 - 2y^2 - 1/2\nF = System([f₁, f₂], variables = [x,y])\nresult = solve(F)\n\nResult with 18 solutions\n========================\n• 18 paths tracked\n• 18 non-singular solutions (4 real)\n• random seed: 0xcaa483cd\n• start_system: :polyhedral\n\nWe see that we obtain 18 solutions and it seems that 4 solutions are real. However, this is based on heuristics. To be absolute certain we can certify the result\n\ncertify(F, result)\n\nCertificationResult\n===================\n• 18 solution candidates given\n• 18 certified solution intervals (4 real, 14 complex)\n• 18 distinct certified solution intervals (4 real, 14 complex)\n\nand see that there are indeed 18 solutions and that they are all distinct.\n\n[Moo77]: Moore, Ramon E. \"A test for existence of solutions to nonlinear systems.\" SIAM Journal on Numerical Analysis 14.4 (1977): 611-615.\n\n[BRT20]: Breiding, P., Rose, K. and Timme, S. \"Certifying zeros of polynomial systems using interval arithmetic.\" arXiv:2011.05000.\n\n\n\n\n\n","category":"function"},{"location":"certification/#CertificationResult","page":"Certification","title":"CertificationResult","text":"","category":"section"},{"location":"certification/","page":"Certification","title":"Certification","text":"The result of certify is a CertificationResult:","category":"page"},{"location":"certification/","page":"Certification","title":"Certification","text":"CertificationResult\ncertificates\ndistinct_certificates\nncertified\nnreal_certified\nncomplex_certified\nndistinct_certified\nndistinct_real_certified\nndistinct_complex_certified\nsave(filename, R::CertificationResult)\nshow_straight_line_program","category":"page"},{"location":"certification/#HomotopyContinuation.CertificationResult","page":"Certification","title":"HomotopyContinuation.CertificationResult","text":"CertificationResult\n\nThe result of certify for multiple solutions. Contains a vector of SolutionCertificate as well as a list of certificates which correspond to the same true solution.\n\n\n\n\n\n","category":"type"},{"location":"certification/#HomotopyContinuation.certificates","page":"Certification","title":"HomotopyContinuation.certificates","text":"certificates(R::CertificationResult)\n\nObtain the stored SolutionCertificates.\n\n\n\n\n\n","category":"function"},{"location":"certification/#HomotopyContinuation.distinct_certificates","page":"Certification","title":"HomotopyContinuation.distinct_certificates","text":"distinct_certificates(R::CertificationResult)\n\nObtain the certificates corresponding to the determined distinct solution intervals.\n\n\n\n\n\n","category":"function"},{"location":"certification/#HomotopyContinuation.ncertified","page":"Certification","title":"HomotopyContinuation.ncertified","text":"ncertified(R::CertificationResult)\n\nReturns the number of certified solutions.\n\n\n\n\n\n","category":"function"},{"location":"certification/#HomotopyContinuation.nreal_certified","page":"Certification","title":"HomotopyContinuation.nreal_certified","text":"nreal_certified(R::CertificationResult)\n\nReturns the number of certified real solutions.\n\n\n\n\n\n","category":"function"},{"location":"certification/#HomotopyContinuation.ncomplex_certified","page":"Certification","title":"HomotopyContinuation.ncomplex_certified","text":"ncomplex_certified(R::CertificationResult)\n\nReturns the number of certified complex solutions.\n\n\n\n\n\n","category":"function"},{"location":"certification/#HomotopyContinuation.ndistinct_certified","page":"Certification","title":"HomotopyContinuation.ndistinct_certified","text":"ndistinct_certified(R::CertificationResult)\n\nReturns the number of distinct certified solutions.\n\n\n\n\n\n","category":"function"},{"location":"certification/#HomotopyContinuation.ndistinct_real_certified","page":"Certification","title":"HomotopyContinuation.ndistinct_real_certified","text":"ndistinct_real_certified(R::CertificationResult)\n\nReturns the number of distinct certified real solutions.\n\n\n\n\n\n","category":"function"},{"location":"certification/#HomotopyContinuation.ndistinct_complex_certified","page":"Certification","title":"HomotopyContinuation.ndistinct_complex_certified","text":"ndistinct_complex_certified(R::CertificationResult)\n\nReturns the number of distinct certified complex solutions.\n\n\n\n\n\n","category":"function"},{"location":"certification/#HomotopyContinuation.save-Tuple{Any,CertificationResult}","page":"Certification","title":"HomotopyContinuation.save","text":"save(filename, C::CertificationResult)\n\nStore a text representation of the certification result C on disk.\n\n\n\n\n\n","category":"method"},{"location":"certification/#HomotopyContinuation.show_straight_line_program","page":"Certification","title":"HomotopyContinuation.show_straight_line_program","text":"show_straight_line_program(R::CertificationResult)\nshow_straight_line_program(io::IO, R::CertificationResult)\n\nPrint a representation of the used straight line program.\n\n\n\n\n\n","category":"function"},{"location":"certification/#SolutionCertificate","page":"Certification","title":"SolutionCertificate","text":"","category":"section"},{"location":"certification/","page":"Certification","title":"Certification","text":"A CertificationResult contains in particular all SolutionCertificates:","category":"page"},{"location":"certification/","page":"Certification","title":"Certification","text":"SolutionCertificate\nis_certified\nis_real(::SolutionCertificate)\nis_complex(::SolutionCertificate)\nis_positive(::SolutionCertificate)\nsolution_candidate\ncertified_solution_interval\ncertified_solution_interval_after_krawczyk\ncertificate_index\nsolution_approximation","category":"page"},{"location":"certification/#HomotopyContinuation.SolutionCertificate","page":"Certification","title":"HomotopyContinuation.SolutionCertificate","text":"SolutionCertificate\n\nResult of certify for a single solution. Contains the initial solutions and if the certification was successfull a vector of complex intervals where the true solution is contained in.\n\n\n\n\n\n","category":"type"},{"location":"certification/#HomotopyContinuation.is_certified","page":"Certification","title":"HomotopyContinuation.is_certified","text":"is_certified(certificate::SolutionCertificate)\n\nReturns true if certificate is a certificate that certified_solution_interval(certificate) contains a unique zero.\n\n\n\n\n\n","category":"function"},{"location":"certification/#HomotopyContinuation.is_real-Tuple{SolutionCertificate}","page":"Certification","title":"HomotopyContinuation.is_real","text":"is_real(certificate::SolutionCertificate)\n\nReturns true if certificate certifies that the certified solution interval contains a true real zero of the system. If false is returned then this does not necessarily mean that the true solution is not real.\n\n\n\n\n\n","category":"method"},{"location":"certification/#HomotopyContinuation.is_complex-Tuple{SolutionCertificate}","page":"Certification","title":"HomotopyContinuation.is_complex","text":"is_complex(certificate::SolutionCertificate)\n\nReturns true if certificate certifies that the certified solution interval contains a true complex zero of the system.\n\n\n\n\n\n","category":"method"},{"location":"certification/#HomotopyContinuation.is_positive-Tuple{SolutionCertificate}","page":"Certification","title":"HomotopyContinuation.is_positive","text":"is_positive(certificate::SolutionCertificate)\n\nReturns true if is_certified(certificate) is true and the unique zero contained in certified_solution_interval(certificate) is real and positive.\n\n\n\n\n\n","category":"method"},{"location":"certification/#HomotopyContinuation.solution_candidate","page":"Certification","title":"HomotopyContinuation.solution_candidate","text":"solution_candidate(certificate::SolutionCertificate)\n\nReturns the given provided solution candidate.\n\n\n\n\n\n","category":"function"},{"location":"certification/#HomotopyContinuation.certified_solution_interval","page":"Certification","title":"HomotopyContinuation.certified_solution_interval","text":"certified_solution_interval(certificate::SolutionCertificate)\n\nReturns an Arblib.AcbMatrix representing a vector of complex intervals where a unique zero of the system is contained in. Returns nothing if is_certified(certificate) is false.\n\n\n\n\n\n","category":"function"},{"location":"certification/#HomotopyContinuation.certified_solution_interval_after_krawczyk","page":"Certification","title":"HomotopyContinuation.certified_solution_interval_after_krawczyk","text":"certified_solution_interval_after_krawczyk(certificate::SolutionCertificate)\n\nReturns an Arblib.AcbMatrix representing a vector of complex intervals where a unique zero of the system is contained in. This is the result of applying the Krawczyk operator to certified_solution_interval(certificate). Returns nothing if is_certified(certificate) is false.\n\n\n\n\n\n","category":"function"},{"location":"certification/#HomotopyContinuation.certificate_index","page":"Certification","title":"HomotopyContinuation.certificate_index","text":"certificate_index(certificate::SolutionCertificate)\n\nReturn the index of the solution certificate. Here the index refers to the index of the provided solution candidates.\n\n\n\n\n\n","category":"function"},{"location":"certification/#HomotopyContinuation.solution_approximation","page":"Certification","title":"HomotopyContinuation.solution_approximation","text":"solution_approximation(certificate::SolutionCertificate)\n\nIf is_certified(certificate) is true this returns the midpoint of the certified_solution_interval of the given certificate as a Vector{ComplexF64}. Returns nothing if is_certified(certificate) is false.\n\n\n\n\n\n","category":"function"},{"location":"solve/#The-solve-function","page":"Solve (finitely many solutions)","title":"The solve function","text":"","category":"section"},{"location":"solve/","page":"Solve (finitely many solutions)","title":"Solve (finitely many solutions)","text":"The solve function is the most convenient way to solve general polynomial systems. For the mathematical background take a look at our introduction guide.","category":"page"},{"location":"solve/","page":"Solve (finitely many solutions)","title":"Solve (finitely many solutions)","text":"solve\nsolver_startsolutions\nSolver","category":"page"},{"location":"solve/#HomotopyContinuation.solve","page":"Solve (finitely many solutions)","title":"HomotopyContinuation.solve","text":"solve(f; options...)\nsolve(f, start_solutions; start_parameters, target_parameters, options...)\nsolve(f, start_solutions; start_subspace, target_subspace, options...)\nsolve(g, f, start_solutions; options...)\nsolve(homotopy, start_solutions; options...)\n\nSolve the given problem. If only a single polynomial system f is given, then all (complex) isolated solutions are computed. If a system f depending on parameters together with start and target parameters is given then a parameter homotopy is performed. If two systems g and f with solutions of g are given then the solutions are tracked during the deformation of g to f. Similarly, for a given homotopy homotopy H(xt) with solutions at t=1 the solutions at t=0 are computed. See the documentation for examples. If the input is a homogeneous polynomial system, solutions on a random affine chart of projective space are computed.\n\nGeneral Options\n\nThe solve routines takes the following options:\n\ncatch_interrupt = true: If this is true, the computation is gracefully stopped and a partial result is returned when the computation is interruped.\ncompile = mixed: If true then a System (resp. Homotopy) is compiled to a straight line program (CompiledSystem resp. CompiledHomotopy) for evaluation. This induces a compilation overhead. If false then the generated program is only interpreted (InterpretedSystem resp. InterpretedHomotopy). This is slower than the compiled version, but does not introduce compilation overhead.\nendgame_options: The options and parameters for the endgame. See EndgameOptions.\nseed: The random seed used during the computations. The seed is also reported in the result. For a given random seed the result is always identical.\nshow_progress= true: Indicate whether a progress bar should be displayed.\nstop_early_cb: Here it is possible to provide a function (or any callable struct) which accepts a PathResult r as input and returns a Bool. If stop_early_cb(r) is true then no further paths are tracked and the computation is finished. This is only called for successfull paths. This is for example useful if you only want to compute one solution of a polynomial system. For this stop_early_cb = _ -> true would be sufficient.\nthreading = true: Enable multi-threading for the computation. The number of available threads is controlled by the environment variable JULIA_NUM_THREADS.\ntracker_options: The options and parameters for the path tracker. See TrackerOptions.\n\nOptions depending on input\n\nIf only a polynomial system is given:\n\nstart_system: Possible values are :total_degree and :polyhedral. Depending on the choice furhter options are possible. See also total_degree and polyhedral.\n\nIf a system f depending on parameters together with start parameters (or start subspace), start solutions and multiple target parameters (or target subspaces) then the following options are also available:\n\nflatten: Flatten the output of transform_result. This is useful for example if  transform_result returns a vector of solutions, and you only want a single vector of  solutions as the result (instead of a vector of vector of solutions).\ntransform_parameters = identity: Transform a parameters values p before passing it to target_parameters = ....\ntransform_result: A function taking two arguments, the result and the parameters p. By default this returns the tuple (result, p).\n\nBasic example\n\njulia> @var x y;\n\njulia> F = System([x^2+y^2+1, 2x+3y-1])\nSystem of length 2\n 2 variables: x, y\n\n 1 + x^2 + y^2\n -1 + 2*x + 3*y\n\njulia> solve(F)\nResult with 2 solutions\n=======================\n• 2 non-singular solutions (0 real)\n• 0 singular solutions (0 real)\n• 2 paths tracked\n• random seed: 0x75a6a462\n• start_system: :polyhedral\n\n\n\n\n\n","category":"function"},{"location":"solve/#HomotopyContinuation.solver_startsolutions","page":"Solve (finitely many solutions)","title":"HomotopyContinuation.solver_startsolutions","text":"solver_startsolutions(args...; kwargs...)\n\nTakes the same input as solve but instead of directly solving the problem returns a Solver struct and the start solutions.\n\nExample\n\nCalling solve(args..; kwargs...) is equivalent to\n\nsolver, starts = solver_startsolutions(args...; kwargs...)\nsolve(solver, starts)\n\n\n\n\n\n","category":"function"},{"location":"solve/#HomotopyContinuation.Solver","page":"Solve (finitely many solutions)","title":"HomotopyContinuation.Solver","text":"Solver(path_tracker; seed = nothing)\n\nA struct containing multiple copies of path_tracker. This contains all pre-allocated data structures to call [solve]. The most convenient way to construct a Solver is via solver_startsolutions.\n\n\n\n\n\n","category":"type"},{"location":"solve/","page":"Solve (finitely many solutions)","title":"Solve (finitely many solutions)","text":"The function paths_to_track allows you to know beforehand how manys the you need to track:","category":"page"},{"location":"solve/","page":"Solve (finitely many solutions)","title":"Solve (finitely many solutions)","text":"paths_to_track","category":"page"},{"location":"solve/#HomotopyContinuation.paths_to_track","page":"Solve (finitely many solutions)","title":"HomotopyContinuation.paths_to_track","text":"paths_to_track(f; optopms..)\n\nReturns the number of paths tracked when calling solve with the given arguments.\n\n\n\n\n\n","category":"function"},{"location":"misc/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"misc/#Storing-solutions-and-parameters","page":"Miscellaneous","title":"Storing solutions and parameters","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"write_solutions\nread_solutions\nwrite_parameters\nread_parameters","category":"page"},{"location":"misc/#HomotopyContinuation.write_solutions","page":"Miscellaneous","title":"HomotopyContinuation.write_solutions","text":"write_solutions(filename, solutions)\n\nStores the as a plain text file onto disk. The storage format is as follows. The first line indicates the number of solutions stored followed by a blank line. Then the solutions are stored where each solution is separated by a blank line. Note that the solutions are always considered as complex numbers. See read_solutions for reading the solution file back.\n\nNote that this is the same file format as used in Bertini.\n\nExample\n\njulia> write_solutions(\"solutions.txt\", [[1, 1], [-1, 2]])\n\nshell> cat solutions.txt\n2\n\n1 0\n1 0\n\n-1 0\n2 0\n\njulia> read_solutions(\"solutions.txt\")\n2-element Array{Array{Complex{Int64},1},1}:\n [1 + 0im, 1 + 0im]\n [-1 + 0im, 2 + 0im]\n\n\n\n\n\n","category":"function"},{"location":"misc/#HomotopyContinuation.read_solutions","page":"Miscellaneous","title":"HomotopyContinuation.read_solutions","text":"read_solutions(filename)\n\nRead the solutions stored with write_solutions.\n\nExample\n\njulia> write_solutions(\"solutions.txt\", [[1, 1], [-1, 2]])\n\njulia> read_solutions(\"solutions.txt\")\n2-element Array{Array{Complex{Int64},1},1}:\n [1 + 0im, 1 + 0im]\n [-1 + 0im, 2 + 0im]\n\n\n\n\n\n","category":"function"},{"location":"misc/#HomotopyContinuation.write_parameters","page":"Miscellaneous","title":"HomotopyContinuation.write_parameters","text":"write_parameters(filename, parameters)\n\nStores the parameters as a plain text file onto disk. The storage format is as follows. The first line indicates the number of parameter values stored followed by a blank line. Then the parameter values are stored.\n\nSee read_parameters\n\nNote that this is the same file format as used in Bertini.\n\nExample\n\njulia> write_parameters(\"parameters.txt\", [2.0, -3.2 + 2im])\n\nshell> cat parameters.txt\n2\n\n2.0 0.0\n-3.2 2.0\n\njulia> read_parameters(\"parameters.txt\")\n2-element Array{Complex{Float64},1}:\n  2.0 + 0.0im\n -3.2 + 2.0im\n\n\n\n\n\n","category":"function"},{"location":"misc/#HomotopyContinuation.read_parameters","page":"Miscellaneous","title":"HomotopyContinuation.read_parameters","text":"read_parameters(filename)\n\nRead the parameters stored with write_parameters.\n\nExample\n\njulia> write_parameters(\"parameters.txt\", [2.0, -3.2 + 2im])\n\njulia> read_parameters(\"parameters.txt\")\n2-element Array{Complex{Float64},1}:\n  2.0 + 0.0im\n -3.2 + 2.0im\n\n\n\n\n\n","category":"function"},{"location":"misc/#Newton's-method","page":"Miscellaneous","title":"Newton's method","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"newton\nNewtonResult\nis_success(::NewtonResult)\nNewtonCache","category":"page"},{"location":"misc/#HomotopyContinuation.newton","page":"Miscellaneous","title":"HomotopyContinuation.newton","text":"newton(\n    F::AbstractSystem,\n    x₀::AbstractVector,\n    p = nothing,\n    norm::AbstractNorm = InfNorm(),\n    cache::NewtonCache = NewtonCache(F);\n    options...\n)\n\nAn implemenetation of a local Newton's method with various options to specify convergence criteria. Returns a NewtonResult. The computations are always performed in complex arithmetic with double precision, i.e., using Complex{Float64}. The optional cache argument pre-allocates the necessary memory. This is useful if the method is called repeatedly.\n\nOptions\n\natol::Float64 = 1e-8: The method is declared converged if norm(xᵢ₊₁ - xᵢ) < atol.\nrtol::Float64 = atol: The method is declared converged if norm(xᵢ₊₁ - xᵢ) < max(atol, rtol * norm(x₀)).\nmax_iters::Int = 20: The maximal number of iterations.\nextended_precision::Bool = false: An optional use of extended precision for the evaluation of F(x). This can increase the achievable accuracy.\ncontraction_factor::Float64 = 1.0: The Newton updates have to satisfy xᵢ₁ - xᵢ  a^2^i-1x₁ - x₀ for i  1 where a is contraction_factor.\nmin_contraction_iters::Int = typemax(Int):  The minimal number of iterations the contraction_factor has to be satisfied. If after min_contraction_iters many iterations the contraction factor is not satisfied the step is accepted anyway.\nmax_abs_norm_first_update::Float64 = Inf: The initial guess x₀ is rejected if norm(x₁ - x₀) >  max_abs_norm_first_update\nmax_rel_norm_first_update::Float64 = max_abs_norm_first_update: The initial guess x₀ is rejected if norm(x₁ - x₀) >  max_rel_norm_first_update * norm(x₀)\n\n\n\n\n\n","category":"function"},{"location":"misc/#HomotopyContinuation.NewtonResult","page":"Miscellaneous","title":"HomotopyContinuation.NewtonResult","text":"NewtonResult\n\nResult returned by newton.\n\nFields\n\nreturn_code::Symbol: Can be :success, :rejected or :max_iters.\nx::Vector{ComplexF64}: The last value obtained.\naccuracy::Float64: Estimate of the absolute distance of x to a true zero.\niters::Int Number of iterations performed.\ncontraction_ratio::Float64: The value |xᵢ - xᵢ₋₁| / |xᵢ₋₁ - xᵢ₋₂|.\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation.is_success-Tuple{NewtonResult}","page":"Miscellaneous","title":"HomotopyContinuation.is_success","text":"is_success(R::NewtonResult)\n\nReturns true if the newton was successfull.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation.NewtonCache","page":"Miscellaneous","title":"HomotopyContinuation.NewtonCache","text":"NewtonCache(F::AbstractSystem; optimize_data_structure = true)\n\nPre-allocates the necessary memory for newton.\n\n\n\n\n\n","category":"type"},{"location":"misc/#Norms","page":"Miscellaneous","title":"Norms","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"AbstractNorm\nInfNorm\nEuclideanNorm\nWeightedNorm\ndistance(u, v, ::AbstractNorm)\nnorm(u, ::AbstractNorm)\ninit!(::WeightedNorm, ::AbstractVector)\nupdate!(::WeightedNorm, ::AbstractVector)","category":"page"},{"location":"misc/#HomotopyContinuation.AbstractNorm","page":"Miscellaneous","title":"HomotopyContinuation.AbstractNorm","text":"AbstractNorm\n\nAn AbstractNorm represents any norm of a vector space. All norms are callable. norm(x) computes the norm of x and norm(x,y) computes the distance norm(x - y).\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation.InfNorm","page":"Miscellaneous","title":"HomotopyContinuation.InfNorm","text":"InfNorm <: AbstractNorm\n\nThe infinity or maximum norm.\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation.EuclideanNorm","page":"Miscellaneous","title":"HomotopyContinuation.EuclideanNorm","text":"EuclideanNorm <: AbstractNorm\n\nThe Euclidean resp. 2-norm.\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation.WeightedNorm","page":"Miscellaneous","title":"HomotopyContinuation.WeightedNorm","text":"WeightedNorm(d::AbstractVector, norm::AbstractNorm; options...)\nWeightedNorm(norm::AbstractNorm, n::Integer; options...)\nWeightedNorm(norm::AbstractNorm, x::AbstractVector; options...)\n\nA WeightedNorm represents a weighted variant of norm norm of a n-dimensional vector space.A norm||x||is weighted by introducing a vector of additional weightsdsuch that the new norm is||D⁻¹x||whereDis the diagonal matrix with diagonald. The WeightedNorm is desigened to change the weights dynamically by using init!(::WeightedNorm, x) and update!(::WeightedNorm, x). The weights are there constructed such that D¹x  10. The weights can be accessed and changed by indexing.\n\nOptions\n\nscale_min = sqrt(eps()): The minimal size of dᵢ is scale_min time the (weighted) norm of x.\nscale_abs_min = min(scale_min^2, 200 * sqrt(eps())): The absolute minimal size of dᵢ.\nscale_max = 1.0 / eps() / sqrt(2): The absolute maximal size of dᵢ\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation.distance-Tuple{Any,Any,AbstractNorm}","page":"Miscellaneous","title":"HomotopyContinuation.distance","text":"distance(u, v, norm::AbstractNorm)\n\nCompute the distance ||u-v|| with respect to the given norm norm.\n\n\n\n\n\n","category":"method"},{"location":"misc/#LinearAlgebra.norm-Tuple{Any,AbstractNorm}","page":"Miscellaneous","title":"LinearAlgebra.norm","text":"norm(u, norm::AbstractNorm)\n\nCompute the norm ||u|| with respect to the given norm norm.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation.init!-Tuple{WeightedNorm,AbstractArray{T,1} where T}","page":"Miscellaneous","title":"HomotopyContinuation.init!","text":"init!(w::WeightedNorm, x::AbstractVector)\n\nSetup the weighted norm w for x.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation.update!-Tuple{WeightedNorm,AbstractArray{T,1} where T}","page":"Miscellaneous","title":"HomotopyContinuation.update!","text":"update!(w::WeightedNorm, x)\n\nUpdate the weighted norm w for x, this will interpolate between the previous weights and the norm of x.\n\n\n\n\n\n","category":"method"},{"location":"misc/#Unique-points,-group-actions-and-multiplicities","page":"Miscellaneous","title":"Unique points, group actions and multiplicities","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"UniquePoints\nsearch_in_radius(::UniquePoints, v, tol::Real)\nadd!(UP::UniquePoints{T,Id,M,GA}, v, id::Id, tol::Real) where {T,Id,M,GA}\nmultiplicities\nunique_points","category":"page"},{"location":"misc/#HomotopyContinuation.UniquePoints","page":"Miscellaneous","title":"HomotopyContinuation.UniquePoints","text":"UniquePoints{T, Id, M}\n\nA data structure for assessing quickly whether a point is close to an indexed point as determined by the given distances function M. The distance function has to be a metric. The indexed points are only stored by their identifiers Id.\n\nUniquePoints(v::AbstractVector{T}, id::Id;\n                metric = EuclideanNorm(),\n                group_actions = nothing)\n\nInitialize the data structure. This does not initialize the data structure with the point.\n\nExample\n\nx = randn(ComplexF64, 4)\npermutation(x) = ([x[2]; x[1]; x[3]; x[4]],)\ngroup_actions = GroupActions(permutation)\nX = group_actions(x)\n\n# without group actions\nunique_points = UniquePoints(x, 1)\nHC.add!.(unique_points, X, 1:length(X), 1e-5)\nlength(unique_points) # 2\n\nunique_points = UniquePoints(x, 1, group_actions = group_actions)\nHC.add!.(unique_points, X, 1:length(X), 1e-5)\nlength(unique_points) # 1\n\n\n\n\n\n","category":"type"},{"location":"misc/#HomotopyContinuation.search_in_radius-Tuple{UniquePoints,Any,Real}","page":"Miscellaneous","title":"HomotopyContinuation.search_in_radius","text":"search_in_radius(unique_points, v, tol)\n\nSearch whether unique_points contains a point p with distances at most tol from v. Returns nothing if no point exists, otherwise the identifier of p is returned.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation.add!-Union{Tuple{GA}, Tuple{M}, Tuple{Id}, Tuple{T}, Tuple{UniquePoints{T,Id,M,GA},Any,Id,Real}} where GA where M where Id where T","page":"Miscellaneous","title":"HomotopyContinuation.add!","text":"add!(unique_points, v, id; atol = 1e-14, rtol = sqrt(eps()))\nadd!(unique_points, v, id, atol)\n\nSearch whether unique_points contains a point p with distances at most max(atol, norm(v)rtol) from v. If this is the case the identifier of p and false is returned. Otherwise (id, true) is returned.\n\n\n\n\n\n","category":"method"},{"location":"misc/#HomotopyContinuation.multiplicities","page":"Miscellaneous","title":"HomotopyContinuation.multiplicities","text":"multiplicities(vectors; metric = EuclideanNorm(), atol = 1e-14, rtol = 1e-8, kwargs...)\n\nReturns a Vector{Vector{Int}} v. Each vector w in 'v' contains all indices i,j such that w[i] and w[j] have distance at most max(atol, rtol * metric(0,w[i])). The remaining kwargs are things that can be passed to UniquePoints.\n\njulia> multiplicities([[1,0.5], [1,0.5], [1,1]])\n[[1,2]]\n\nThis is the same as\n\nmultiplicities([[1,0.5], [1,0.5], [1,1]]; distance=(x,y) -> LinearAlgebra.norm(x-y))\n\nHere is an example for using group actions.\n\njulia> X = [[1, 2, 3, 4], [2,1,3,4], [1,2,4,3], [2,1,4,3]]\njulia> permutation(x) = [x[2], x[1], x[3], x[4]]\njulia> m = multiplicities(X, group_action = permutation)\n[[1,2], [3,4]]\n\n\n\n\n\n","category":"function"},{"location":"misc/#HomotopyContinuation.unique_points","page":"Miscellaneous","title":"HomotopyContinuation.unique_points","text":"unique_points(vectors; metric = EuclideanNorm(), atol = 1e-14, rtol = 1e-8, kwargs...)\n\nReturns all elements in vector for which two elements have distance at most max(atol, rtol * metric(0,w[i])). Note that the output can depend on the order of elements in vectors. The remaining kwargs are things that can be passed to UniquePoints.\n\n\n\n\n\n","category":"function"},{"location":"misc/#Debugging","page":"Miscellaneous","title":"Debugging","text":"","category":"section"},{"location":"misc/","page":"Miscellaneous","title":"Miscellaneous","text":"path_info","category":"page"},{"location":"misc/#HomotopyContinuation.path_info","page":"Miscellaneous","title":"HomotopyContinuation.path_info","text":"path_info(tracker::Tracker, x₀, t₁ = 1.0, t₀ = 0.0; debug::Bool = false, kwargs...)\n\nTrack a path using the given tracker and start value x₀. This returns a struct containing detailed information about the tracked path.\n\n\n\n\n\n","category":"function"},{"location":"tracker/#Tracker","page":"Tracker","title":"Tracker","text":"","category":"section"},{"location":"tracker/","page":"Tracker","title":"Tracker","text":"Tracker is a data structure to track for a given AbstractHomotopy H(xt) a solution x from t₁  ℂ to t₀  ℂ, i.e.,  H(xt₁) = 0 and x with H(xt₀) = 0 is returned. This is done by following an implicitly defined smooth path x(t) using a predictor-corrector scheme. In particular, it is assumed that for all t on the line segment between t₁ and t₀ the Jacobian H_x(x(t)t) has full column-rank. The algorithm uses as an predictor a Padé approximant of order (2,1) and as a corrector Newton's method. The details of the algorithm are described in the article [Tim20].","category":"page"},{"location":"tracker/#Constructor-and-Options","page":"Tracker","title":"Constructor and Options","text":"","category":"section"},{"location":"tracker/","page":"Tracker","title":"Tracker","text":"Tracker\nTrackerOptions\nTrackerParameters\nDEFAULT_TRACKER_PARAMETERS\nCONSERVATIVE_TRACKER_PARAMETERS\nFAST_TRACKER_PARAMETERS","category":"page"},{"location":"tracker/#HomotopyContinuation.Tracker","page":"Tracker","title":"HomotopyContinuation.Tracker","text":"Tracker(H::AbstractHomotopy;\n        options = TrackerOptions(),\n        weighted_norm_options = WeightedNormOptions())\n\nConstruct a tracker for the given homotopy H. The algorithm computes along the path x(t) the local derivatives up to order 4. For options see also TrackerOptions. The algorithm uses as a weighted infinity norm to measure distances. See also WeightedNorm.\n\n[Tim20]: Timme, S. \"Mixed Precision Path Tracking for Polynomial Homotopy Continuation\". arXiv:1902.02968 (2020)\n\nExample\n\nWe want to solve the system\n\n@var x y t\nF = System([x^2 + y^2 - 3, 2x^2 + 0.5x*y + 3y^2 - 2])\n\nusing a total degree homotopy and Tracker.\n\n# construct start system and homotopy\nG = System(im * [x^2 - 1, y^2 - 1])\nH = StraightLineHomotopy(G, F)\nstart_solutions = [[1,1], [-1,1], [1,-1], [-1,-1]]\n# construct tracker\ntracker = Tracker(H)\n# track each start solution separetely\nresults = track.(tracker, start_solutions)\nprintln(\"# successfull: \", count(is_success, results))\n\nWe see that we tracked all 4 paths successfully.\n\n# successfull: 4\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation.TrackerOptions","page":"Tracker","title":"HomotopyContinuation.TrackerOptions","text":"TrackerOptions(; options...)\n\nThe set of options for a Tracker.\n\nOptions\n\nautomatic_differentiation = 1: The value automatic_differentiation determines up to which order the derivative is computed using automatic differentiation. Otherwise numerical differentiation is used. The automatic differentiation results in additional compilation time, however for numerically challenging paths it is strongly recommended to use automatic_differentiation = 3.\nmax_steps = 10_000: The maximal number of steps a tracker attempts\nmax_step_size = Inf: The maximal size of a step\nmax_initial_step_size = Inf: The maximal size of the first step\nmin_step_size = 1e-48: The minimal step size. If a smaller step size would be necessary, then the tracking gets terminated.\nextended_precision = true: Whether to allow for the use of extended precision, if necessary, in some computations. This can greatly improve the ability to track numerically difficult paths.\nterminate_cond = 1e13: If the relative component-wise condition number cond(H_x, ẋ) is larger than terminate_cond then the path is terminated as too ill-conditioned.\nparameters::Union{Symbol,TrackerParameters} = :default Set the TrackerParameters to control the performance of the path tracking algorithm. The values :default, :conservative and :fast are shorthands for using DEFAULT_TRACKER_PARAMETERS, CONSERVATIVE_TRACKER_PARAMETERS resp. FAST_TRACKER_PARAMETERS.\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation.TrackerParameters","page":"Tracker","title":"HomotopyContinuation.TrackerParameters","text":"TrackerParameters\n\nParameters that control the performance and robustness characteristics of the path tracking algorithm. See [Tim20] for an explanation and derivation of the parameters. We provide three sets of parameters for common use cases:\n\nDEFAULT_TRACKER_PARAMETERS\nFAST_TRACKER_PARAMETERS\nCONSERVATIVE_TRACKER_PARAMETERS\n\n[Tim20]: Timme, S. \"Mixed Precision Path Tracking for Polynomial Homotopy Continuation\". arXiv:1902.02968 (2020)\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation.DEFAULT_TRACKER_PARAMETERS","page":"Tracker","title":"HomotopyContinuation.DEFAULT_TRACKER_PARAMETERS","text":"The default TrackerParameters which have a good balance between robustness and efficiency.\n\n\n\n\n\n","category":"constant"},{"location":"tracker/#HomotopyContinuation.CONSERVATIVE_TRACKER_PARAMETERS","page":"Tracker","title":"HomotopyContinuation.CONSERVATIVE_TRACKER_PARAMETERS","text":"TrackerParameters which trade robustness against some speed.\n\n\n\n\n\n","category":"constant"},{"location":"tracker/#HomotopyContinuation.FAST_TRACKER_PARAMETERS","page":"Tracker","title":"HomotopyContinuation.FAST_TRACKER_PARAMETERS","text":"TrackerParameters which trade speed against a higher chance of path jumping.\n\n\n\n\n\n","category":"constant"},{"location":"tracker/#Tracking","page":"Tracker","title":"Tracking","text":"","category":"section"},{"location":"tracker/","page":"Tracker","title":"Tracker","text":"track(tracker::Tracker, x₁::AbstractVector, t₁::Number, t₀::Number)","category":"page"},{"location":"tracker/#HomotopyContinuation.track-Tuple{Tracker,AbstractArray{T,1} where T,Number,Number}","page":"Tracker","title":"HomotopyContinuation.track","text":" track(tracker::Tracker, x::AbstractVector, t₁ = 1.0, t₀ = 0.0; debug::Bool = false)\n\nTrack the given solution x at t₁ using tracker to a solution at t₀.\n\ntrack(tracker::Tracker, r::TrackerResult, t₁ = 1.0, t₀ = 0.0; debug::Bool = false)\n\nTrack the solution of the result r from t₁ to t₀.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#Result","page":"Tracker","title":"Result","text":"","category":"section"},{"location":"tracker/","page":"Tracker","title":"Tracker","text":"TrackerResult\nsolution(::TrackerResult)\nis_success(::TrackerResult)\nis_invalid_startvalue(::TrackerResult)\nsteps(::TrackerResult)\naccepted_steps(::TrackerResult)\nrejected_steps(::TrackerResult)","category":"page"},{"location":"tracker/#HomotopyContinuation.TrackerResult","page":"Tracker","title":"HomotopyContinuation.TrackerResult","text":"TrackerResult\n\nContaining the result of tracking a path with a Tracker.\n\nFields\n\nreturn_code::Symbol: A code indicating whether the tracking was successfull (:success). See TrackerCode for all possible values.\nsolution::V: The solution when the tracking stopped.\nt::ComplexF64: The value of t when the tracking stopped.\naccuracy::Float64: Estimate of the relative accuracy of the solution.\naccepted_steps::Int: Number of steps that got accepted.\nrejected_steps::Int: Number of steps that got rejected.\nextended_precision::Bool: Indicate whether extended precision is necessary to achieve the accuracy of the solution.\nextended_precision_used::Bool: This is true if during the tracking at any point extended precision was used.\n\n\n\n\n\n","category":"type"},{"location":"tracker/#HomotopyContinuation.solution-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation.solution","text":"solution(result::TrackerResult)\n\nReturns the solutions obtained by the Tracker.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.is_success-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation.is_success","text":"is_success(result::TrackerResult)\n\nReturns true if the path tracking was successfull.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.is_invalid_startvalue-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation.is_invalid_startvalue","text":"is_invalid_startvalue(result::TrackerResult)\n\nReturns true if the path tracking failed since the start value was invalid.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.steps-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation.steps","text":"steps(result::TrackerResult)\n\nReturns the number of steps done.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.accepted_steps-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation.accepted_steps","text":"accepted_steps(result::TrackerResult)\n\nReturns the number of accepted steps.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.rejected_steps-Tuple{TrackerResult}","page":"Tracker","title":"HomotopyContinuation.rejected_steps","text":"rejected_steps(result::TrackerResult)\n\nReturns the number of rejected_steps steps.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#Low-level-API","page":"Tracker","title":"Low-level API","text":"","category":"section"},{"location":"tracker/","page":"Tracker","title":"Tracker","text":"track!(tracker::Tracker, x₁::AbstractVector, t₁::Number, t₀::Number)\ninit!(tracker::Tracker, ::TrackerResult, ::Number, ::Number)\nTrackerCode\nis_success(::TrackerCode.codes)\nis_tracking(::TrackerCode.codes)\nis_invalid_startvalue(::TrackerCode.codes)\nis_terminated(::TrackerCode.codes)\n","category":"page"},{"location":"tracker/#HomotopyContinuation.track!-Tuple{Tracker,AbstractArray{T,1} where T,Number,Number}","page":"Tracker","title":"HomotopyContinuation.track!","text":"track!(tracker::Tracker, x, t₁ = 1.0, t₀ = 0.0; debug::Bool = false)\n\nThe same as track but only returns the final TrackerCode.\n\ntrack!(tracker::Tracker, t₀; debug::Bool = false)\n\nTrack with tracker the current solution to t₀. This keeps the current state.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.init!-Tuple{Tracker,TrackerResult,Number,Number}","page":"Tracker","title":"HomotopyContinuation.init!","text":"init!(tracker::Tracker, x₁, t₁, t₀)\n\nSetup tracker to track x₁ from t₁ to t₀.\n\ninit!(tracker::Tracker, t₀)\n\nSetup tracker to continue tracking the current solution to t₀. This keeps the current state.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.TrackerCode","page":"Tracker","title":"HomotopyContinuation.TrackerCode","text":"TrackerCode\n\nThe possible states a CoreTracker can have are of type TrackerCode.codes and can be\n\nTrackerCode.success: Indicates a successfull tracking.\nTrackerCode.tracking: The tracking is still in progress.\nTrackerCode.terminated_accuracy_limit: Tracking terminaed since the accuracy was insufficient.\nTrackerCode.terminated_invalid_startvalue: Tracking terminated since the provided start value was invalid.\nTrackerCode.terminated_ill_conditioned: Tracking terminated since the path was too ill-conditioned.\nTrackerCode.terminated_max_steps: Tracking terminated since maximal number of steps is reached.\nTrackerCode.terminated_step_size_too_small: Trackint terminated since the step size was too small.\nTrackerCode.terminated_unknown: An unintended error occured. Please consider reporting an issue.\n\n\n\n\n\n","category":"module"},{"location":"tracker/#HomotopyContinuation.is_success-Tuple{HomotopyContinuation.TrackerCode.codes}","page":"Tracker","title":"HomotopyContinuation.is_success","text":"is_success(code::TrackerCode.codes)\n\nReturns true if code indicates a success in the path tracking.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.is_tracking-Tuple{HomotopyContinuation.TrackerCode.codes}","page":"Tracker","title":"HomotopyContinuation.is_tracking","text":"is_tracking(code::TrackerCode.codes)\n\nReturns true if code indicates that the path tracking is not yet finished.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.is_invalid_startvalue-Tuple{HomotopyContinuation.TrackerCode.codes}","page":"Tracker","title":"HomotopyContinuation.is_invalid_startvalue","text":"is_invalid_startvalue(code::TrackerCode.codes)\n\nReturns true if code indicates that the path tracking got terminated since the start value was not a zero.\n\n\n\n\n\n","category":"method"},{"location":"tracker/#HomotopyContinuation.is_terminated-Tuple{HomotopyContinuation.TrackerCode.codes}","page":"Tracker","title":"HomotopyContinuation.is_terminated","text":"is_terminated(code::TrackerCode.codes)\n\nReturns true if code indicates that the path tracking got terminated.\n\n\n\n\n\n","category":"method"},{"location":"witness_sets/#Witness-Sets","page":"Witness Sets (infinitely many solutions)","title":"Witness Sets","text":"","category":"section"},{"location":"witness_sets/","page":"Witness Sets (infinitely many solutions)","title":"Witness Sets (infinitely many solutions)","text":"A WitnessSet W is the basic data structure to work with positive dimensional solution sets V(F) of a polynomial system F. The general idea is to intersect V(F) with an (affine) linear space L such that the intersection V(F)  L consists of only finitely many points (witnesses). Over the complex numbers the number of points is independent of the linear space L and called the degree of V(F).","category":"page"},{"location":"witness_sets/","page":"Witness Sets (infinitely many solutions)","title":"Witness Sets (infinitely many solutions)","text":"WitnessSet","category":"page"},{"location":"witness_sets/#HomotopyContinuation.WitnessSet","page":"Witness Sets (infinitely many solutions)","title":"HomotopyContinuation.WitnessSet","text":"WitnessSet(F, L, S)\n\nStore solutions S of the polynomial system F(x) = L(x) = 0 into a witness set.\n\n\n\n\n\n","category":"type"},{"location":"witness_sets/","page":"Witness Sets (infinitely many solutions)","title":"Witness Sets (infinitely many solutions)","text":"To compute a WitnessSet call witness_set.","category":"page"},{"location":"witness_sets/","page":"Witness Sets (infinitely many solutions)","title":"Witness Sets (infinitely many solutions)","text":"witness_set","category":"page"},{"location":"witness_sets/#HomotopyContinuation.witness_set","page":"Witness Sets (infinitely many solutions)","title":"HomotopyContinuation.witness_set","text":"witness_set(F; codim = nvariables(F) - length(F), dim = nothing, options...)\n\nCompute a WitnessSet for F in the given dimension (resp. codimension) by sampling a random (affine) linear subspace. After constructing the system this calls solve with the provided options.\n\nwitness_set(F, L; options...)\n\nCompute WitnessSet for F and the (affine) linear subspace L.\n\nwitness_set(W::WitnessSet, L; options...)\n\nCompute a new WitnessSet with the (affine) linear subspace L by moving the linear subspace stored in W to L.\n\nExample\n\njulia> @var x y;\njulia> F = System([x^2 + y^2 - 5], [x, y])\nSystem of length 1\n 2 variables: x, y\n\n -5 + x^2 + y^2\n\njulia> W = witness_set(F)\nWitness set for dimension 1 of degree 2\n\n\n\n\n\n","category":"function"},{"location":"witness_sets/","page":"Witness Sets (infinitely many solutions)","title":"Witness Sets (infinitely many solutions)","text":"To obtain information about a WitnessSet the following functions are provided.","category":"page"},{"location":"witness_sets/","page":"Witness Sets (infinitely many solutions)","title":"Witness Sets (infinitely many solutions)","text":"solutions(::WitnessSet)\nresults(W::WitnessSet{<:Any,<:Any,PathResult})\nsystem\nlinear_subspace\ndim(::WitnessSet)\ncodim(::WitnessSet)\nModelKit.degree(::WitnessSet)","category":"page"},{"location":"witness_sets/#HomotopyContinuation.solutions-Tuple{WitnessSet}","page":"Witness Sets (infinitely many solutions)","title":"HomotopyContinuation.solutions","text":"solutions(W::WitnessSet)\n\nGet the solutions stored in W.\n\n\n\n\n\n","category":"method"},{"location":"witness_sets/#HomotopyContinuation.results-Tuple{WitnessSet{var\"#s22\",var\"#s21\",PathResult} where var\"#s21\" where var\"#s22\"}","page":"Witness Sets (infinitely many solutions)","title":"HomotopyContinuation.results","text":"results(W::WitnessSet)\n\nGet the results stored in W.\n\n\n\n\n\n","category":"method"},{"location":"witness_sets/#HomotopyContinuation.system","page":"Witness Sets (infinitely many solutions)","title":"HomotopyContinuation.system","text":"system(W::WitnessSet)\n\nGet the system stored in W.\n\n\n\n\n\n","category":"function"},{"location":"witness_sets/#HomotopyContinuation.linear_subspace","page":"Witness Sets (infinitely many solutions)","title":"HomotopyContinuation.linear_subspace","text":"linear_subspace(W::WitnessSet)\n\nGet the linear subspace stored in W.\n\n\n\n\n\n","category":"function"},{"location":"witness_sets/#HomotopyContinuation.dim-Tuple{WitnessSet}","page":"Witness Sets (infinitely many solutions)","title":"HomotopyContinuation.dim","text":"dim(W::WitnessSet)\n\nThe dimension of the algebraic set encoded by the witness set.\n\n\n\n\n\n","category":"method"},{"location":"witness_sets/#HomotopyContinuation.codim-Tuple{WitnessSet}","page":"Witness Sets (infinitely many solutions)","title":"HomotopyContinuation.codim","text":"codim(W::WitnessSet)\n\nThe dimension of the algebraic set encoded by the witness set.\n\n\n\n\n\n","category":"method"},{"location":"witness_sets/#MultivariatePolynomials.degree-Tuple{WitnessSet}","page":"Witness Sets (infinitely many solutions)","title":"MultivariatePolynomials.degree","text":"degree(W::WitnessSet)\n\nReturns the degree of the witness set W. This equals the number of solutions stored.\n\n\n\n\n\n","category":"method"},{"location":"witness_sets/","page":"Witness Sets (infinitely many solutions)","title":"Witness Sets (infinitely many solutions)","text":"To test for completeness of a WitnessSet you can perform a trace_test","category":"page"},{"location":"witness_sets/","page":"Witness Sets (infinitely many solutions)","title":"Witness Sets (infinitely many solutions)","text":"trace_test","category":"page"},{"location":"witness_sets/#HomotopyContinuation.trace_test","page":"Witness Sets (infinitely many solutions)","title":"HomotopyContinuation.trace_test","text":"trace_test(W::WitnessSet; options...)\n\nPerforms a trace test [LRS18] to verify whether the given witness set W is complete. Returns the trace of the witness set which should be theoretically be 0 if W is complete. Due to floating point arithmetic this is not the case, thus is has to be manually checked that the trace is sufficiently small. Returns nothing if the trace test failed due to path tracking failures. The options are the same as for calls to witness_set.\n\njulia> @var x y;\njulia> F = System([x^2 + y^2 - 5], [x, y])\nSystem of length 1\n 2 variables: x, y\n\n -5 + x^2 + y^2\n\njulia> W = witness_set(F)\nWitness set for dimension 1 of degree 2\n\njulia> trace = trace_test(W)\n9.981960497718987e-16\n\n[LRS18]: Leykin, Anton, Jose Israel Rodriguez, and Frank Sottile. \"Trace test.\" Arnold Mathematical Journal 4.1 (2018): 113-125.\n\nAPA\n\n\n\n\n\n","category":"function"},{"location":"linear_subspaces/#Linear-Subspaces","page":"Linear Subspaces","title":"Linear Subspaces","text":"","category":"section"},{"location":"linear_subspaces/","page":"Linear Subspaces","title":"Linear Subspaces","text":"We provide built-in data structures to work with (affine) linear subspaces L where L can be represented in either extrinsic coordinates x with L =  x  Ax = b  or in intrinsic coordinates u with L =  Bu+p  u .","category":"page"},{"location":"linear_subspaces/#Coordinates","page":"Linear Subspaces","title":"Coordinates","text":"","category":"section"},{"location":"linear_subspaces/","page":"Linear Subspaces","title":"Linear Subspaces","text":"To specify which coordinates are given / expected the following can be used:","category":"page"},{"location":"linear_subspaces/","page":"Linear Subspaces","title":"Linear Subspaces","text":"Coordinates\nIntrinsic\nExtrinsic","category":"page"},{"location":"linear_subspaces/#HomotopyContinuation.Coordinates","page":"Linear Subspaces","title":"HomotopyContinuation.Coordinates","text":"Coordinates\n\nA type used for encoding the used coordinates and for performing coordinate changes.\n\nCurrently supported coordinates are:\n\nIntrinsic\nExtrinsic\n\n\n\n\n\n","category":"type"},{"location":"linear_subspaces/#HomotopyContinuation.Intrinsic","page":"Linear Subspaces","title":"HomotopyContinuation.Intrinsic","text":"Intrinsic <: Coordinates\n\nIndicates the use of the intrinsic description of an (affine) linear subspace. See also IntrinsicDescription.\n\n\n\n\n\n","category":"constant"},{"location":"linear_subspaces/#HomotopyContinuation.Extrinsic","page":"Linear Subspaces","title":"HomotopyContinuation.Extrinsic","text":"Extrinsic <: Coordinates\n\nIndicates the use of the extrinsic description of an (affine) linear subspace. See also ExtrinsicDescription.\n\n\n\n\n\n","category":"constant"},{"location":"linear_subspaces/#Constructors","page":"Linear Subspaces","title":"Constructors","text":"","category":"section"},{"location":"linear_subspaces/","page":"Linear Subspaces","title":"Linear Subspaces","text":"LinearSubspace\nExtrinsicDescription\nIntrinsicDescription","category":"page"},{"location":"linear_subspaces/#HomotopyContinuation.LinearSubspace","page":"Linear Subspaces","title":"HomotopyContinuation.LinearSubspace","text":"LinearSubspace(A, b)\n\nAn m-dimensional (affine) linear subspace L in n-dimensional space given by the extrinsic description L =  x  A x = b .\n\njulia> A = LinearSubspace([1 0 3; 2 1 3], [5, -2])\n1-dim. (affine) linear subspace {x|Ax=b} with eltype Float64:\nA:\n2×3 Array{Float64,2}:\n 1.0  0.0  3.0\n 2.0  1.0  3.0\nb:\n2-element Array{Float64,1}:\n  5.0\n -2.0\n\njulia> dim(A)\n1\n\njulia> codim(A)\n2\n\njulia> ambient_dim(A)\n3\n\nA LinearSubspace holds always its extrinsic description, see also ExtrinsicDescription, as well as its intrinsic description, see IntrinsicDescription.\n\njulia> intrinsic(A)\nIntrinsicDescription{Float64}:\nA:\n3×1 Array{Float64,2}:\n -0.6882472016116853\n  0.6882472016116853\n  0.22941573387056186\nb₀:\n3-element Array{Float64,1}:\n -3.0526315789473677\n -3.947368421052632\n  2.684210526315789\n\nA LinearSubspace can be evaluated with either using Intrinsic or Extrinsic coordinates.\n\njulia> u = [0.5]\n1-element Array{Float64,1}:\n 0.5\n\njulia> x = A(u, Intrinsic)\n3-element Array{Float64,1}:\n -3.3967551797532103\n -3.6032448202467893\n  2.79891839325107\n\njulia> A(x, Extrinsic)\n  2-element Array{Float64,1}:\n   0.0\n   0.0\n\nTo change the used coordinates you can use coord_change.\n\njulia> coord_change(A, Extrinsic, Intrinsic, x)\n1-element Array{Float64,1}:\n 0.49999999999999994\n\n\n\n\n\n","category":"type"},{"location":"linear_subspaces/#HomotopyContinuation.ExtrinsicDescription","page":"Linear Subspaces","title":"HomotopyContinuation.ExtrinsicDescription","text":"ExtrinsicDescription(A, b)\n\nExtrinsic description of an m-dimensional (affine) linear subspace L in n-dimensional space. That is L =  x  A x = b . Note that internally A and b will be stored such that the rows of A are orthonormal.\n\n\n\n\n\n","category":"type"},{"location":"linear_subspaces/#HomotopyContinuation.IntrinsicDescription","page":"Linear Subspaces","title":"HomotopyContinuation.IntrinsicDescription","text":"IntrinsicDescription(A, b₀)\n\nIntrinsic description of an m-dimensional (affine) linear subspace L in n-dimensional space. That is L =  u  A u + b₀ . Here, A and b₀ are in orthogonal coordinates. That is, the columns of A are orthonormal and A b₀ = 0.\n\n\n\n\n\n","category":"type"},{"location":"linear_subspaces/#Functions","page":"Linear Subspaces","title":"Functions","text":"","category":"section"},{"location":"linear_subspaces/","page":"Linear Subspaces","title":"Linear Subspaces","text":"ambient_dim\ncodim\ncoord_change\ndim\nintrinsic\nis_linear\nextrinsic\ngeodesic\ngeodesic_distance\nrand_subspace\ntranslate","category":"page"},{"location":"linear_subspaces/#HomotopyContinuation.ambient_dim","page":"Linear Subspaces","title":"HomotopyContinuation.ambient_dim","text":"ambient_dim(A::LinearSubspace)\n\nDimension of ambient space of the (affine) linear subspace A.\n\n\n\n\n\n","category":"function"},{"location":"linear_subspaces/#HomotopyContinuation.codim","page":"Linear Subspaces","title":"HomotopyContinuation.codim","text":"codim(A::ExtrinsicDescription)\n\nCodimension of the (affine) linear subspace A.\n\n\n\n\n\ncodim(A::IntrinsicDescription)\n\nCodimension of the (affine) linear subspace A.\n\n\n\n\n\ncodim(A::LinearSubspace)\n\nCodimension of the (affine) linear subspace A.\n\n\n\n\n\ncodim(W::WitnessSet)\n\nThe dimension of the algebraic set encoded by the witness set.\n\n\n\n\n\n","category":"function"},{"location":"linear_subspaces/#HomotopyContinuation.coord_change","page":"Linear Subspaces","title":"HomotopyContinuation.coord_change","text":"coord_change(A::LinearSubspace, C₁::Coordinates, C₂::Coordinates, p)\n\nGiven an (affine) linear subspace A and a point p in coordinates C₁ compute the point x describing p in coordinates C₂.\n\nExample\n\njulia> A = LinearSubspace([1 0 3; 2 1 3], [5, -2]);\n\njulia> u = [1.25];\n\njulia> x = coord_change(A, Intrinsic, Extrinsic, u)\n3-element Array{Float64,1}:\n -3.9129405809619744\n -3.087059419038025\n  2.9709801936539915\n\njulia> A(x, Extrinsic)\n2-element Array{Float64,1}:\n 0.0\n 0.0\n\njulia> x - A(u, Intrinsic)\n3-element Array{Float64,1}:\n 0.0\n 0.0\n 0.0\n\n\n\n\n\n","category":"function"},{"location":"linear_subspaces/#HomotopyContinuation.dim","page":"Linear Subspaces","title":"HomotopyContinuation.dim","text":"dim(A::ExtrinsicDescription)\n\nDimension of the (affine) linear subspace A.\n\n\n\n\n\ndim(A::IntrinsicDescription)\n\nDimension of the (affine) linear subspace A.\n\n\n\n\n\ndim(A::LinearSubspace)\n\nDimension of the (affine) linear subspace A.\n\n\n\n\n\ndim(W::WitnessSet)\n\nThe dimension of the algebraic set encoded by the witness set.\n\n\n\n\n\n","category":"function"},{"location":"linear_subspaces/#HomotopyContinuation.intrinsic","page":"Linear Subspaces","title":"HomotopyContinuation.intrinsic","text":"intrinsic(A::LinearSubspace)\n\nObtain the intrinsic description of A, see also IntrinsicDescription.\n\n\n\n\n\n","category":"function"},{"location":"linear_subspaces/#HomotopyContinuation.is_linear","page":"Linear Subspaces","title":"HomotopyContinuation.is_linear","text":"is_linear(L::LinearSubspace)\n\nReturns true if the space is proper linear subspace, i.e., described by `L = { x | Ax = 0 }.\n\n\n\n\n\n","category":"function"},{"location":"linear_subspaces/#HomotopyContinuation.extrinsic","page":"Linear Subspaces","title":"HomotopyContinuation.extrinsic","text":"extrinsic(A::LinearSubspace)\n\nObtain the extrinsic description of A, see also ExtrinsicDescription.\n\n\n\n\n\n","category":"function"},{"location":"linear_subspaces/#HomotopyContinuation.geodesic","page":"Linear Subspaces","title":"HomotopyContinuation.geodesic","text":"geodesic(A::LinearSubspace, B::LinearSubspace)\n\nReturns the geodesic γ(t) connecting A and B in the Grassmanian Gr(k+1n+1) where k is the dimension of A and n is the ambient dimension. See also Corollary 4.3 in [LKK19].\n\n[LKK19]: Lim, Lek-Heng, Ken Sze-Wai Wong, and Ke Ye. \"Numerical algorithms on the affine Grassmannian.\" SIAM Journal on Matrix Analysis and Applications 40.2 (2019): 371-393\n\n\n\n\n\n","category":"function"},{"location":"linear_subspaces/#HomotopyContinuation.geodesic_distance","page":"Linear Subspaces","title":"HomotopyContinuation.geodesic_distance","text":"geodesic_distance(A::LinearSubspace, B::LinearSubspace)\n\nCompute the geodesic distance between A and B in the affine Grassmanian Graff(k, n) where k = dim(A) and n is the amebient dimension. This follows the derivation in [LKK19].\n\n[LKK19]: Lim, Lek-Heng, Ken Sze-Wai Wong, and Ke Ye. \"Numerical algorithms on the affine Grassmannian.\" SIAM Journal on Matrix Analysis and Applications 40.2 (2019): 371-393.\n\n\n\n\n\n","category":"function"},{"location":"linear_subspaces/#HomotopyContinuation.rand_subspace","page":"Linear Subspaces","title":"HomotopyContinuation.rand_subspace","text":"rand_subspace(n::Integer; dim | codim, affine = true, real = false)\n\nGenerate a random LinearSubspace with given dimension dim or codimension codim (one of them has to be provided) in ambient space of dimension n. If real is true, then the extrinsic description is real. If affine then an affine linear subspace is generated. The subspace is generated by drawing each entry of the extrinsic description indepdently from a normal distribuation using randn.\n\nrand_subspace(x::AbstractVector; dim | codim, affine = true)\n\nGenerate a random LinearSubspace with given dimension dim or codimension codim (one of them has to be provided) in ambient space of dimension length(x) going through the given point x.\n\nExample\n\nConstruction of a general random subspace:\n\njulia> rand_subspace(3; dim = 1)\n1-dim. (affine) linear subspace {x|Ax=b} with eltype Complex{Float64}:\nA:\n2×3 Array{Complex{Float64},2}:\n  -1.73825+1.27987im   -0.0871343+0.840408im  -0.551957+0.106397im\n -0.597132-0.343965im   -0.122543-0.172715im   -1.04949+0.370917im\nb:\n2-element Array{Complex{Float64},1}:\n  0.47083334430689394 + 0.8099804422599071im\n -0.12018696822943896 + 0.11723026326952792im\n\njulia> rand_subspace(4; codim = 1)\n3-dim. (affine) linear subspace {x|Ax=b} with eltype Complex{Float64}:\nA:\n1×4 Array{Complex{Float64},2}:\n 0.345705+0.0893881im  -0.430867-0.663249im  0.979969-0.569378im  -0.29722-0.192493im\nb:\n1-element Array{Complex{Float64},1}:\n 0.7749708228192062 + 0.9762873764567546im\n\n\n\n\n\n","category":"function"},{"location":"linear_subspaces/#HomotopyContinuation.translate","page":"Linear Subspaces","title":"HomotopyContinuation.translate","text":"translate(L::LinearSubspace, δb, ::Coordinates = Extrinsic)\n\nTranslate the (affine) linear subspace L by δb.\n\n\n\n\n\n","category":"function"},{"location":"solve_examples/#Solve-Examples","page":"Examples","title":"Solve Examples","text":"","category":"section"},{"location":"solve_examples/#A-First-Example-(no-start-system)","page":"Examples","title":"A First Example (no start system)","text":"","category":"section"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"We can solve the system F(xy) = (x^2+y^2+1 2x+3y-1) in the following way","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"using HomotopyContinuation #hide\n@var x y\nF = System([x^2+y^2+1, 2x+3y-1], variables = [x, y])\nsolve(F; show_progress = false) #hide\nsolve(F)","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"Here, the call","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"F = System([x^2+y^2+1, 2x+3y-1], variables = [x, y])","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"also determines the ordering of the variables in the solution vectors. By default, variables are ordered lexciographically. If this is okay, you can also call solve without first constructing a system, i.e.,","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"solve([x^2+y^2+1, 2x+3y-1])","category":"page"},{"location":"solve_examples/#Parameter-Homotopy","page":"Examples","title":"Parameter Homotopy","text":"","category":"section"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"Using the syntax","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"solve(F, startsolutions; start_parameters, target_parameters)","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"We can track the given start solutions alogn the parameter homotopy","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"H(x t) = F(x tp₁+(1-t)p₀)","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"where p₁ (=start_parameters) and p₀ (=target_parameters) are vectors of parameter values for F where F is a System depending on parameters.","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"Assume we want to perform a parameter homotopy H(xt) = F(x t1 0+(1-t)2 4) where","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"F(x a) = (x₁^2-a₁ x₁x₂-a₁+a₂)","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"and let's say we are only interested in tracking the solution 11. This can be accomplished as follows","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"using HomotopyContinuation #hide\n@var x[1:2] a[1:2]\nF = System([x[1]^2-a[1], x[1]*x[2]-a[1]+a[2]], parameters = a)\nstart_solutions = [[1, 1]]\np₁ = [1, 0]\np₀ = [2, 4]\nsolve(F, start_solutions; start_parameters=p₁, target_parameters=p₀, show_progress=false) #hide\nsolve(F, start_solutions; start_parameters=p₁, target_parameters=p₀)","category":"page"},{"location":"solve_examples/#Start-Target-Homotopy","page":"Examples","title":"Start Target Homotopy","text":"","category":"section"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"solve(G, F, start_solutions; options...)","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"This constructs the homotopy H(xt) = tG(x)+(1-t)F(x) to compute solutions of the system F. start_solutions is a list of solutions of G which are tracked to solutions of F.","category":"page"},{"location":"solve_examples/","page":"Examples","title":"Examples","text":"using HomotopyContinuation #hide\n@var x y\nG = System([x^2+1,y+1])\nF = System([x^2+y^2+1, 2x+3y-1])\nsolve(G, F, [[im, -1], [-im, -1]]; show_progress = false) #hide\nsolve(G, F, [[im, -1], [-im, -1]])","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"HomotopyContinuation.jl is a package for the numerical solution of systems of polynomial equations.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"This documentation is a purely technical description of the package functionality. You can find tutorials, examples, how-to guides and explanations on our homepage JuliaHomotopyContinuation.org.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"Problem formulation","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"model_kit.md\",\n    \"linear_affine.md\",\n    \"systems.md\",\n    \"homotopies.md\"\n]\nDepth = 2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Solving Systems","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"solve.md\",\n    \"witness_sets.md\",\n    \"monodromy.md\",\n    \"result.md\",\n    \"certification.md\",\n    \"solve_examples.md\",\n    \"start_systems.md\",\n]\nDepth = 2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Trackers","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"endgame_tracker.md\",\n    \"tracker.md\",\n]\nDepth = 2","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Miscellaneous","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"misc.md\",\n]\nDepth = 2","category":"page"}]
}
