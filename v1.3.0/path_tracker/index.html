<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Path Tracker · HomotopyContinuation.jl</title><link href="https://fonts.googleapis.com/css?family=Lato|Roboto+Mono" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.11.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.11.1/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="HomotopyContinuation.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit">HomotopyContinuation.jl</span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Introduction</a></li><li><span class="tocitem">Solving polynomial systems</span><ul><li><a class="tocitem" href="../solving/">The solve function</a></li><li><a class="tocitem" href="../solver/">The Solver struct</a></li></ul></li><li><a class="tocitem" href="../monodromy/">Solving parametrized systems with monodromy</a></li><li><a class="tocitem" href="../input/">Input</a></li><li><span class="tocitem">Tracking paths</span><ul><li class="is-active"><a class="tocitem" href>Path Tracker</a><ul class="internal"><li><a class="tocitem" href="#Basic-usage-1"><span>Basic usage</span></a></li><li><a class="tocitem" href="#PathResult-1"><span>PathResult</span></a></li><li><a class="tocitem" href="#Low-level-API-1"><span>Low-level API</span></a></li></ul></li><li><a class="tocitem" href="../core_tracker/">Core Tracker</a></li></ul></li><li><a class="tocitem" href="../homotopies/">Homotopies</a></li><li><a class="tocitem" href="../systems/">Polynomial systems</a></li><li><a class="tocitem" href="../reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Tracking paths</a></li><li class="is-active"><a href>Path Tracker</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Path Tracker</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/JuliaHomotopyContinuation/HomotopyContinuation.jl/blob/master/docs/src/path_tracker.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Path-Tracker-1"><a class="docs-heading-anchor" href="#Path-Tracker-1">Path Tracker</a><a class="docs-heading-anchor-permalink" href="#Path-Tracker-1" title="Permalink"></a></h1><p>The <a href="../solving/#HomotopyContinuation.solve"><code>solve</code></a> routine is only a thin wrapper around <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a>. Therefore you can also use <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a> directly. This is for example a good choice if you have to solve the same problem many times.</p><h2 id="Basic-usage-1"><a class="docs-heading-anchor" href="#Basic-usage-1">Basic usage</a><a class="docs-heading-anchor-permalink" href="#Basic-usage-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.PathTracker" href="#HomotopyContinuation.PathTracker"><code>HomotopyContinuation.PathTracker</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PathTracker</code></pre><p>The <code>PathTracker</code> combines the path tracking (with <a href="../core_tracker/#HomotopyContinuation.CoreTracker"><code>CoreTracker</code></a>) with an <em>endgame</em> routine. The <em>endgame</em>  is the name for special algorithms the end of the path tracking. These enable to detect if a path is diverging or if it ends in a singular solution. The <code>PathTracker</code> is more opinionated than the <code>CoreTracker</code> and implements additional logic to handle numerical difficult solutions. In particular it always reparametrizes a solution path to use a logarithmic time scale, i.e., <span>$x(t) → x(e^{-s})$</span> and we track for <span>$s$</span> from <span>$0$</span> to <span>$∞$</span>.</p><p>In order to construct a <code>PathTracker</code> it is recommended to use the <a href="#HomotopyContinuation.pathtracker"><code>pathtracker</code></a> and <a href="#HomotopyContinuation.pathtracker_startsolutions"><code>pathtracker_startsolutions</code></a> helper functions. With a <code>PathTracker</code> constructed you can track a single path using the <a href="../core_tracker/#HomotopyContinuation.track"><code>track</code></a> method. The result of this will be a <a href="#HomotopyContinuation.PathResult"><code>PathResult</code></a>.</p><p>The <code>PathTracker</code> assumes that the provided homotopy <code>H</code> is defined in such a way that <code>H(x,1)</code> is the start system and <code>H(x,0)</code> the target system. During the path tracking an approximation of the valuation of a Puiseux series expansion of the solution is computed. This is used to decide whether a path is diverging. Before a certain treshold (<code>s_always_consider_valuation</code>) this approximation is only trusted if a path gives some sign of ill-conditioning. To compute singular solutions the <em>Cauchy endgame</em> is used which is based on Cauchy&#39;s integral formula. For this we have to track solutions along a loop around the origin. The number of loops necessary to arrive back at the start point is called the <em>winding number</em>.</p><p><strong>Options</strong></p><p>The path tracker accepts all options which <a href="../core_tracker/#HomotopyContinuation.CoreTracker"><code>CoreTracker</code></a> accepts. Furthermore the following options are accepted:</p><ul><li><code>at_infinity_check</code>: This is true if the provided start system is an affine polynomial system.</li><li><code>endgame_start</code> (default <code>2.0</code>): The value of <code>s</code> where the endgame is started earliest.</li><li><code>max_winding_number</code> (default <code>12</code>): The maximal winding number tried in the Cauchy endgame.</li><li><code>min_accuracy</code> (default <code>1e-5</code>): The <code>PathTracker</code> automatically lowers the desired accuracy automatically to <code>min_accuracy</code> if path tracking would fail othwerwise (since the desired cannot be reached)</li><li><code>min_cond_eg</code> (default <code>1e5</code>): The minimal condition number before the Cauchy endgame is started or a path is cut off.</li><li><code>min_step_size_before_eg</code> (default <code>exp2(-40)</code>): The minimal allowed step size before the endgame starts.</li><li><code>min_step_size_eg</code> (default <code>exp2(-120)</code>): The minimal allowed step size during the endgame. This is also control what is considered <code>∞</code> for the path tracking.</li><li><code>s_always_consider_valuation</code> (default <code>-log(1e-16)</code>) A threshold after which we always consider the valuation.</li><li><code>samples_per_loop (default</code>8`): The number of samples used during the endgame.</li><li><code>precision_strategy</code> (default <code>:adaptive_finite</code>): This controls whether <code>H(x,t)</code> is possibly evaluated with higher than machine precision during the endgame (the Jacobian is always computed with machine precision). The <code>:adaptive_finite</code> allows this only if we are optimistic that we can still obtain a finite solution. Other options are <code>:adaptive_never</code> where this is never allowed and <code>:adaptive_always</code> where it is always enabled. ``</li></ul></div></section></article><p>The easiest way to construct a <code>PathTracker</code>:</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.pathtracker_startsolutions" href="#HomotopyContinuation.pathtracker_startsolutions"><code>HomotopyContinuation.pathtracker_startsolutions</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pathtracker_startsolutions(args...; kwargs...)</code></pre><p>Construct a <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a> and start solutions in the same way <a href="../solving/#HomotopyContinuation.solve"><code>solve</code></a> does it. This also takes the same input arguments as <code>solve</code>. This is convenient if you want to investigate single paths.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.pathtracker" href="#HomotopyContinuation.pathtracker"><code>HomotopyContinuation.pathtracker</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">pathtracker(args...; kwargs...)</code></pre><p>Construct a <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a> in the same way <a href="../solving/#HomotopyContinuation.solve"><code>solve</code></a> does it. This also takes the same input arguments as <code>solve</code> with the exception that you do not need to specify startsolutions.</p><p><strong>Examples</strong></p><p><strong>Obtain single solution</strong></p><p>We want to construct a path tracker to track a parametrized system <code>f</code> with parameters <code>p</code> from the parameters <code>a</code> to <code>b</code>.</p><pre><code class="language-julia">tracker = pathtracker(f, parameters=p, p₁=a, p₀=b)</code></pre><p>You then can obtain a single solution at <code>b</code> by using</p><pre><code class="language-julia">x_b = solution(track(tracker, x_a))</code></pre></div></section></article><p>To track a single path you can use the <a href="../core_tracker/#HomotopyContinuation.track"><code>track</code></a> and <a href="../core_tracker/#HomotopyContinuation.track!-Tuple{CoreTracker,AbstractArray{T,1} where T,Number,Number}"><code>track!</code></a> methods.</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.track-Tuple{PathTracker,Any}" href="#HomotopyContinuation.track-Tuple{PathTracker,Any}"><code>HomotopyContinuation.track</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">track(tracker::PathTracker, x₁;
        path_number=nothing,
        details::Symbol=:default,
        start_parameters = nothing,
        target_parameters = nothing)</code></pre><p>Track the path <code>x(t)</code> with start solution <code>x₁</code> from <span>$1$</span> towards <span>$0$</span>. Returns a <a href="#HomotopyContinuation.PathResult"><code>PathResult</code></a>.</p><p>The <code>details</code> options controls the level of details of the informations available in the <a href="#HomotopyContinuation.PathResult"><code>PathResult</code></a>. If <code>tracker</code> uses a parameter homotopy you can set the start and target parameters by setting the corresponding fields. To investigate the behaviour of a particular take a look at <a href="../reference/#HomotopyContinuation.path_info"><code>path_info</code></a>.</p></div></section></article><h2 id="PathResult-1"><a class="docs-heading-anchor" href="#PathResult-1">PathResult</a><a class="docs-heading-anchor-permalink" href="#PathResult-1" title="Permalink"></a></h2><p>For each path we return a <a href="#HomotopyContinuation.PathResult"><code>PathResult</code></a> containing the detailed information about the single path.</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.PathResult" href="#HomotopyContinuation.PathResult"><code>HomotopyContinuation.PathResult</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">PathResult{V&lt;:AbstractVector}</code></pre><p>A <code>PathResult</code> is the result of tracking of a path with <a href="../core_tracker/#HomotopyContinuation.track"><code>track</code></a> using a <a href="#HomotopyContinuation.PathTracker"><code>PathTracker</code></a>.</p><p><strong>Fields</strong></p><ul><li><code>return_code</code>: See the list of return codes below.</li><li><code>solution::V</code>: The solution vector.</li><li><code>t::Float64</code>: The value of <code>t</code> at which <code>solution</code> was computed. Note that if <code>return_code</code> is <code>:at_infinity</code>, then <code>t</code> is the value when this was decided.</li><li><code>accuracy::Float64</code>: An approximation of <span>$||x-x̄||$</span> where <span>$x$</span> is the computed solution and <span>$x̄$</span> is the true solution.</li><li><code>residual::Float64</code>: The value of the infinity-norm of <code>H(solution, 0)</code>.</li><li><code>multiplicity::Union{Nothing, Int}</code> is the multiplicity of the <code>solution</code>. This is only assigned by <a href="../solving/#HomotopyContinuation.singular"><code>singular</code></a>.</li><li><code>condition_jacobian::Union{Nothing, Float64}</code>: This is the condition number of the row-equilibrated Jacobian at the solution. A high condition number indicates a singularity.</li><li><code>winding_number:Union{Nothing, Int}</code>: The estimated winding number. This is a lower bound on the multiplicity of the solution.</li><li><code>start_solution::Union{Nothing, Int}</code>: The start solution of the path.</li><li><code>accepted_steps::Int</code>: The number of accepted steps during the path tracking.</li><li><code>rejected_steps::Int</code>: The number of rejected steps during the path tracking.</li><li><code>valuation::Union{Nothing, Vector{Float64}}</code>: An approximation of the valuation of the Puiseux series expansion of <code>x(t)</code>.</li><li><code>valuation_accuracy::Union{Nothing, Vector{Float64}}</code>: An estimate of the accuracy of the valuation of the Puiseux series expansion of <code>x(t)</code>.</li></ul><p><strong>Return codes</strong></p><p>These is the list of possible return codes:</p><ul><li><code>:success</code>: The <code>PathTracker</code> obtained a solution.</li><li><code>:at_infinity</code>: The <code>PathTracker</code> stopped the tracking of the path since it determined that that path is diverging towards infinity.</li><li><code>:terminated_callback</code>: One of the optional <code>PathTracker</code> callbacks terminated the tracking.</li><li><code>:terminated_max_iters</code>: The <code>PathTracker</code> terminated since it reached the limit accuracy.</li><li><code>:terminated_invalid_startvalue</code>: The <code>PathTracker</code> terminated since the provided start value is invalid.</li><li><code>:terminated_step_size_too_small</code>: The <code>PathTracker</code> terminated since the step size became smaller than the provided threshold.</li><li><code>:terminated_accuracy_limit</code>: The <code>PathTracker</code> terminated since the problem was too ill-conditioned to be tracked further with the desired minimal accuracy.</li><li><code>:terminated_ill_conditioned</code>: The <code>PathTracker</code> terminated since the Jacobian of the homotopy was too ill-conditioned.</li><li><code>:post_check_failed</code>: The verification of a non-singular solution failed.</li></ul><p><strong>Constructors</strong></p><pre><code class="language-none"> PathResult(tracker::PathTracker,
            start_solution=nothing,
            path_number::Union{Nothing,Int}=nothing;
            details=:default)</code></pre><p>Construct a <code>PathResult</code> using the current state of the <code>PathTracker</code>. Possible values for <code>details</code> are <code>:minimal</code> (minimal details), <code>:default</code> (default) and <code>:extensive</code> (all information possible).</p></div></section></article><p>The following helper functions are provided</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.solution-Tuple{PathResult}" href="#HomotopyContinuation.solution-Tuple{PathResult}"><code>HomotopyContinuation.solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">solution(r::PathResult)</code></pre><p>Get the solution of the path.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.accuracy-Tuple{PathResult}" href="#HomotopyContinuation.accuracy-Tuple{PathResult}"><code>HomotopyContinuation.accuracy</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">accuracy(r::PathResult)</code></pre><p>Get the accuracy of the solution. This is an estimate of the (relative) distance to the true solution.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.residual-Tuple{PathResult}" href="#HomotopyContinuation.residual-Tuple{PathResult}"><code>HomotopyContinuation.residual</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">residual(r::PathResult)</code></pre><p>Get the residual of the solution <span>$x$</span> of the path, i.e., <span>$||H(x, 0)||₂$</span>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.winding_number-Tuple{PathTracker}" href="#HomotopyContinuation.winding_number-Tuple{PathTracker}"><code>HomotopyContinuation.winding_number</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">winding_number(tracker::PathTracker)</code></pre><p>Obtain the estimate of the winding number computed by the <code>PathTracker</code>. Returns <code>nothing</code> if the Cauchy endgame was not run.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.multiplicity-Tuple{PathResult}" href="#HomotopyContinuation.multiplicity-Tuple{PathResult}"><code>HomotopyContinuation.multiplicity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">multiplicity(P::PathResult)</code></pre><p>Returns the multiplicity of <code>P</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.condition_jacobian-Tuple{PathResult}" href="#HomotopyContinuation.condition_jacobian-Tuple{PathResult}"><code>HomotopyContinuation.condition_jacobian</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">condition_jacobian(r::PathResult)</code></pre><p>Return the condition number of the Jacobian of the result.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="LinearAlgebra.cond-Tuple{PathResult}" href="#LinearAlgebra.cond-Tuple{PathResult}"><code>LinearAlgebra.cond</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">cond(r::PathResult)</code></pre><p>Return the condition number of the Jacobian of the result.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.start_solution-Tuple{PathResult}" href="#HomotopyContinuation.start_solution-Tuple{PathResult}"><code>HomotopyContinuation.start_solution</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">start_solution(r::PathResult)</code></pre><p>Get the start solution of the path.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.is_real-Tuple{PathResult}" href="#HomotopyContinuation.is_real-Tuple{PathResult}"><code>HomotopyContinuation.is_real</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_real(r::PathResult; tol=1e-6)</code></pre><p>We consider a result as <code>real</code> if the 2-norm of the imaginary part of the solution is at most <code>tol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.is_success-Tuple{PathResult}" href="#HomotopyContinuation.is_success-Tuple{PathResult}"><code>HomotopyContinuation.is_success</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_success(r::PathResult)</code></pre><p>Checks whether the path is successfull.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.is_failed-Tuple{PathResult}" href="#HomotopyContinuation.is_failed-Tuple{PathResult}"><code>HomotopyContinuation.is_failed</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_failed(r::PathResult)</code></pre><p>Checks whether the path failed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.is_affine-Tuple{PathResult}" href="#HomotopyContinuation.is_affine-Tuple{PathResult}"><code>HomotopyContinuation.is_affine</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_affine(pathresult)</code></pre><p>Return`s true if the solution is an affine vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.is_projective-Tuple{PathResult}" href="#HomotopyContinuation.is_projective-Tuple{PathResult}"><code>HomotopyContinuation.is_projective</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_projective(r::PathResult)</code></pre><p>Return`s true if the solution is a projective vector.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.is_at_infinity-Tuple{PathResult}" href="#HomotopyContinuation.is_at_infinity-Tuple{PathResult}"><code>HomotopyContinuation.is_at_infinity</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_at_infinity(r::PathResult)</code></pre><p>Checks whether the path goes to infinity.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.is_singular-Tuple{PathResult}" href="#HomotopyContinuation.is_singular-Tuple{PathResult}"><code>HomotopyContinuation.is_singular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_singular(r::PathResult; tol=1e10)</code></pre><p>Checks whether the path result is singular. This is true if the multiplicity is larger than  1 or if the condition number of the Jacobian is larger than <code>tol</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.is_nonsingular-Tuple{PathResult}" href="#HomotopyContinuation.is_nonsingular-Tuple{PathResult}"><code>HomotopyContinuation.is_nonsingular</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">is_nonsingular(r::PathResult; tol=1e10)</code></pre><p>Checks whether the path result is non-singular. This is true if it is not singular.</p></div></section></article><h2 id="Low-level-API-1"><a class="docs-heading-anchor" href="#Low-level-API-1">Low-level API</a><a class="docs-heading-anchor-permalink" href="#Low-level-API-1" title="Permalink"></a></h2><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.track!-Tuple{PathTracker,Any}" href="#HomotopyContinuation.track!-Tuple{PathTracker,Any}"><code>HomotopyContinuation.track!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">track!(tracker::PathTracker, x₁)::PathTrackerStatus.states</code></pre><p>Track the path <code>x(t)</code> with start solution <code>x₁</code> from <span>$1$</span> towards <span>$0$</span>. Returns a <a href="#HomotopyContinuation.PathTrackerStatus.states"><code>PathTrackerStatus.states</code></a>.</p></div></section></article><p>In the case that you track paths of parameter homotopy you can also change the parameters using</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.start_parameters!-Tuple{PathTracker,Any}" href="#HomotopyContinuation.start_parameters!-Tuple{PathTracker,Any}"><code>HomotopyContinuation.start_parameters!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">start_parameters!(tracker::PathTracker, p)</code></pre><p>Set the start parameters of the homotopy in in <code>tracker</code> to <code>p</code>.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.target_parameters!-Tuple{PathTracker,Any}" href="#HomotopyContinuation.target_parameters!-Tuple{PathTracker,Any}"><code>HomotopyContinuation.target_parameters!</code></a> — <span class="docstring-category">Method</span></header><section><div><pre><code class="language-julia">target_parameters!(tracker::PathTracker, p)</code></pre><p>Set the target parameters of the homotopy in in <code>tracker</code> to <code>p</code>.</p></div></section></article><p>The return type of <a href="../core_tracker/#HomotopyContinuation.track!-Tuple{CoreTracker,AbstractArray{T,1} where T,Number,Number}"><code>track!</code></a> is a <a href="#HomotopyContinuation.PathTrackerStatus.states"><code>PathTrackerStatus.states</code></a>:</p><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.PathTrackerStatus.states" href="#HomotopyContinuation.PathTrackerStatus.states"><code>HomotopyContinuation.PathTrackerStatus.states</code></a> — <span class="docstring-category">Type</span></header><section><div><pre><code class="language-julia">enum PathTrackerStatus</code></pre><p>The possible states a <code>PathTracker</code> can be in:</p><ul><li><code>PathTrackerStatus.tracking</code></li><li><code>PathTrackerStatus.success</code></li><li><code>PathTrackerStatus.at_infinity</code></li><li><code>PathTrackerStatus.excess_solution</code></li><li><code>PathTrackerStatus.post_check_failed</code></li><li><code>PathTrackerStatus.terminated_accuracy_limit</code></li><li><code>PathTrackerStatus.terminated_ill_conditioned</code></li><li><code>PathTrackerStatus.terminated_invalid_startvalue</code></li><li><code>PathTrackerStatus.terminated_max_winding_number</code></li><li><code>PathTrackerStatus.terminated_max_iters</code></li><li><code>PathTrackerStatus.terminated_step_size_too_small</code></li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/JuliaLang/julia/blob/46ce4d79337bdd257ee2e3d2f4bb1c55ff0a5030/base/#L0-L16">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.is_success" href="#HomotopyContinuation.is_success"><code>HomotopyContinuation.is_success</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_success(S::CoreTrackerStatus.states)</code></pre><p>Returns <code>true</code> if <code>S</code> indicates a success in the path tracking.</p></div></section><section><div><pre><code class="language-julia">is_success(result::CoreTrackerResult)</code></pre><p>Returns <code>true</code> if the path tracking was successfull.</p></div></section><section><div><pre><code class="language-none">is_success(status::PathTrackerStatus.states)</code></pre><p>Returns <code>true</code> if <code>status</code> indicates a success in tracking.</p></div></section><section><div><pre><code class="language-julia">is_success(r::PathResult)</code></pre><p>Checks whether the path is successfull.</p></div></section><section><div><pre><code class="language-none">is_success(result::MonodromyResult)</code></pre><p>Returns true if the monodromy computation achieved its target solution count.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.is_at_infinity" href="#HomotopyContinuation.is_at_infinity"><code>HomotopyContinuation.is_at_infinity</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_success(status::PathTrackerStatus.states)</code></pre><p>Returns <code>true</code> if <code>status</code> indicates that a path diverged towards infinity.</p></div></section><section><div><pre><code class="language-julia">is_at_infinity(r::PathResult)</code></pre><p>Checks whether the path goes to infinity.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.is_invalid_startvalue" href="#HomotopyContinuation.is_invalid_startvalue"><code>HomotopyContinuation.is_invalid_startvalue</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_invalid_startvalue(S::CoreTrackerStatus.states)</code></pre><p>Returns <code>true</code> if <code>S</code> indicates that the path tracking got terminated since the start value was not a zero.</p></div></section><section><div><pre><code class="language-none">is_invalid_startvalue(status::PathTrackerStatus.states)</code></pre><p>Returns <code>true</code> if the provided start value was not valid.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.is_failed" href="#HomotopyContinuation.is_failed"><code>HomotopyContinuation.is_failed</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_failed(r::PathResult)</code></pre><p>Checks whether the path failed.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.is_terminated_callback" href="#HomotopyContinuation.is_terminated_callback"><code>HomotopyContinuation.is_terminated_callback</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_terminated_callback(status::PathTrackerStatus.states)</code></pre><p>Returns <code>true</code> if the provided callback indicated a termination of the path.</p></div></section></article><article class="docstring"><header><a class="docstring-binding" id="HomotopyContinuation.is_tracking" href="#HomotopyContinuation.is_tracking"><code>HomotopyContinuation.is_tracking</code></a> — <span class="docstring-category">Function</span></header><section><div><pre><code class="language-julia">is_tracking(S::CoreTrackerStatus.states)</code></pre><p>Returns <code>true</code> if <code>S</code> indicates that the path tracking is not yet finished.</p></div></section><section><div><pre><code class="language-none">is_tracking(status::PathTrackerStatus.states)</code></pre><p>Returns <code>true</code> if <code>status</code> indicates the tracking is not going on.</p></div></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../input/">« Input</a><a class="docs-footer-nextpage" href="../core_tracker/">Core Tracker »</a></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> on <span class="colophon-date" title="Monday 2 December 2019 06:46">Monday 2 December 2019</span>. Using Julia version 1.3.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
