var documenterSearchIndex = {"docs":
[{"location":"homotopies/#Homotopies-1","page":"Homotopies","title":"Homotopies","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"A homotopy is a function","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"H mathbbC^N  mathbbC  mathbbC^n (xt)  H(xt)","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"where H( t) is a polynomial system for all tmathbbC.","category":"page"},{"location":"homotopies/#Default-homotopies-1","page":"Homotopies","title":"Default homotopies","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"The following homotopies are available by default","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"StraightLineHomotopy\nFixedPointHomotopy\nParameterHomotopy\nCoefficientHomotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.StraightLineHomotopy","page":"Homotopies","title":"HomotopyContinuation.StraightLineHomotopy","text":"StraightLineHomotopy(G, F; gamma=exp(i * 2π*rand()))\n\nConstruct the homotopy H(x t) = γtG(x) + (1-t)F(x).\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.FixedPointHomotopy","page":"Homotopies","title":"HomotopyContinuation.FixedPointHomotopy","text":"FixedPointHomotopy(F, x₀; gamma=exp(i * 2π*rand()))\n\nConstruct the homotopy H(x t) = (1-t)F(x) + γt(x-x₀).\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.ParameterHomotopy","page":"Homotopies","title":"HomotopyContinuation.ParameterHomotopy","text":"ParameterHomotopy(F, parameters;\n    variables=setdiff(variables(F), parameters),\n    p₁=randn(ComplexF64, length(parameters)),\n    p₀=randn(ComplexF64, length(parameters)),\n    γ₁=nothing, γ₀=nothing)\n\nConstruct the homotopy\n\nH(x t) = F(x (tγ₁p₁+(1-t)γ₀p₀)  (tγ₁+(1-t)γ₀))\n\nwhere p₁ and p₀ are a vector of parameter values for F and γ₁ and γ₀ are complex numbers. If γ₁ or γ₀ is nothing, it is assumed that γ₁ and γ₀ are 1. The input parameters specifies the parameter variables of F. Neccessarily, length(parameters) == length(p₁) == length(p₀).\n\nNote that p₁ and p₀ are stored as a tuple p of SVectors and γ₁ and γ₀ are stored as a tuple γ or as γ=nothing\n\nParameterHomotopy(F, parameters;\n    variables=setdiff(variables(F), parameters),\n    start_parameters=randn(ComplexF64, length(parameters)),\n    target_parameters=randn(ComplexF64, length(parameters)),\n    start_gamma=nothing, target_gamma=nothing)\n\nThis is a non-unicode variant where γ₁=start_parameters, γ₀=target_parameters, γ₁=start_gamma, γ₀=target_gamma.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.CoefficientHomotopy","page":"Homotopies","title":"HomotopyContinuation.CoefficientHomotopy","text":"CoefficientHomotopy(support, start_coeffs, target_coeffs)\n\nConstruct the homotopy H(x t) = _a  Aᵢ (c_a t + (1-t)d_a) x^a where c_a are the start coefficients and d_a the target coefficients.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"We also provide more specialised homotopies, which are mostly used internally currently but could be useful in conjunction with the CoreTracker primitive.","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"PatchedHomotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.PatchedHomotopy","page":"Homotopies","title":"HomotopyContinuation.PatchedHomotopy","text":"PatchedHomotopy(H::AbstractHomotopy, patch, v::PVector)\n\nAugment the homotopy H with the given patch v. This results in the system [H(x,t); v ⋅ x - 1]\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#Interface-for-custom-homotopies-1","page":"Homotopies","title":"Interface for custom homotopies","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"The great thing is that you are not limited to the homotopies provided by default. You can define your own homotopy by defining a struct with super type AbstractHomotopy. For this the following interface has to be defined.","category":"page"},{"location":"homotopies/#Types-1","page":"Homotopies","title":"Types","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"AbstractHomotopy\nAbstractHomotopyCache\nHomotopyNullCache","category":"page"},{"location":"homotopies/#HomotopyContinuation.AbstractHomotopy","page":"Homotopies","title":"HomotopyContinuation.AbstractHomotopy","text":"AbstractHomotopy\n\nRepresenting a homotopy.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.AbstractHomotopyCache","page":"Homotopies","title":"HomotopyContinuation.AbstractHomotopyCache","text":"AbstractHomotopyCache\n\nA cache to avoid allocations for the evaluation of an AbstractHomotopy.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#HomotopyContinuation.HomotopyNullCache","page":"Homotopies","title":"HomotopyContinuation.HomotopyNullCache","text":"HomotopyNullCache\n\nThe default AbstractHomotopyCache containing nothing.\n\n\n\n\n\n","category":"type"},{"location":"homotopies/#Mandatory-1","page":"Homotopies","title":"Mandatory","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"The following methods are mandatory to implement.","category":"page"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"cache(H::AbstractHomotopy, x, t)\nevaluate!(u, F::AbstractHomotopy, args...)\njacobian!(u, H::AbstractHomotopy, args...)\ndt!\nBase.size(::AbstractHomotopy)","category":"page"},{"location":"homotopies/#HomotopyContinuation.cache-Tuple{AbstractHomotopy,Any,Any}","page":"Homotopies","title":"HomotopyContinuation.cache","text":"cache(H::AbstractHomotopy, x, t)::AbstractHomotopyCache\n\nCreate a cache for the evaluation (incl. Jacobian) of F with elements of the type of x. The default implementation returns HomotopyNullCache.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.evaluate!-Tuple{Any,AbstractHomotopy,Vararg{Any,N} where N}","page":"Homotopies","title":"HomotopyContinuation.evaluate!","text":"evaluate!(u, H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H at (x, t) and store the result in u.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.jacobian!-Tuple{Any,AbstractHomotopy,Vararg{Any,N} where N}","page":"Homotopies","title":"HomotopyContinuation.jacobian!","text":"jacobian!(u, H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the Jacobian of the homotopy H at (x, t) and store the result in u.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.dt!","page":"Homotopies","title":"HomotopyContinuation.dt!","text":"dt!(u, H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H at (x, t) and store the result in u.\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#Base.size-Tuple{AbstractHomotopy}","page":"Homotopies","title":"Base.size","text":"Base.size(H::AbstractHomotopy)\n\nReturns a tuple (m, n) indicating that H is a homotopy of m polynomials m in n variables.\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#Optional-1","page":"Homotopies","title":"Optional","text":"","category":"section"},{"location":"homotopies/#","page":"Homotopies","title":"Homotopies","text":"evaluate_and_jacobian!(u, U, H::AbstractHomotopy, x, t, c=cache(H, x, t))\nevaluate_and_jacobian(H::AbstractHomotopy, x, t, c=cache(H, x, t))\njacobian_and_dt!(U, u, H::AbstractHomotopy, x, t, c=cache(H, x, t))\njacobian_and_dt(H::AbstractHomotopy, x, t, c=cache(H, x, t))\nevaluate(H::AbstractHomotopy, x, t)\njacobian(H::AbstractHomotopy, x, t)\ndt(H::AbstractHomotopy, x, t)\nbasehomotopy","category":"page"},{"location":"homotopies/#HomotopyContinuation.evaluate_and_jacobian!","page":"Homotopies","title":"HomotopyContinuation.evaluate_and_jacobian!","text":"evaluate_and_jacobian!(u, U, F, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H and its Jacobian at (x, t) and store the results in u (evalution) and U (Jacobian).\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#HomotopyContinuation.evaluate_and_jacobian","page":"Homotopies","title":"HomotopyContinuation.evaluate_and_jacobian","text":"evaluate_and_jacobian(H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H and its Jacobian at (x, t).\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#HomotopyContinuation.jacobian_and_dt!","page":"Homotopies","title":"HomotopyContinuation.jacobian_and_dt!","text":"jacobian_and_dt!(U, u, H, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H and its derivative w.r.t. t at (x, t) and store the results in u (evalution) and v (∂t).\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#HomotopyContinuation.jacobian_and_dt","page":"Homotopies","title":"HomotopyContinuation.jacobian_and_dt","text":"jacobian_and_dt(H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H and its derivative w.r.t. t at (x, t).\n\n\n\n\n\n","category":"function"},{"location":"homotopies/#HomotopyContinuation.evaluate-Tuple{AbstractHomotopy,Any,Any}","page":"Homotopies","title":"HomotopyContinuation.evaluate","text":"evaluate(H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H at (x, t).\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.jacobian-Tuple{AbstractHomotopy,Any,Any}","page":"Homotopies","title":"HomotopyContinuation.jacobian","text":"jacobian(H::AbstractHomotopy, x, t, cache::AbstractHomotopyCache)\n\nEvaluate the Jacobian of the homotopy H at (x, t).\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.dt-Tuple{AbstractHomotopy,Any,Any}","page":"Homotopies","title":"HomotopyContinuation.dt","text":"dt(H::AbstractHomotopy, x::AbstractVector, cache::AbstractHomotopyCache)\n\nEvaluate the homotopy H at (x, t).\n\n\n\n\n\n","category":"method"},{"location":"homotopies/#HomotopyContinuation.basehomotopy","page":"Homotopies","title":"HomotopyContinuation.basehomotopy","text":"basehomotopy(H::AbstractHomotopy)\n\nReturns the 'proper' homotopy describing the problem. Any wrapper homotopy recursively calls wrappedhomotopy with the wrapped homotopy as argument.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#Core-Tracker-1","page":"Core Tracker","title":"Core Tracker","text":"","category":"section"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"A CoreTracker is the low-level path tracker. Its job is to track an initial solution x₁ from t₁ to t₀ by following a solution path x(t). For this a predictor-corrector scheme is used. See our introduction guide for a high-level explanation of the predictor corrector scheme","category":"page"},{"location":"core_tracker/#Basic-usage-1","page":"Core Tracker","title":"Basic usage","text":"","category":"section"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"CoreTracker","category":"page"},{"location":"core_tracker/#HomotopyContinuation.CoreTracker","page":"Core Tracker","title":"HomotopyContinuation.CoreTracker","text":"CoreTracker\n\nA CoreTracker is the low-level path tracker. Its job is to track an initial solution x₁ from t₁ to t₀ by following a solution path x(t). For this a predictor-corrector scheme is used. See our introduction guide for a high-level explanation of the predictor corrector scheme. The CoreTracker accepts for a value t a solution x^* if x(t) - x^*  τ where τ is controlled by the accuracy option.\n\nTo interact with a CoreTracker take a look at track resp. track!. You can also use CoreTracker as an iterator. For this you need to call init!(::CoreTracker, x₁, t₁, t₀) first. There is also iterator if you are only interested in pairs (x,t).\n\nThe CoreTracker cannot handle singular solutions or divergent paths. For this you have to use a PathTracker (which uses internally again a CoreTracker).\n\nThe CoreTracker can track solutions in projective space if the underlying homotopy is homogeneous and the provided start solution is a projective vector (with type PVector) from the ProjectiveVectors.jl package.\n\nThe CoreTracker can also perform a reparamterization of the parameter t from 01 towards 0 by t = e^-s. If the homotopy assumes t  01 this can be done by passing the log_transform = true option. If you already have a homotopy which assumes s  0 you can use the logarithmic_time_scale = true to tell the core tracker this. In this case the min_step_size criterion is still applied to t and not s.\n\nOptions\n\nCoreTracker accepts many different options. Here are the options in alphabetic order:\n\naccuracy (default 1e-7): The maximal acceptable distance to the true solution at a time step t.\nauto_scaling (default true): Enables an automatic scaling of the variables by introducing a weighted norm. See also WeightedNorm.\ninitial_step_size: The size of the first step. By default an automatic estimate is computed but this can be overwritten with this option.\nmax_cond (default 1e10): The maximal condition number before a path is terminated due to ill-conditioning. This is only applicable if terminate_ill_conditioned is true.\nmax_corrector_iters (default2`): The maximal number of Newton iteration steps until which the desired accuracy has to be achieved.\nmax_step_size (default Inf): Limit the path tracker to a maximal step size.\nmax_steps (default 1000): The maximal number of steps the path tracker makes. Note that this changes to 10_000 for parameter homotopies.\nmin_step_size (default 1e-14): The path tracking is terminated if the step size is smaller than this value.\nnorm (default InfNorm()): The norm used in the computations. Note that if the auto_scaling is true, this will automatically be converted to a WeightedNorm.\npatch: It is possible to perform tracking in projective space. For the actual compuations we still need to choose an affine chart. There are multiple charts possible, see AbstractAffinePatch. The default is RandomPatch.\nprecision (default :double): This controls the precision used in the computation of H(xt). If it is set to :double only double precision arithmetic is used (Complex{Float64}).  If it set to :double_double double double arithmetic as implemented by the DoubleFloats package is always used. The option :adaptive changes adaptively the precision.\npredictor (default Pade21): The predictor used.\nsimple_step_size_alg (default false): By default the step size algorithm presented in arXiv:1902.02968 is used. If this option is true a more simple step size algorithm is used which doubles the step size after 5 consecutive successive steps and halfes the step size after a failed step.\nterminate_ill_conditioned (default true): Indicates whether the path tracking should be terminated for ill-conditioned paths. A path is considered ill-conditioned if the desirable accuracy is no more achievable or if the condition number of the Jacobian is larger than 1e14.\n\n\n\n\n\n","category":"type"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"The easiest way to construct a CoreTracker is to use coretracker and coretracker_startsolutions.","category":"page"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"coretracker_startsolutions\ncoretracker","category":"page"},{"location":"core_tracker/#HomotopyContinuation.coretracker_startsolutions","page":"Core Tracker","title":"HomotopyContinuation.coretracker_startsolutions","text":"coretracker_startsolutions(args...; kwargs...)\n\nConstruct a CoreTracker and startsolutions in the same way solve does it. This also takes the same input arguments as solve. This is convenient if you want to investigate single paths.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.coretracker","page":"Core Tracker","title":"HomotopyContinuation.coretracker","text":"coretracker(args...; kwargs...)\n\nConstruct a CoreTracker in the same way solve does it. This also takes the same input arguments as solve with the exception that you do not need to specify startsolutions. This is convenient if you want to investigate single paths.\n\nExamples\n\nObtain single solution\n\nWe want to construct a path tracker to track a parametrized system f with parameters p from the parameters a to b.\n\ntracker = coretracker(f; parameters = p, start_parameters = a, target_parameters = b)\n\nYou then can obtain a single solution at b by using\n\nx_b = track(tracker, x_a).x\n\nTrace a path\n\nTo trace a path you can use the iterator method.\n\ntracker = coretracker(f; parameters = p, start_parameters = a, target_parameters = b)\nfor (x, t) in iterator(tracker, x₁)\n    @show (x,t)\nend\n\nIf we want to guarantee smooth traces we can limit the maximal step size.\n\ntracker = coretracker(f; parameters = p, max_step_size = 0.01,\n                         start_parameters = a, target_parameters = b)\nfor (x, t) in iterator(tracker, x₁)\n    @show (x,t)\nend\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#Result-and-Status-1","page":"Core Tracker","title":"Result and Status","text":"","category":"section"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"CoreTrackerResult\nis_success(result::CoreTrackerResult)\nsolution(result::CoreTrackerResult)\nCoreTrackerStatus.states\nis_success(::CoreTrackerStatus.states)\nis_terminated(::CoreTrackerStatus.states)\nis_tracking(::CoreTrackerStatus.states)\nis_invalid_startvalue(::CoreTrackerStatus.states)","category":"page"},{"location":"core_tracker/#HomotopyContinuation.CoreTrackerResult","page":"Core Tracker","title":"HomotopyContinuation.CoreTrackerResult","text":" CoreTrackerResult{V<:AbstractVector}\n\nThe result of track(::CoreTracker, x₁, t₁, t₀). You can use is_success to check whether the tracking was successfull and solution to obtain the solution.\n\nFields\n\nreturncode The CoreTrackerStatus.states enum.\nx::V The solution at t.\nt::ComplexF64 The time t when the path tracker stopped.\naccuracy::Float64: The estimated accuracy of x.\naccepted_steps::Int: The number of accepted steps during the tracking.\nrejected_steps::Int: The number of rejected_steps steps during the tracking.\n\n\n\n\n\n","category":"type"},{"location":"core_tracker/#HomotopyContinuation.is_success-Tuple{CoreTrackerResult}","page":"Core Tracker","title":"HomotopyContinuation.is_success","text":"is_success(result::CoreTrackerResult)\n\nReturns true if the path tracking was successfull.\n\n\n\n\n\n","category":"method"},{"location":"core_tracker/#HomotopyContinuation.solution-Tuple{CoreTrackerResult}","page":"Core Tracker","title":"HomotopyContinuation.solution","text":"solution(result::CoreTrackerResult)\n\nReturns the solutions obtained by the CoreTracker.\n\n\n\n\n\n","category":"method"},{"location":"core_tracker/#HomotopyContinuation.CoreTrackerStatus.states","page":"Core Tracker","title":"HomotopyContinuation.CoreTrackerStatus.states","text":"CoreTrackerStatus.states\n\nThe possible states a CoreTracker can have are\n\nCoreTrackerStatus.success: Indicates a successfull completed tracking\nCoreTrackerStatus.tracking: The tracking is still in progress\nCoreTrackerStatus.terminated_maximal_iterations: Tracking terminated since maximal iterations reached.\nCoreTrackerStatus.terminated_ill_conditioned: Tracking terminated since the path was too ill-conditioned.\nCoreTrackerStatus.terminated_invalid_startvalue: Tracking terminated since the provided start value was invalid.\nCoreTrackerStatus.terminated_step_size_too_small\n\n\n\n\n\n","category":"type"},{"location":"core_tracker/#HomotopyContinuation.is_success-Tuple{HomotopyContinuation.CoreTrackerStatus.states}","page":"Core Tracker","title":"HomotopyContinuation.is_success","text":"is_success(S::CoreTrackerStatus.states)\n\nReturns true if S indicates a success in the path tracking.\n\n\n\n\n\n","category":"method"},{"location":"core_tracker/#HomotopyContinuation.is_terminated-Tuple{HomotopyContinuation.CoreTrackerStatus.states}","page":"Core Tracker","title":"HomotopyContinuation.is_terminated","text":"is_terminated(S::CoreTrackerStatus.states)\n\nReturns true if S indicates that the path tracking got terminated. This is not true if is_success(S) is true.\n\n\n\n\n\n","category":"method"},{"location":"core_tracker/#HomotopyContinuation.is_tracking-Tuple{HomotopyContinuation.CoreTrackerStatus.states}","page":"Core Tracker","title":"HomotopyContinuation.is_tracking","text":"is_tracking(S::CoreTrackerStatus.states)\n\nReturns true if S indicates that the path tracking is not yet finished.\n\n\n\n\n\n","category":"method"},{"location":"core_tracker/#HomotopyContinuation.is_invalid_startvalue-Tuple{HomotopyContinuation.CoreTrackerStatus.states}","page":"Core Tracker","title":"HomotopyContinuation.is_invalid_startvalue","text":"is_invalid_startvalue(S::CoreTrackerStatus.states)\n\nReturns true if S indicates that the path tracking got terminated since the start value was not a zero.\n\n\n\n\n\n","category":"method"},{"location":"core_tracker/#Methods-1","page":"Core Tracker","title":"Methods","text":"","category":"section"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"To track from a start to an endpoint with the CoreTracker we provide the following routines.","category":"page"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"track(tracker::CoreTracker, x₁::AbstractVector, t₁::Number = 1.0, t₀::Number = 0.0)\ntrack!(tracker::CoreTracker, x₁::AbstractVector, t₁::Number, t₀::Number)\ninit!(tracker::CoreTracker, x₁::AbstractVector, t₁::Number, t₀::Number)","category":"page"},{"location":"core_tracker/#HomotopyContinuation.track","page":"Core Tracker","title":"HomotopyContinuation.track","text":"track(tracker::CoreTracker, x₁, t₁=1.0, t₀=0.0)::CoreTrackerResult\n\nTrack a value x₁ from t₁ to t₀ using the given CoreTracker tracker. This returns a CoreTrackerResult. This modifies tracker. See track! for the possible options. To investigate the behaviour of a particular take a look at path_info.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.track!-Tuple{CoreTracker,AbstractArray{T,1} where T,Number,Number}","page":"Core Tracker","title":"HomotopyContinuation.track!","text":"track!(tracker::CoreTracker, x₁, t₁=1.0, t₀=0.0)::CoreTrackerStatus.states\n\nTrack a value x₁ from t₁ to t₀ using the given CoreTracker tracker. Returns one of the enum values of CoreTrackerStatus indicating the status. Check is_success and is_terminated to test for the status.\n\nIf setup_patch is true then init! is called at the beginning of the tracking.\n\ntrack!(x₀, tracker::CoreTracker, x₁, t₁=1.0, t₀=0.0)::CoreTrackerStatus.states\n\nAdditionally also stores the result in x₀ if the tracking was successfull.\n\n\n\n\n\n","category":"method"},{"location":"core_tracker/#HomotopyContinuation.init!-Tuple{CoreTracker,AbstractArray{T,1} where T,Number,Number}","page":"Core Tracker","title":"HomotopyContinuation.init!","text":"init!(tracker::CT, x₁, t₁, t₀;\n  setup_patch::Bool = tracker.options.update_patch,\n  loop::Bool = false,\n  check_start_value::Bool = !loop)\n\nSetup tracker to track x₁ from t₁ to t₀. Use this if you want to use the tracker as an iterator.\n\n\n\n\n\n","category":"method"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"It is also possible to use a CoreTracker as an iterator. This can either be done by the high level iterator method or by directly using a CoreTracker as an iterator. The recommend approach is to simply use iterator.","category":"page"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"iterator","category":"page"},{"location":"core_tracker/#HomotopyContinuation.iterator","page":"Core Tracker","title":"HomotopyContinuation.iterator","text":"iterator(tracker::CoreTracker, x₁, t₁=1.0, t₀=0.0; affine=true)\n\nPrepare a tracker to make it usable as a (stateful) iterator. Use this if you want to inspect a specific path. In each iteration the tuple (x,t) is returned. If affine == true then x is the affine solution (internally we compute in projective space).\n\nExample\n\nAssume you have CoreTracker tracker and you wan to track x₁ from 1.0 to 0.25:\n\nfor (x,t) in iterator(tracker, x₁, 1.0, 0.25)\nprintln(\"x at t=$t:\")\nprintln(x)\nend\n\nNote that this is a stateful iterator. You can still introspect the state of the tracker. For example to check whether the tracker was successfull (and did not terminate early due to some problem) you can do\n\nprintln(\"Success: \", status(tracker) == CoreTrackerStatus.success)\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#Introspecting-the-current-state-1","page":"Core Tracker","title":"Introspecting the current state","text":"","category":"section"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"To introspect the current state we provide the following routines.","category":"page"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"current_x\ncurrent_t\ncurrent_Δt\nsteps\nstatus\nLinearAlgebra.cond(::CoreTracker)\noptions","category":"page"},{"location":"core_tracker/#HomotopyContinuation.current_x","page":"Core Tracker","title":"HomotopyContinuation.current_x","text":"current_x(tracker::CoreTracker)\n\nReturn the current value of x.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.current_t","page":"Core Tracker","title":"HomotopyContinuation.current_t","text":"current_t(tracker::CoreTracker)\n\nCurrent t.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.current_Δt","page":"Core Tracker","title":"HomotopyContinuation.current_Δt","text":"current_Δt(tracker::CoreTracker)\n\nCurrent step_size Δt.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.steps","page":"Core Tracker","title":"HomotopyContinuation.steps","text":"steps(tracker::CoreTracker)\n\nCurrent number of steps.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.status","page":"Core Tracker","title":"HomotopyContinuation.status","text":"status(tracker::CoreTracker)\n\nCurrent status.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#LinearAlgebra.cond-Tuple{CoreTracker}","page":"Core Tracker","title":"LinearAlgebra.cond","text":"LinearAlgebra.cond(tracker::CoreTracker)\n\nReturns the currently computed approximation of the condition number of the Jacobian.\n\n\n\n\n\n","category":"method"},{"location":"core_tracker/#HomotopyContinuation.options","page":"Core Tracker","title":"HomotopyContinuation.options","text":"options(tracker::CoreTracker)\n\nReturns the options used in the tracker.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#Changing-options-1","page":"Core Tracker","title":"Changing options","text":"","category":"section"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"To change settings","category":"page"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"accuracy(::CoreTracker)\nset_accuracy!\nmax_corrector_iters\nset_max_corrector_iters!\nmax_step_size\nset_max_step_size!","category":"page"},{"location":"core_tracker/#HomotopyContinuation.accuracy-Tuple{CoreTracker}","page":"Core Tracker","title":"HomotopyContinuation.accuracy","text":"accuracy(tracker::CoreTracker)\n\nCurrent accuracy.\n\n\n\n\n\n","category":"method"},{"location":"core_tracker/#HomotopyContinuation.set_accuracy!","page":"Core Tracker","title":"HomotopyContinuation.set_accuracy!","text":"set_accuracy!(tracker::CoreTracker, accuracy)\n\nSet the current accuracy to accuracy.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.max_corrector_iters","page":"Core Tracker","title":"HomotopyContinuation.max_corrector_iters","text":"max_corrector_iters(tracker::CoreTracker)\n\nCurrent correction max_steps.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.set_max_corrector_iters!","page":"Core Tracker","title":"HomotopyContinuation.set_max_corrector_iters!","text":"setmaxcorrector_iters!(tracker::CoreTracker, n)\n\nSet the correction max_steps to n.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.max_step_size","page":"Core Tracker","title":"HomotopyContinuation.max_step_size","text":"max_step_size (tracker::CoreTracker)\n\nCurrent maximal step size.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.set_max_step_size!","page":"Core Tracker","title":"HomotopyContinuation.set_max_step_size!","text":"set_max_corrector_iters!(tracker::CoreTracker, Δs)\n\nSet the maximal step size to Δs.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#Deprecated-1","page":"Core Tracker","title":"Deprecated","text":"","category":"section"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"The following functions are deprecated.","category":"page"},{"location":"core_tracker/#","page":"Core Tracker","title":"Core Tracker","text":"max_refinement_iters\nset_max_refinement_iters!\nrefinement_accuracy\nset_refinement_accuracy!","category":"page"},{"location":"core_tracker/#HomotopyContinuation.max_refinement_iters","page":"Core Tracker","title":"HomotopyContinuation.max_refinement_iters","text":"max_refinement_iters(tracker::CoreTracker)\n\nCurrent refinement max_steps.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.set_max_refinement_iters!","page":"Core Tracker","title":"HomotopyContinuation.set_max_refinement_iters!","text":"set_max_refinement_iters!(tracker::CoreTracker, n)\n\nSet the current refinement max_steps to n.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.refinement_accuracy","page":"Core Tracker","title":"HomotopyContinuation.refinement_accuracy","text":"refinement_accuracy(tracker::CoreTracker)\n\nCurrent refinement accuracy.\n\n\n\n\n\n","category":"function"},{"location":"core_tracker/#HomotopyContinuation.set_refinement_accuracy!","page":"Core Tracker","title":"HomotopyContinuation.set_refinement_accuracy!","text":"set_max_refinement_iters!(tracker::CoreTracker, accuracy)\n\nSet the current refinement accuracy to accuracy.\n\n\n\n\n\n","category":"function"},{"location":"input/#Input-1","page":"Input","title":"Input","text":"","category":"section"},{"location":"input/#","page":"Input","title":"Input","text":"The solve and monodromy_solve functions in HomotopyContinuation.jl accept multiple input formats for polynomial systems. These are","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"Arrays of polynomials following the MultivariatePolynomials interface. We export the @polyvar macro from the DynamicPolynomials package to create polynomials with the DynamicPolynomials implementation.\nSystems constructed with our own symbolic modeling language as implemented in the ModelKit module. We export the @var macro to create variables in this modeling language.\nSystems (resp. homotopies) following the AbstractSystem (resp. AbstractHomotopy) interface.","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"The difference between the MultivariatePolynomials and ModelKit input is best shown on an example. Assume we want to solve the polynomial system","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"F(xy) = beginbmatrix\n  (2x + 3y + 2)^2 (4x - 2y + 3) \n  (y - 4x - 5)^3 - 3x^2 + y^2\n endbmatrix = 0","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"Using the @polyvar macro from DynamicPolynomials we can do","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"@polyvar x y\nF = [\n  (2x + 3y + 2)^2 * (4x - 2y + 3),\n  (y - 4x - 5)^3 - 3x^2 + y^2\n]","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"2-element Array{Polynomial{true,Int64},1}:\n 16x³ + 40x²y + 12xy² - 18y³ + 44x² + 68xy + 3y² + 40x + 28y + 12    \n -64x³ + 48x²y - 12xy² + y³ - 243x² + 120xy - 14y² - 300x + 75y - 125","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"We see that our expression got automatically expanded into a monomial basis. Sometimes this is very useful, but for the fast evaluation of a polynomial system this is not so useful! Here, ModelKit comes into play.","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"@var x y\nF = [\n  (2x + 3y + 2)^2 * (4x - 2y + 3),\n  (y - 4x - 5)^3 - 3x^2 + y^2\n]","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"2-element Array{HomotopyContinuation.ModelKit.Operation,1}:\n (2x + 3y + 2) ^ 2 * ((4x - 2y) + 3)     \n (((y - 4x) - 5) ^ 3 - 3 * x ^ 2) + y ^ 2","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"Compared to the polynomial input we see that it doesn't forget the structure of the input.","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"For the internal computations both formulations will be converted into efficient straight line programs. However, from the polynomial formulation we will not be able to recover the actual formulation of the problem and therefore the generated straight line program will be less efficient than the one created by ModelKit.","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"However, there are also cases where the polynomial input is preferable. An example is when you only have an expression of your polynomial system in the monomial basis. In this case the polynomial input will generate more efficient code since it is more optimized for this case.","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"Besides the different macros to generate variables both packages provide a common set of helpful functions for modeling problems:","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"variables(f, parameters = []) to obtain a list of all variables.\nnvariables(f, parameters = []) to obtain the number of variables.\ndifferentiate(f, vars) to compute the gradient with respect to the given variables\nsubs(f, var => expr) to substitute variables with expressions\nmonomials(vars, d; homogenous = false) create all monomials of degree up to d (resp. exactly degree d if homogenous = true)","category":"page"},{"location":"input/#","page":"Input","title":"Input","text":"warning: Variable ordering\nWhile MultivariatePolynomials orders variables in the order of creation, ModelKit orders them alphabetically. Also in ModelKit two variables with the same name are always identical.","category":"page"},{"location":"input/#ModelKit-1","page":"Input","title":"ModelKit","text":"","category":"section"},{"location":"input/#","page":"Input","title":"Input","text":"ModelKit.@var\nModelKit.@unique_var\nModelKit.System\nModelKit.Homotopy\nModelKit.compile","category":"page"},{"location":"input/#HomotopyContinuation.ModelKit.@var","page":"Input","title":"HomotopyContinuation.ModelKit.@var","text":"@var(args...)\n\nDeclare variables with the given and automatically create the variable bindings.\n\nExamples\n\njulia> @var a b x[1:2] y[1:2,1:3]\n(a, b, Variable[x₁, x₂], Variable[y₁₋₁ y₁₋₂ y₁₋₃; y₂₋₁ y₂₋₂ y₂₋₃])\n\njulia> a\na\n\njulia> b\nb\n\njulia> x\n2-element Array{Variable,1}:\n x₁\n x₂\n\njulia> y\n2×3 Array{Variable,2}:\n y₁₋₁  y₁₋₂  y₁₋₃\n y₂₋₁  y₂₋₂  y₂₋₃\n\n\n\n\n\n","category":"macro"},{"location":"input/#HomotopyContinuation.ModelKit.@unique_var","page":"Input","title":"HomotopyContinuation.ModelKit.@unique_var","text":"@unique_var(args...)\n\nDeclare variables and automatically create the variable bindings to the given names. This will change the names of the variables to ensure uniqueness.\n\nExamples\n\njulia> @unique_var a b\n(##a#591, ##b#592)\n\njulia> a\n##a#591\n\njulia> b\n##b#592\n\n\n\n\n\n","category":"macro"},{"location":"input/#HomotopyContinuation.ModelKit.System","page":"Input","title":"HomotopyContinuation.ModelKit.System","text":"System(exprs, vars, parameters = Variable[])\n\nCreate a system from the given exprs. vars are the given variables and determines the variable ordering.\n\nExample\n\njulia> @var x y;\njulia> H = System([x^2, y^2], [y, x]);\njulia> H([2, 3], 0)\n2-element Array{Int64,1}:\n 4\n 9\n\nIt is also possible to declare additional variables.\n\njulia> @var x y t a b;\njulia> H = Homotopy([x^2 + a, y^2 + b^2], [x, y], [a, b]);\njulia> H([2, 3], [5, 2])\n2-element Array{Int64,1}:\n 9\n 13\n\n\n\n\n\n","category":"type"},{"location":"input/#HomotopyContinuation.ModelKit.Homotopy","page":"Input","title":"HomotopyContinuation.ModelKit.Homotopy","text":"Homotopy(exprs, vars, t, parameters = Variable[])\n\nCreate a homotopy from the given exprs. vars are the given variables and determines the variable ordering, t is the dedicated variable along which is \"homotopied\".\n\nExample\n\njulia> @var x y t;\njulia> H = Homotopy([x + t, y + 2t], [y, x], t);\njulia> H([2, 3], 0)\n2-element Array{Int64,1}:\n 3\n 2\n\n\njulia> H([2, 3], 1)\n2-element Array{Int64,1}:\n 4\n 4\n\nIt is also possible to declare additional variables.\n\njulia> @var x y t a b;\njulia> H = Homotopy([x^2 + t*a, y^2 + t*b], [x, y], t, [a, b]);\njulia> H([2, 3], 1, [5, 2])\n2-element Array{Int64,1}:\n 9\n 11\n\n\n\n\n\n","category":"type"},{"location":"input/#HomotopyContinuation.ModelKit.compile","page":"Input","title":"HomotopyContinuation.ModelKit.compile","text":"compile(F::System)\ncompile(H::Homotopy)\n\nCompile the given object to a straight line program.\n\n\n\n\n\n","category":"function"},{"location":"monodromy/#Solving-parametrized-systems-with-monodromy-1","page":"Solving parametrized systems with monodromy","title":"Solving parametrized systems with monodromy","text":"","category":"section"},{"location":"monodromy/#","page":"Solving parametrized systems with monodromy","title":"Solving parametrized systems with monodromy","text":"Next to solve, HomotopyContinuation.jl provides the function monodromy_solve. Instead of taking two systems f and g and tracking an array of start solutions from f to g, monodromy_solve takes as input a single system with parameters p and together with a start solution s. Then by tracking s around loops in the parameters p, monodromy_solve tries to find new solutions until a stopping criterion is reached. Make sure to check out our monodromy guide for a more in depth introduction into this method.","category":"page"},{"location":"monodromy/#Basic-usage-1","page":"Solving parametrized systems with monodromy","title":"Basic usage","text":"","category":"section"},{"location":"monodromy/#","page":"Solving parametrized systems with monodromy","title":"Solving parametrized systems with monodromy","text":"monodromy_solve","category":"page"},{"location":"monodromy/#HomotopyContinuation.monodromy_solve","page":"Solving parametrized systems with monodromy","title":"HomotopyContinuation.monodromy_solve","text":"monodromy_solve(F, [sols, p]; parameters=..., options..., pathtrackerkwargs...)\n\nSolve a polynomial system F(x;p) with specified parameters and initial solutions sols by monodromy techniques. This makes loops in the parameter space of F to find new solutions. If F the parameters p only occur linearly in F it is eventually possible to compute a start pair (x₀ p₀) automatically. In this case sols and p can be omitted and the automatically generated parameters can be obtained with the parameters function from the MonodromyResult.\n\nOptions\n\ncheck_startsolutions=true: If true, we do a Newton step for each entry of solsfor checking if it is a valid startsolutions. Solutions which are not valid are sorted out.\ndistance_function=euclidean_distance: The distance function used for UniquePoints.\ndone_callback=always_false: A callback to end the computation early. This function takes 2 arguments. The first one is the new solution x and the second one are all current solutions (including x). Return true if the compuation is done.\nequivalence_classes=true: This only applies if there is at least one group action supplied. We then consider two solutions in the same equivalence class if we can transform one to the other by the supplied group actions. We only track one solution per equivalence class.\nidentical_tol::Float64=1e-6: The tolerance with which it is decided whether two solutions are identical.\ngroup_action=nothing: A function taking one solution and returning other solutions if there is a constructive way to obtain them, e.g. by symmetry.\ngroup_actions=nothing: If there is more than one group action you can use this to chain the application of them. For example if you have two group actions foo and bar you can set group_actions=[foo, bar]. See GroupActions for details regarding the application rules.\nmax_loops_no_progress::Int=10: The maximal number of iterations (i.e. loops generated) without any progress.\nmin_solutions: The minimal number of solutions before a stopping heuristic is applied. By default this is half of target_solutions_count if applicable otherwise 1.\nparameter_sampler=independent_normal: A function taking the parameter p and returning a new random parameter q. By default each entry of the parameter vector is drawn independently from the univariate normal distribution.\nresuse_loops::Symbol=:all: Strategy to reuse other loops for new found solutions. :all propagates a new solution through all other loops, :random picks a random loop, :none doesn't reuse a loop.\nshow_progress=true: Enable a progress meter.\nstrategy: The strategy used to create loops. If F only depends linearly on p this will be Petal. Otherwise this will be Triangle with weights if F is a real system.\ntarget_solutions_count=nothing: The computations are stopped if this number of solutions is reached.\nthreading = true: Enable multithreading of the path tracking.\ntimeout=float(typemax(Int)): The maximal number of seconds the computation is allowed to run.\n\n\n\n\n\n","category":"function"},{"location":"monodromy/#Monodromy-Result-1","page":"Solving parametrized systems with monodromy","title":"Monodromy Result","text":"","category":"section"},{"location":"monodromy/#","page":"Solving parametrized systems with monodromy","title":"Solving parametrized systems with monodromy","text":"A call to monodromy_solve returns a MonodromyResult:","category":"page"},{"location":"monodromy/#","page":"Solving parametrized systems with monodromy","title":"Solving parametrized systems with monodromy","text":"MonodromyResult","category":"page"},{"location":"monodromy/#HomotopyContinuation.MonodromyResult","page":"Solving parametrized systems with monodromy","title":"HomotopyContinuation.MonodromyResult","text":"MonodromyResult\n\nThe monodromy result contains the result of the monodromy_solve computation.\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#Analyse-a-MonodromyResult-1","page":"Solving parametrized systems with monodromy","title":"Analyse a MonodromyResult","text":"","category":"section"},{"location":"monodromy/#","page":"Solving parametrized systems with monodromy","title":"Solving parametrized systems with monodromy","text":"solutions(::MonodromyResult)\nparameters(::MonodromyResult)","category":"page"},{"location":"monodromy/#HomotopyContinuation.solutions-Tuple{MonodromyResult}","page":"Solving parametrized systems with monodromy","title":"HomotopyContinuation.solutions","text":"solutions(result::MonodromyResult; only_real=false, real_tol=1e-6)\n\nReturn all solutions (as SVectors) for which the given conditions apply.\n\nExample\n\nreal_solutions = solutions(R, only_real=true)\n\n\n\n\n\n","category":"method"},{"location":"monodromy/#HomotopyContinuation.parameters-Tuple{MonodromyResult}","page":"Solving parametrized systems with monodromy","title":"HomotopyContinuation.parameters","text":"parameters(r::MonodromyResult)\n\nReturn the parameters corresponding to the given result r.\n\n\n\n\n\n","category":"method"},{"location":"monodromy/#Verification-of-completeness-1","page":"Solving parametrized systems with monodromy","title":"Verification of completeness","text":"","category":"section"},{"location":"monodromy/#","page":"Solving parametrized systems with monodromy","title":"Solving parametrized systems with monodromy","text":"It is possible to verify after the computation that monodromy_solve has found all solutions.","category":"page"},{"location":"monodromy/#","page":"Solving parametrized systems with monodromy","title":"Solving parametrized systems with monodromy","text":"verify_solution_completeness\nsolution_completeness_witnesses","category":"page"},{"location":"monodromy/#HomotopyContinuation.verify_solution_completeness","page":"Solving parametrized systems with monodromy","title":"HomotopyContinuation.verify_solution_completeness","text":"verify_solution_completeness(F, res::MonodromyResult;\n                             parameters=..., trace_tol=1e-6, options...)\n\nVerify that the monodromy computation found all solutions by monodromy_solve. This uses a trace test as described in [LRS18]. The trace is a numerical value which is 0 if all solutions are found, for this the trace_tol keyword argument is used. The function returns nothing if some computation couldn't be carried out. Otherwise returns a boolean. Note that this function requires the computation of solutions to another polynomial system using monodromy. This routine can return false although all solutions are found if this additional solution set is not complete. The options... arguments can be everything which is accepted by solve and monodromy_solve.\n\nExample\n\njulia> @polyvar x y a b c;\n\njulia> f = x^2+y^2-1;\n\njulia> l = a*x+b*y+c;\n\njulia> res = monodromy_solve([f,l], [-0.6-0.8im, -1.2+0.4im], [1,2,3]; parameters=[a,b,c])\nMonodromyResult\n==================================\n• 2 solutions (0 real)\n• return code → heuristic_stop\n• 44 tracked paths\n• seed → 367230\n\njulia> verify_solution_completeness([f,l], res; parameters=[a,b,c], trace_tol = 1e-8)\n[ Info: Compute additional witnesses for completeness...\n[ Info: Found 2 additional witnesses\n[ Info: Compute trace...\n[ Info: Norm of trace: 1.035918995391323e-15\ntrue\n\nverify_solution_completeness(F, S, p; parameters=..., kwargs...)\n\nVerify the solution completeness using the computed solutions S to the parameter p.\n\nverify_solution_completeness(TTS, S, W₁₀, p₀::Vector{<:Number}, l₀)\n\nUse the already computeded additional witnesses W₁₀. You want to obtain TTS, W₁₀ and l₀ as the output from solution_completeness_witnesses.\n\n[LRS18]: Leykin, Anton, Jose Israel Rodriguez, and Frank Sottile. \"Trace test.\" Arnold Mathematical Journal 4.1 (2018): 113-125.\n\n\n\n\n\n","category":"function"},{"location":"monodromy/#HomotopyContinuation.solution_completeness_witnesses","page":"Solving parametrized systems with monodromy","title":"HomotopyContinuation.solution_completeness_witnesses","text":"solution_completeness_witnesses(F, S, p; parameters=..., kwargs...)\n\nCompute the additional necessary witnesses. Returns a triple (W₁₀, TTS, l) containing the additional witnesses W₁₀, a trace test system TTS and the parameters l for TTS.\n\n\n\n\n\n","category":"function"},{"location":"monodromy/#Group-actions-1","page":"Solving parametrized systems with monodromy","title":"Group actions","text":"","category":"section"},{"location":"monodromy/#","page":"Solving parametrized systems with monodromy","title":"Solving parametrized systems with monodromy","text":"If there is a group acting on the solution set of the polynomial system this can provided with the group_action keyword for single group actions or with the group_actions keyword for compositions of group actions. These will be internally transformed into GroupActions.","category":"page"},{"location":"monodromy/#","page":"Solving parametrized systems with monodromy","title":"Solving parametrized systems with monodromy","text":"GroupActions","category":"page"},{"location":"monodromy/#HomotopyContinuation.GroupActions","page":"Solving parametrized systems with monodromy","title":"HomotopyContinuation.GroupActions","text":"GroupActions(actions::Function...)\n\nStore a bunch of group actions (f1, f2, f3, ...). Each action has to return a tuple. The actions are applied in the following sense\n\nf1 is applied on the original solution s\nf2 is applied on s and the results of 1\nf3 is applied on s and the results of 1) and 2)\n\nand so on\n\nExample\n\njulia> f1(s) = (s * s,);\n\njulia> f2(s) = (2s, -s, 5s);\n\njulia> f3(s) = (s + 1,);\n\njulia> GroupActions(f1)(3)\n(3, 9)\n\njulia> GroupActions(f1, f2)(3)\n(3, 9, 6, -3, 15, 18, -9, 45)\n\njulia> GroupActions(f1,f2, f3)(3)\n(3, 9, 6, -3, 15, 18, -9, 45, 4, 10, 7, -2, 16, 19, -8, 46)\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#","page":"Solving parametrized systems with monodromy","title":"Solving parametrized systems with monodromy","text":"To help with the more common group actions we provide some helper functions:","category":"page"},{"location":"monodromy/#","page":"Solving parametrized systems with monodromy","title":"Solving parametrized systems with monodromy","text":"SymmetricGroup","category":"page"},{"location":"monodromy/#HomotopyContinuation.SymmetricGroup","page":"Solving parametrized systems with monodromy","title":"HomotopyContinuation.SymmetricGroup","text":"SymmetricGroup(n)\n\nGroup action of the symmetric group S(n).\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#Strategies-1","page":"Solving parametrized systems with monodromy","title":"Strategies","text":"","category":"section"},{"location":"monodromy/#","page":"Solving parametrized systems with monodromy","title":"Solving parametrized systems with monodromy","text":"Triangle\nPetal","category":"page"},{"location":"monodromy/#HomotopyContinuation.Triangle","page":"Solving parametrized systems with monodromy","title":"HomotopyContinuation.Triangle","text":"Triangle(;useweights=true)\n\nA triangle is a loop consisting of the main node and two addtional nodes. If weights is true the edges are equipped with additional random weights. Note that this is usually only necessary for real parameters.\n\n\n\n\n\n","category":"type"},{"location":"monodromy/#HomotopyContinuation.Petal","page":"Solving parametrized systems with monodromy","title":"HomotopyContinuation.Petal","text":"Petal()\n\nA petal is a loop consisting of the main node and one other node connected by two edges with different random weights.\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#Path-Tracker-1","page":"Path Tracker","title":"Path Tracker","text":"","category":"section"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"The solve routine is only a thin wrapper around PathTracker. Therefore you can also use PathTracker directly. This is for example a good choice if you have to solve the same problem many times.","category":"page"},{"location":"path_tracker/#Basic-usage-1","page":"Path Tracker","title":"Basic usage","text":"","category":"section"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"PathTracker","category":"page"},{"location":"path_tracker/#HomotopyContinuation.PathTracker","page":"Path Tracker","title":"HomotopyContinuation.PathTracker","text":"PathTracker\n\nThe PathTracker combines the path tracking (with CoreTracker) with an endgame routine. The endgame  is the name for special algorithms the end of the path tracking. These enable to detect if a path is diverging or if it ends in a singular solution. The PathTracker is more opinionated than the CoreTracker and implements additional logic to handle numerical difficult solutions. In particular it always reparametrizes a solution path to use a logarithmic time scale, i.e., x(t)  x(e^-s) and we track for s from 0 to .\n\nIn order to construct a PathTracker it is recommended to use the pathtracker and pathtracker_startsolutions helper functions. With a PathTracker constructed you can track a single path using the track method. The result of this will be a PathResult.\n\nThe PathTracker assumes that the provided homotopy H is defined in such a way that H(x,1) is the start system and H(x,0) the target system. During the path tracking an approximation of the valuation of a Puiseux series expansion of the solution is computed. This is used to decide whether a path is diverging. Before a certain treshold (s_always_consider_valuation) this approximation is only trusted if a path gives some sign of ill-conditioning. To compute singular solutions the Cauchy endgame is used which is based on Cauchy's integral formula. For this we have to track solutions along a loop around the origin. The number of loops necessary to arrive back at the start point is called the winding number.\n\nOptions\n\nThe path tracker accepts all options which CoreTracker accepts. Furthermore the following options are accepted:\n\nat_infinity_check: This is true if the provided start system is an affine polynomial system.\nendgame_start (default 2.0): The value of s where the endgame is started earliest.\nmax_winding_number (default 12): The maximal winding number tried in the Cauchy endgame.\nmin_accuracy (default 1e-5): The PathTracker automatically lowers the desired accuracy automatically to min_accuracy if path tracking would fail othwerwise (since the desired cannot be reached)\nmin_cond_eg (default 1e5): The minimal condition number before the Cauchy endgame is started or a path is cut off.\nmin_step_size_before_eg (default exp2(-40)): The minimal allowed step size before the endgame starts.\nmin_step_size_eg (default exp2(-120)): The minimal allowed step size during the endgame. This is also control what is considered ∞ for the path tracking.\ns_always_consider_valuation (default -log(1e-16)) A threshold after which we always consider the valuation.\nsamples_per_loop (default8`): The number of samples used during the endgame.\nprecision_strategy (default :adaptive_finite): This controls whether H(x,t) is possibly evaluated with higher than machine precision during the endgame (the Jacobian is always computed with machine precision). The :adaptive_finite allows this only if we are optimistic that we can still obtain a finite solution. Other options are :adaptive_never where this is never allowed and :adaptive_always where it is always enabled. ``\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"The easiest way to construct a PathTracker:","category":"page"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"pathtracker_startsolutions\npathtracker","category":"page"},{"location":"path_tracker/#HomotopyContinuation.pathtracker_startsolutions","page":"Path Tracker","title":"HomotopyContinuation.pathtracker_startsolutions","text":"pathtracker_startsolutions(args...; kwargs...)\n\nConstruct a PathTracker and start solutions in the same way solve does it. This also takes the same input arguments as solve. This is convenient if you want to investigate single paths.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.pathtracker","page":"Path Tracker","title":"HomotopyContinuation.pathtracker","text":"pathtracker(args...; kwargs...)\n\nConstruct a PathTracker in the same way solve does it. This also takes the same input arguments as solve with the exception that you do not need to specify startsolutions.\n\nExamples\n\nObtain single solution\n\nWe want to construct a path tracker to track a parametrized system f with parameters p from the parameters a to b.\n\ntracker = pathtracker(f, parameters=p, p₁=a, p₀=b)\n\nYou then can obtain a single solution at b by using\n\nx_b = solution(track(tracker, x_a))\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"To track a single path you can use the track and track! methods.","category":"page"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"track(tracker::PathTracker, x₁)","category":"page"},{"location":"path_tracker/#HomotopyContinuation.track-Tuple{PathTracker,Any}","page":"Path Tracker","title":"HomotopyContinuation.track","text":"track(tracker::PathTracker, x₁;\n        path_number=nothing,\n        details::Symbol=:default,\n        start_parameters = nothing,\n        target_parameters = nothing)\n\nTrack the path x(t) with start solution x₁ from 1 towards 0. Returns a PathResult.\n\nThe details options controls the level of details of the informations available in the PathResult. If tracker uses a parameter homotopy you can set the start and target parameters by setting the corresponding fields. To investigate the behaviour of a particular take a look at path_info.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#PathResult-1","page":"Path Tracker","title":"PathResult","text":"","category":"section"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"For each path we return a PathResult containing the detailed information about the single path.","category":"page"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"PathResult","category":"page"},{"location":"path_tracker/#HomotopyContinuation.PathResult","page":"Path Tracker","title":"HomotopyContinuation.PathResult","text":"PathResult{V<:AbstractVector}\n\nA PathResult is the result of tracking of a path with track using a PathTracker.\n\nFields\n\nreturn_code: See the list of return codes below.\nsolution::V: The solution vector.\nt::Float64: The value of t at which solution was computed. Note that if return_code is :at_infinity, then t is the value when this was decided.\naccuracy::Float64: An approximation of x-x where x is the computed solution and x is the true solution.\nresidual::Float64: The value of the infinity-norm of H(solution, 0).\nmultiplicity::Union{Nothing, Int} is the multiplicity of the solution. This is only assigned by singular.\ncondition_jacobian::Union{Nothing, Float64}: This is the condition number of the row-equilibrated Jacobian at the solution. A high condition number indicates a singularity.\nwinding_number:Union{Nothing, Int}: The estimated winding number. This is a lower bound on the multiplicity of the solution.\nstart_solution::Union{Nothing, Int}: The start solution of the path.\naccepted_steps::Int: The number of accepted steps during the path tracking.\nrejected_steps::Int: The number of rejected steps during the path tracking.\nvaluation::Union{Nothing, Vector{Float64}}: An approximation of the valuation of the Puiseux series expansion of x(t).\nvaluation_accuracy::Union{Nothing, Vector{Float64}}: An estimate of the accuracy of the valuation of the Puiseux series expansion of x(t).\n\nReturn codes\n\nThese is the list of possible return codes:\n\n:success: The PathTracker obtained a solution.\n:at_infinity: The PathTracker stopped the tracking of the path since it determined that that path is diverging towards infinity.\n:terminated_callback: One of the optional PathTracker callbacks terminated the tracking.\n:terminated_max_iters: The PathTracker terminated since it reached the limit accuracy.\n:terminated_invalid_startvalue: The PathTracker terminated since the provided start value is invalid.\n:terminated_step_size_too_small: The PathTracker terminated since the step size became smaller than the provided threshold.\n:terminated_accuracy_limit: The PathTracker terminated since the problem was too ill-conditioned to be tracked further with the desired minimal accuracy.\n:terminated_ill_conditioned: The PathTracker terminated since the Jacobian of the homotopy was too ill-conditioned.\n:post_check_failed: The verification of a non-singular solution failed.\n\nConstructors\n\n PathResult(tracker::PathTracker,\n            start_solution=nothing,\n            path_number::Union{Nothing,Int}=nothing;\n            details=:default)\n\nConstruct a PathResult using the current state of the PathTracker. Possible values for details are :minimal (minimal details), :default (default) and :extensive (all information possible).\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"The following helper functions are provided","category":"page"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"solution(::PathResult)\naccuracy(::PathResult)\nresidual(::PathResult)\nwinding_number(tracker::PathTracker)\nmultiplicity(::PathResult)\ncondition_jacobian(::PathResult)\nLinearAlgebra.cond(::PathResult)\nstart_solution(::PathResult)\nis_real(::PathResult)\nis_success(::PathResult)\nis_failed(::PathResult)\nis_affine(::PathResult)\nis_projective(r::PathResult)\nis_at_infinity(::PathResult)\nis_singular(::PathResult)\nis_nonsingular(::PathResult)","category":"page"},{"location":"path_tracker/#HomotopyContinuation.solution-Tuple{PathResult}","page":"Path Tracker","title":"HomotopyContinuation.solution","text":"solution(r::PathResult)\n\nGet the solution of the path.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.accuracy-Tuple{PathResult}","page":"Path Tracker","title":"HomotopyContinuation.accuracy","text":"accuracy(r::PathResult)\n\nGet the accuracy of the solution. This is an estimate of the (relative) distance to the true solution.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.residual-Tuple{PathResult}","page":"Path Tracker","title":"HomotopyContinuation.residual","text":"residual(r::PathResult)\n\nGet the residual of the solution x of the path, i.e., H(x 0)₂.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.winding_number-Tuple{PathTracker}","page":"Path Tracker","title":"HomotopyContinuation.winding_number","text":"winding_number(tracker::PathTracker)\n\nObtain the estimate of the winding number computed by the PathTracker. Returns nothing if the Cauchy endgame was not run.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.multiplicity-Tuple{PathResult}","page":"Path Tracker","title":"HomotopyContinuation.multiplicity","text":"multiplicity(P::PathResult)\n\nReturns the multiplicity of P.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.condition_jacobian-Tuple{PathResult}","page":"Path Tracker","title":"HomotopyContinuation.condition_jacobian","text":"condition_jacobian(r::PathResult)\n\nReturn the condition number of the Jacobian of the result.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#LinearAlgebra.cond-Tuple{PathResult}","page":"Path Tracker","title":"LinearAlgebra.cond","text":"cond(r::PathResult)\n\nReturn the condition number of the Jacobian of the result.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.start_solution-Tuple{PathResult}","page":"Path Tracker","title":"HomotopyContinuation.start_solution","text":"start_solution(r::PathResult)\n\nGet the start solution of the path.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.is_real-Tuple{PathResult}","page":"Path Tracker","title":"HomotopyContinuation.is_real","text":"is_real(r::PathResult; tol=1e-6)\n\nWe consider a result as real if the 2-norm of the imaginary part of the solution is at most tol.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.is_success-Tuple{PathResult}","page":"Path Tracker","title":"HomotopyContinuation.is_success","text":"is_success(r::PathResult)\n\nChecks whether the path is successfull.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.is_failed-Tuple{PathResult}","page":"Path Tracker","title":"HomotopyContinuation.is_failed","text":"is_failed(r::PathResult)\n\nChecks whether the path failed.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.is_affine-Tuple{PathResult}","page":"Path Tracker","title":"HomotopyContinuation.is_affine","text":"is_affine(pathresult)\n\nReturn`s true if the solution is an affine vector.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.is_projective-Tuple{PathResult}","page":"Path Tracker","title":"HomotopyContinuation.is_projective","text":"is_projective(r::PathResult)\n\nReturn`s true if the solution is a projective vector.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.is_at_infinity-Tuple{PathResult}","page":"Path Tracker","title":"HomotopyContinuation.is_at_infinity","text":"is_at_infinity(r::PathResult)\n\nChecks whether the path goes to infinity.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.is_singular-Tuple{PathResult}","page":"Path Tracker","title":"HomotopyContinuation.is_singular","text":"is_singular(r::PathResult; tol=1e10)\n\nChecks whether the path result is singular. This is true if the multiplicity is larger than  1 or if the condition number of the Jacobian is larger than tol.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.is_nonsingular-Tuple{PathResult}","page":"Path Tracker","title":"HomotopyContinuation.is_nonsingular","text":"is_nonsingular(r::PathResult; tol=1e10)\n\nChecks whether the path result is non-singular. This is true if it is not singular.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#Low-level-API-1","page":"Path Tracker","title":"Low-level API","text":"","category":"section"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"track!(tracker::PathTracker, x₁)","category":"page"},{"location":"path_tracker/#HomotopyContinuation.track!-Tuple{PathTracker,Any}","page":"Path Tracker","title":"HomotopyContinuation.track!","text":"track!(tracker::PathTracker, x₁)::PathTrackerStatus.states\n\nTrack the path x(t) with start solution x₁ from 1 towards 0. Returns a PathTrackerStatus.states.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"In the case that you track paths of parameter homotopy you can also change the parameters using","category":"page"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"start_parameters!(::PathTracker, p)\ntarget_parameters!(::PathTracker, p)","category":"page"},{"location":"path_tracker/#HomotopyContinuation.start_parameters!-Tuple{PathTracker,Any}","page":"Path Tracker","title":"HomotopyContinuation.start_parameters!","text":"start_parameters!(tracker::PathTracker, p)\n\nSet the start parameters of the homotopy in in tracker to p.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#HomotopyContinuation.target_parameters!-Tuple{PathTracker,Any}","page":"Path Tracker","title":"HomotopyContinuation.target_parameters!","text":"target_parameters!(tracker::PathTracker, p)\n\nSet the target parameters of the homotopy in in tracker to p.\n\n\n\n\n\n","category":"method"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"The return type of track! is a PathTrackerStatus.states:","category":"page"},{"location":"path_tracker/#","page":"Path Tracker","title":"Path Tracker","text":"PathTrackerStatus.states\nis_success\nis_at_infinity\nis_invalid_startvalue\nis_failed\nis_terminated_callback\nis_tracking","category":"page"},{"location":"path_tracker/#HomotopyContinuation.PathTrackerStatus.states","page":"Path Tracker","title":"HomotopyContinuation.PathTrackerStatus.states","text":"enum PathTrackerStatus\n\nThe possible states a PathTracker can be in:\n\nPathTrackerStatus.tracking\nPathTrackerStatus.success\nPathTrackerStatus.at_infinity\nPathTrackerStatus.excess_solution\nPathTrackerStatus.post_check_failed\nPathTrackerStatus.terminated_accuracy_limit\nPathTrackerStatus.terminated_ill_conditioned\nPathTrackerStatus.terminated_invalid_startvalue\nPathTrackerStatus.terminated_max_winding_number\nPathTrackerStatus.terminated_max_iters\nPathTrackerStatus.terminated_step_size_too_small\n\n\n\n\n\n","category":"type"},{"location":"path_tracker/#HomotopyContinuation.is_success","page":"Path Tracker","title":"HomotopyContinuation.is_success","text":"is_success(S::CoreTrackerStatus.states)\n\nReturns true if S indicates a success in the path tracking.\n\n\n\n\n\nis_success(result::CoreTrackerResult)\n\nReturns true if the path tracking was successfull.\n\n\n\n\n\nis_success(status::PathTrackerStatus.states)\n\nReturns true if status indicates a success in tracking.\n\n\n\n\n\nis_success(r::PathResult)\n\nChecks whether the path is successfull.\n\n\n\n\n\nis_success(result::MonodromyResult)\n\nReturns true if the monodromy computation achieved its target solution count.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.is_at_infinity","page":"Path Tracker","title":"HomotopyContinuation.is_at_infinity","text":"is_success(status::PathTrackerStatus.states)\n\nReturns true if status indicates that a path diverged towards infinity.\n\n\n\n\n\nis_at_infinity(r::PathResult)\n\nChecks whether the path goes to infinity.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.is_invalid_startvalue","page":"Path Tracker","title":"HomotopyContinuation.is_invalid_startvalue","text":"is_invalid_startvalue(S::CoreTrackerStatus.states)\n\nReturns true if S indicates that the path tracking got terminated since the start value was not a zero.\n\n\n\n\n\nis_invalid_startvalue(status::PathTrackerStatus.states)\n\nReturns true if the provided start value was not valid.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.is_failed","page":"Path Tracker","title":"HomotopyContinuation.is_failed","text":"is_failed(r::PathResult)\n\nChecks whether the path failed.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.is_terminated_callback","page":"Path Tracker","title":"HomotopyContinuation.is_terminated_callback","text":"is_terminated_callback(status::PathTrackerStatus.states)\n\nReturns true if the provided callback indicated a termination of the path.\n\n\n\n\n\n","category":"function"},{"location":"path_tracker/#HomotopyContinuation.is_tracking","page":"Path Tracker","title":"HomotopyContinuation.is_tracking","text":"is_tracking(S::CoreTrackerStatus.states)\n\nReturns true if S indicates that the path tracking is not yet finished.\n\n\n\n\n\nis_tracking(status::PathTrackerStatus.states)\n\nReturns true if status indicates the tracking is not going on.\n\n\n\n\n\n","category":"function"},{"location":"systems/#Data-structures-for-polynomial-systems-1","page":"Polynomial systems","title":"Data structures for polynomial systems","text":"","category":"section"},{"location":"systems/#","page":"Polynomial systems","title":"Polynomial systems","text":"Polynomial systems can be represented in numerous ways in a computer and each representation has certain tradeoffs. For our purposes the most important thing is that it is fast to evaluate the system. Therefore we automatically convert an input given by DynamicPolynomials to another representation more suitable for numerically evaluations. The default is currently FPSystem.","category":"page"},{"location":"systems/#Default-systems-1","page":"Polynomial systems","title":"Default systems","text":"","category":"section"},{"location":"systems/#","page":"Polynomial systems","title":"Polynomial systems","text":"We provide the following systems by default.","category":"page"},{"location":"systems/#","page":"Polynomial systems","title":"Polynomial systems","text":"FPSystem\nSPSystem\nFixedHomotopy\nFixedParameterSystem\nCompositionSystem","category":"page"},{"location":"systems/#HomotopyContinuation.FPSystem","page":"Polynomial systems","title":"HomotopyContinuation.FPSystem","text":"FPSystem(polynomials, vars) <: AbstractSystem\n\nCreate a polynomial system using the FixedPolynomials package.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.SPSystem","page":"Polynomial systems","title":"HomotopyContinuation.SPSystem","text":"SPSystem(polynomials, vars) <: AbstractSystem\n\nCreate a system using the StaticPolynomials package. Note that StaticPolynomials leverages Julias metaprogramming capabilities to automatically generate functions to evaluate the system and its Jacobian. These generated functions are very fast but at the cost of possibly large compile times. The compile time depends on the size of the support of the polynomial system. If you intend to solve a large system or you need to solve a system with the same support but different coefficients even large compile times can be worthwile. As a general rule of thumb this usually is twice as fast as solving the same system using FPSystem.\n\nExample\n\nYou can use SPSystem as follows with solve\n\n@polyvar x y\nF = [x^2+3y^4-2, 2y^2+3x*y+4]\nsolve(F, system=SPSystem)\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.FixedHomotopy","page":"Polynomial systems","title":"HomotopyContinuation.FixedHomotopy","text":"FixedHomotopy(H, t) <: AbstractSystem\n\nFix a homotopy H(x,t) at t\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.FixedParameterSystem","page":"Polynomial systems","title":"HomotopyContinuation.FixedParameterSystem","text":"FixedParameterSystem(F, p) <: AbstractSystem\n\nFix a parametrized system F(x; p) at p, i.e., it is treated as a system without parameters.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.CompositionSystem","page":"Polynomial systems","title":"HomotopyContinuation.CompositionSystem","text":"CompositionSystem(composition::Composition, systems_constructor) <: AbstractSystem\n\nA system representing the composition of polynomial maps.\n\n\n\n\n\n","category":"type"},{"location":"systems/#Interface-for-custom-systems-1","page":"Polynomial systems","title":"Interface for custom systems","text":"","category":"section"},{"location":"systems/#","page":"Polynomial systems","title":"Polynomial systems","text":"The great thing is that you are not limited to the systems provided by default. Maybe your polynomial system has a particular structure which you want to use to efficiently evaluate it. For this you can define your own homotopy by defining a struct with super type AbstractSystem. For this the following interface has to be defined.","category":"page"},{"location":"systems/#Types-1","page":"Polynomial systems","title":"Types","text":"","category":"section"},{"location":"systems/#","page":"Polynomial systems","title":"Polynomial systems","text":"AbstractSystem\nAbstractSystemCache\nSystemNullCache","category":"page"},{"location":"systems/#HomotopyContinuation.AbstractSystem","page":"Polynomial systems","title":"HomotopyContinuation.AbstractSystem","text":"AbstractSystem\n\nRepresenting a system of polynomials.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.AbstractSystemCache","page":"Polynomial systems","title":"HomotopyContinuation.AbstractSystemCache","text":"AbstractSystemCache\n\nA cache to avoid allocations for the evaluation of an AbstractSystem.\n\n\n\n\n\n","category":"type"},{"location":"systems/#HomotopyContinuation.SystemNullCache","page":"Polynomial systems","title":"HomotopyContinuation.SystemNullCache","text":"SystemNullCache\n\nAn empty cache if no cache is necessary.\n\n\n\n\n\n","category":"type"},{"location":"systems/#Mandatory-1","page":"Polynomial systems","title":"Mandatory","text":"","category":"section"},{"location":"systems/#","page":"Polynomial systems","title":"Polynomial systems","text":"The following methods are mandatory to implement.","category":"page"},{"location":"systems/#","page":"Polynomial systems","title":"Polynomial systems","text":"cache(F::AbstractSystem, args...)\nevaluate!(u, F::AbstractSystem, args...)\nevaluate(F::AbstractSystem, x, c::AbstractSystemCache=cache(F, x))\njacobian!(u, F::AbstractSystem, args...)\njacobian(F::AbstractSystem, x, c::AbstractSystemCache=cache(F, x))\nBase.size(::AbstractSystem)","category":"page"},{"location":"systems/#HomotopyContinuation.cache-Tuple{AbstractSystem,Vararg{Any,N} where N}","page":"Polynomial systems","title":"HomotopyContinuation.cache","text":"cache(F::AbstractSystem, x)::AbstractSystemCache\n\nCreate a cache for the evaluation (incl. Jacobian) of F with elements of the type of x.\n\ncache(F::AbstractSystem, x, p)::AbstractSystemCache\n\nCreate a cache for the evaluation (incl. Jacobian) of F with elements of the type of x and parameters p.\n\n\n\n\n\n","category":"method"},{"location":"systems/#HomotopyContinuation.evaluate!-Tuple{Any,AbstractSystem,Vararg{Any,N} where N}","page":"Polynomial systems","title":"HomotopyContinuation.evaluate!","text":"evaluate!(u, F::AbstractSystem, x, cache::AbstractSystemCache)\n\nEvaluate the system F at x and store the result in u.\n\nevaluate!(u, F::AbstractSystem, x, p, cache::AbstractSystemCache)\n\nEvaluate the system F at x and parameters p and store the result in u.\n\n\n\n\n\n","category":"method"},{"location":"systems/#HomotopyContinuation.evaluate","page":"Polynomial systems","title":"HomotopyContinuation.evaluate","text":"evaluate(F::AbstractSystem, x::AbstractVector, cache=cache(F, x))\n\nEvaluate the system F at x.\n\nevaluate(F::AbstractSystem, x::AbstractVector, p, cache=cache(F, x))\n\nEvaluate the system F at x and parameters p.\n\n\n\n\n\n","category":"function"},{"location":"systems/#HomotopyContinuation.jacobian!-Tuple{Any,AbstractSystem,Vararg{Any,N} where N}","page":"Polynomial systems","title":"HomotopyContinuation.jacobian!","text":"jacobian!(u, F::AbstractSystem, x , cache::AbstractSystemCache)\n\nEvaluate the Jacobian of the system F at x and store the result in u.\n\njacobian!(u, F::AbstractSystem, x , p, cache::AbstractSystemCache)\n\nEvaluate the Jacobian of the system F at x and parameters p and store the result in u.\n\n\n\n\n\n","category":"method"},{"location":"systems/#HomotopyContinuation.jacobian","page":"Polynomial systems","title":"HomotopyContinuation.jacobian","text":"jacobian(F::AbstractSystem, x, cache=cache(F, x))\n\nEvaluate the Jacobian of the system F at x.\n\njacobian(F::AbstractSystem, x , p, cache=cache(F, x))\n\nEvaluate the Jacobian of the system F at x and parameters p.\n\n\n\n\n\n","category":"function"},{"location":"systems/#Base.size-Tuple{AbstractSystem}","page":"Polynomial systems","title":"Base.size","text":"Base.size(F::AbstractSystem)\n\nReturns a tuple (m, n) indicating that F is a system of m polynomials m in n variables.\n\n\n\n\n\n","category":"method"},{"location":"systems/#","page":"Polynomial systems","title":"Polynomial systems","text":"Additionally if the system should support parameter homotopies it needs to support","category":"page"},{"location":"systems/#","page":"Polynomial systems","title":"Polynomial systems","text":"differentiate_parameters!\ndifferentiate_parameters","category":"page"},{"location":"systems/#HomotopyContinuation.differentiate_parameters!","page":"Polynomial systems","title":"HomotopyContinuation.differentiate_parameters!","text":"differentiate_parameters!(u, F::AbstractSystem, x, p, cache::AbstractSystemCache)\n\nEvaluate the Jacobian of the system F at x and parameters p w.r.t. the parameters and store the result in u.\n\n\n\n\n\n","category":"function"},{"location":"systems/#HomotopyContinuation.differentiate_parameters","page":"Polynomial systems","title":"HomotopyContinuation.differentiate_parameters","text":"differentiate_parameters(F::AbstractSystem, x, p, cache=cache(F, x))\n\nEvaluate the Jacobian of the system F at x and parameters p w.r.t. the parameters\n\n\n\n\n\n","category":"function"},{"location":"systems/#","page":"Polynomial systems","title":"Polynomial systems","text":"If a total degree homotopy with a system as input should be supported degrees(F) needs to be defined:","category":"page"},{"location":"systems/#","page":"Polynomial systems","title":"Polynomial systems","text":"HomotopyContinuation.degrees(::AbstractSystem)","category":"page"},{"location":"systems/#HomotopyContinuation.degrees-Tuple{AbstractSystem}","page":"Polynomial systems","title":"HomotopyContinuation.degrees","text":"degrees(F::AbstractSystem)\n\nReturns a the degrees of the polynomials.\n\n\n\n\n\n","category":"method"},{"location":"systems/#Optional-1","page":"Polynomial systems","title":"Optional","text":"","category":"section"},{"location":"systems/#","page":"Polynomial systems","title":"Polynomial systems","text":"The following methods are mandatory to implement. The following are optional to implement but usually you want to define at least cache.","category":"page"},{"location":"systems/#","page":"Polynomial systems","title":"Polynomial systems","text":"evaluate_and_jacobian!(u, U, F::AbstractSystem, x, cache::AbstractSystemCache)\nevaluate_and_jacobian!(u, U, F::AbstractSystem, x, p, cache::AbstractSystemCache)","category":"page"},{"location":"systems/#HomotopyContinuation.evaluate_and_jacobian!-Tuple{Any,Any,AbstractSystem,Any,AbstractSystemCache}","page":"Polynomial systems","title":"HomotopyContinuation.evaluate_and_jacobian!","text":"evaluate_and_jacobian!(u, U, F, x , cache::AbstractSystemCache)\n\nEvaluate the system F and its Jacobian at x and store the results in u (evalution) and U (Jacobian).\n\n\n\n\n\n","category":"method"},{"location":"systems/#HomotopyContinuation.evaluate_and_jacobian!-Tuple{Any,Any,AbstractSystem,Any,Any,AbstractSystemCache}","page":"Polynomial systems","title":"HomotopyContinuation.evaluate_and_jacobian!","text":"evaluate_and_jacobian!(u, U, F, x, p, cache::AbstractSystemCache)\n\nEvaluate the system F and its Jacobian at x and parameters p and store the results in u (evalution) and U (Jacobian).\n\n\n\n\n\n","category":"method"},{"location":"solving/#The-solve-function-1","page":"The solve function","title":"The solve function","text":"","category":"section"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"The solve function is the most convenient way to solve general polynomial systems. For the mathematical background take a look at our introduction guide.","category":"page"},{"location":"solving/#Basic-usage-1","page":"The solve function","title":"Basic usage","text":"","category":"section"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"solve","category":"page"},{"location":"solving/#HomotopyContinuation.solve","page":"The solve function","title":"HomotopyContinuation.solve","text":"solve(args...; options...)::Result\n\nThe solve function takes many different arguments and options depending on your specific situation, but in the end it always returns a Result containing the result of the computations. Depending on the prodived arguments different kind of homotopies are constructed. In particular it is possible to construct the following homotopies:\n\nTotal degree homotopy\nPolyhedral homotopy\nParameter homotopy\nMulti-homogeneous homotopy\nStart target homotopy\n\nIf the input is a homogeneous polynomial system, solutions in projective space are computed. Otherwise affine solutions are computed.\n\nOptions\n\nThe solve routines takes many different options. In particular all options to CoreTracker and PathTracker are allowed. Additionally the following options are allowed:\n\naffine_tracking::Bool=true: Indicate whether path tracking should happen in affine space.\nearly_stop_cb: Here it is possible to provide a function (or any callable struct) which accepts a PathResult r as input and returns a Bool. If early_stop_cb(r) is true then no further paths are tracked and the computation is finished. This is only called for successfull paths unless save_all_paths is true. This is for example useful if you only want to compute one solution of a polynomial system. For this early_stop_cb = _ -> true would be sufficient.\nhomotopy::AbstractHomotopy: A constructor to construct a AbstractHomotopy for the totaldegree and start target homotopy. The default is StraightLineHomotopy. The constructor is called with homotopy(start, target) where start and target are homogeneous AbstractSystems.\nhomvar::Union{Int,MultivariatePolynomials.AbstractVariable}: This considers the homogeneous system F as an affine system which was homogenized by homvar. If F is an AbstractSystem homvar is the index (i.e. Int) of the homogenization variable. If F is an AbstractVariables (e.g. created by @polyvar x) homvar is the actual variable used in the system F.\npath_jumping_check::Bool=true: Enable a check whether one of the paths jumped to another one.\npath_result_details=:default: The amount of information computed in each path result. Possible values are :minimal (minimal details), :default (default) and :extensive.\nprojective_tracking::Bool=false: Indicate whether path tracking should happen in projective space. The flag affine_tracking is dominant.\nseed: The random seed used during the computations. The seed is also reported in the result. For a given random seed the result is always identical.\nshow_progress (default true): Whether a progress bar should be printed to report the progress of the current computation.\nsystem::AbstractSystem: A constructor to assemble a AbstractSystem. The default is SPSystem. This constructor is only applied to the input of solve. The constructor is called with system(polynomials, variables) where polynomials is a vector of MultivariatePolynomials.AbstractPolynomials and variables determines the variable ordering. If you experience significant compilation times, consider to change system to FPSystem.\nsystem_scaling (default :equations) Whether to apply an automatic scaling of the equations (:equations), of the equations and variables (:equations_and_variables) or no scaling at all (nothing).\nthreading (default true): Enable or disable multi-threading. The number of threads used is controlled by the environment variable JULIA_NUM_THREADS.\nvariable_ordering: Provide a custom ordering of the variables.\n\nExamples\n\nTotal Degree Homotopy\n\nsolve(F; options...)\n\nSolve the system F using a start system computed from the degrees of the entries of F. The number of paths to track is equal to the total degree d₁⋯dⱼ, where dᵢ is the degree of the ith entry of F. F can be\n\nVector{<:MultivariatePolynomials.AbstractPolynomial} (e.g. constructed by using the exported @polyvar)\nA composition of polynomial systems constructed by compose\nAny AbstractSystem\n\nWe can solve the system F(xy) = (x^2+y^2+1 2x+3y-1) in the following way:\n\njulia> @polyvar x y;\njulia> solve([x^2+y^2+1, 2x+3y-1])\nResult with 2 solutions\n==================================\n• 2 non-singular solutions (0 real)\n• 0 singular solutions (0 real)\n• 2 paths tracked\n• random seed: 661766\n\nPolyhedral Homotopy\n\nsolve(F; start_system = :polyhedral, only_torus=false, options...)\n\nSolve the system F using a start system computed from the Newton Polytopes of the ntries F. The number of paths to track is equal to the mixed volume of the Newton Polytopes of the entries of F. The mixed volume is at most the total degree of F. F can be\n\nVector{<:MultivariatePolynomials.AbstractPolynomial} (e.g. constructed by @polyvar)\nA composition of polynomial systems constructed by compose. Note that the composition will not preserved.\n\nIf only_torus == true then only solutions in the algebraic torus (ℂsetminus 0)^n will be computed.\n\nWe can solve the system F(xy) = (x^2+y^2+1 2x+3y-1) in the following way:\n\njulia> @polyvar x y;\njulia> solve([x^2+y^2+1, 2x+3y-1]; start_system = :polyhedral)\nResult with 2 solutions\n==================================\n• 2 non-singular solutions (0 real)\n• 0 singular solutions (0 real)\n• 2 paths tracked\n• random seed: 222880\n\nParameter Homotopy\n\nsolve(F, startsolutions;\n    parameters,\n    start_parameters,\n    target_parameters,\n    start_gamma = nothing,\n    target_gamma = nothing,\n)\n\nSolve the parameter homotopy\n\nH(x t) = F(x fractγ₁p₁+(1-t)γ₀p₀tγ₁+(1-t)γ₀)\n\nwhere p₁ (=start_parameters) and p₀ (=target_parameters) are vectors of parameter values for F and γ₁ (=start_gamma) and γ₀ (=target_gamma)     are complex numbers. If start_parameters or target_parameters is nothing, it is assumed that γ₀=γ₁=1. The input parameters specifies the variables of F which should be considered as parameters. Necessarily we have length(parameters) == length(p₁) == length(p₀).\n\nsolve(F, startsolutions; parameters, p₁, p₀, γ₁=nothing, γ₀=nothing)\n\nThis is a unicode variant where γ₁=start_parameters, γ₀=target_parameters,     γ₁=start_gamma, γ₀=target_gamma.\n\nWe want to solve a parameter homotopy H(xt) = F(x t1 0+(1-t)2 4) where\n\nF(x a) = (x₁^2-a₁ x₁x₂-a₁+a₂)\n\nand let's say we are only intersted in tracking of 11. This can be accomplished as follows\n\n@polyvar x[1:2] a[1:2]\nF = [x[1]^2-a[1], x[1]*x[2]-a[1]+a[2]]\nstartsolutions = [[1, 1]]\np₁ = [1, 0]\np₀ = [3im, 0.5+2im]\nsolve(F, startsolutions; parameters=a, start_parameters=p₁, target_parameters=p₀)\n# If you like unicode this is also possible\nsolve(F, startsolutions; parameters=a, p₁=p₁, p₀=p₀)\n\nStart Target Homotopy\n\nsolve(G, F, start_solutions; options...)\n\nThis constructs the homotopy H(xt) = tG(x)+(1-t)F(x) to compute solutions of the system F. start_solutions is a list of solutions of G which are tracked to solutions of F.\n\n@polyvar x y\nG = [x^2-1,y-1]\nF = [x^2+y^2+z^2, 2x+3y-z]\nsolve(G, F, [[1, 1], [-1, 1]])\n\nHomogeneous Systems\n\nIf F has is homogeneous, we return results in projective space\n\njulia> @polyvar x y z;\njulia> solve([x^2+y^2+z^2, 2x+3y-z])\nResult{PVector{Complex{Float64},1}} with 2 solutions\n====================================================\n• 2 non-singular solutions (0 real)\n• 0 singular solutions (0 real)\n• 2 paths tracked\n• random seed: 490575\n\nIt your polynomial system is not homogeneous, you can homogenize it as follows\n\n@polyvar x y\ng = [x^2+y^2+1, 2x+3y-1]\nf = homogenize(g)\n\nIt is also possible to specify the homogenizing variable.\n\n@polyvar x y z\ng = [x^2+y^2+1, 2x+3y-1]\nf = homogenize(g, z)\n\nIf your polynomial system is already homogeneous, but you would like to consider it as an affine system you can do\n\n@polyvar x y z\nsolve([x^2+y^2+z^2, 2x+3y-z], homvar=z)\n\nThis yields the same result as solve([x^2+y^2+1, 2x+3y-1]).\n\nMulti-homogeneous Systems\n\nBy exploiting the multi-homogeneous structure of a polynomial system it is possible to decrease the number of paths necessary to track.\n\n@polyvar x y\n# Use variable groups to only track 2 paths instead of 4\nsolve([x*y - 6, x^2 - 5], variable_groups=[(x,), (y,)])\n\nTo check whether a certain variable grouping is beneficial you can use the bezout_number function.\n\nAbstract Homotopy\n\nsolve(H::AbstractHomotopy, start_solutions; options...)\n\nSolve the homotopy H by tracking the each solution of H( t) (as provided by start_solutions) from t=1 to t=0.\n\nMany parameters\n\nsolve(\n    F, start_solutions;\n    start_parameters = ...,\n    target_parameters = ..., # multiple parameters\n    options...,\n    many_parameters_options...\n)\n\nSolve the system paramterized system F for many different target parameters. If no further options are specified (resp. only those which are explained above) then the result of this funciton is similar to\n\nmap(params) do p\n    res = solve(F, S; start_parameters = start_params, target_parameters = p, options...)\n    (res, p)\nend\n\nNote if threading = true then the parallelization is done on a parameter by parameter basis (and not as above on a path by path basis). Note that order of the results is not guaranteed. The many_parameters_options allow to apply transformations on the results\n\nMany parameter options\n\nflatten::Bool: Flatten the output of transform_result. This is useful for example if transform_result returns a vector of solutions, and you only want a single vector of solutions as the result (instead of a vector of vector of solutions).\ntransform_parameters::Function: Transform a parameters values p before passing it to target_parameters = .... By default this identity.\ntransform_result::Function: A function taking two arguments, the result and the parameters p. By default this returns the tuple (result, p).\n\nMany parameter examples\n\nWe start with some setup. We intersect a circle with a many different lines.\n\n@polyvar x y\nf = x^2 + y^2 - 1\n\n@polyvar a b c\nl = a * x + b * y + c\nF = [f, l]\n\n# Compute start solutions S₀ for given start parameters p₀\np₀ = randn(ComplexF64, 3)\nS₀ = solutions(solve(subs(F, [a, b, c] => p₀)))\n# The parameters we are intersted in\nparams = [rand(3) for i = 1:100]\n\nHere are the some examples of the different options.\n\njulia> result1 = solve(\n           F,\n           S₀;\n           parameters = [a, b, c],\n           start_parameters = p₀,\n           target_parameters = params,\n       );\n\njulia> typeof(result1)\nArray{Tuple{Result{Array{Complex{Float64},1}},Array{Float64,1}},1}\n\njulia> result1[1]\n(Result{Array{Complex{Float64},1}} with 2 solutions\n==================================================\n• 2 non-singular solutions (2 real)\n• 0 singular solutions (0 real)\n• 2 paths tracked\n• random seed: 814544\n, [0.6323567622396351, 0.15381245892007867, 0.44070720179305134])\n\njulia> # Only keep real solutions\n       result2 = solve(\n           F,\n           S₀;\n           parameters = [a, b, c],\n           start_parameters = p₀,\n           target_parameters = params,\n           transform_result = (r, p) -> real_solutions(r),\n       );\n\njulia> typeof(result2)\nArray{Array{Array{Float64,1},1},1}\n\njulia> result2[1:3]\n3-element Array{Array{Array{Float64,1},1},1}:\n [[-0.4840916699908168, -0.8750172884266356], [-0.831904725657279, 0.554918487193468]]\n [[-0.9979849536743425, 0.06345102236859917], [0.5252178600449688, -0.8509678016762935]]\n [[-0.8602211106475295, 0.5099212103809087], [0.7844127443972155, -0.6202391848530926]]\n\njulia> # Now instead of an Array{Array{Array{Float64,1},1},1} we want to have an\n       # Array{Array{Float64,1},1}\n       result3 = solve(\n           F,\n           S₀;\n           parameters = [a, b, c],\n           start_parameters = p₀,\n           target_parameters = params,\n           transform_result = (r, p) -> real_solutions(r),\n           flatten = true\n       );\n\njulia> typeof(result3)\nArray{Array{Float64,1},1}\n\njulia> result3[1:3]\n3-element Array{Array{Float64,1},1}:\n [-0.4840916699908168, -0.8750172884266356]\n [-0.831904725657279, 0.554918487193468]\n [-0.9979849536743425, 0.06345102236859917]\n\njulia> # The passed `params` do not directly need to be the target parameters.\n       # Instead they can be some more concrete informations (e.g. an index)\n       # and we can them by using the `transform_parameters` method\n       result4 = solve(\n           F,\n           S₀;\n           parameters = [a, b, c],\n           start_parameters = p₀,\n           target_parameters = 1:100,\n           transform_result = (r, p) -> (real_solutions(r), p),\n           transform_parameters = _ -> rand(3)\n       );\n\njulia> typeof(result4)\nArray{Tuple{Array{Array{Float64,1},1},Int64},1}\n\njulia> result4[1:3]\n3-element Array{Tuple{Array{Array{Float64,1},1},Int64},1}:\n ([[-0.9459225556889465, -0.3243925378902725], [0.39166252055983675, -0.9201089446303168]], 1)\n ([[-0.838341089344409, 0.5451460519134572], [0.4299213699880814, -0.9028663332008627]], 68)\n ([[-0.8261686468010706, -0.5634229024834612], [-0.19003485030903675, -0.9817773452611452]], 69)\n\n\n\n\n\n","category":"function"},{"location":"solving/#Result-1","page":"The solve function","title":"Result","text":"","category":"section"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"A call to solve returns a Result:","category":"page"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"Result\nseed","category":"page"},{"location":"solving/#HomotopyContinuation.Result","page":"The solve function","title":"HomotopyContinuation.Result","text":"Result{V<:AbstractVector}\n\nThe result of solve. This is a wrapper around the results of each single path (PathResult) and it contains some additional informations like a random seed to replicate the result.\n\n\n\n\n\n","category":"type"},{"location":"solving/#HomotopyContinuation.seed","page":"The solve function","title":"HomotopyContinuation.seed","text":"seed(prob::AbstractProblem)\n\nGet the random seed used for the problem prob.\n\n\n\n\n\nseed(result)\n\nThe random seed used in the computation.\n\n\n\n\n\n","category":"function"},{"location":"solving/#Analyse-a-Result-1","page":"The solve function","title":"Analyse a Result","text":"","category":"section"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"The nonsingular solutions are obtained as follows.","category":"page"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"nonsingular","category":"page"},{"location":"solving/#HomotopyContinuation.nonsingular","page":"The solve function","title":"HomotopyContinuation.nonsingular","text":"nonsingular(result::Results; conditions...)\n\nReturn all PathResults for which the solution is non-singular. This is just a shorthand for results(R; only_nonsingular=true, conditions...). For the possible conditions see results.\n\n\n\n\n\n","category":"function"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"The singular solutions are returned by using the following.","category":"page"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"singular","category":"page"},{"location":"solving/#HomotopyContinuation.singular","page":"The solve function","title":"HomotopyContinuation.singular","text":"singular(R::Results; tol=1e10, multiple_results=false, kwargs...)\n\nReturn all PathResults for which the solution is singular. A solution is labeled singular if the condition number is greater than singular_tol, or if the winding number is > 1. If multiple_results=false only one point from each cluster of multiple solutions is returned. If If multiple_results=true all singular solutions in R are returned. For the possible kwargs see results.\n\n\n\n\n\n","category":"function"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"In order to analyse a Result we provide the following additional helper functions","category":"page"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"results\nmapresults\nsolutions\nreal_solutions\nfinite\nBase.real(::HomotopyContinuation.Results)\nat_infinity\nfailed\nmultiplicities!(::HomotopyContinuation.Result)\nmultiplicities(::HomotopyContinuation.Results)","category":"page"},{"location":"solving/#HomotopyContinuation.results","page":"The solve function","title":"HomotopyContinuation.results","text":"results(result; only_real=false, real_tol=1e-6, only_nonsingular=false,\n            onlysigular=false, singular_tol=1e10, onlyfinite=true, multiple_results=false)\n\nReturn all PathResults for which the given conditions apply.\n\nExample\n\nR = solve(F)\n\n# This gives us all PathResults considered non-singular and real (but still as a complex vector).\nreal_solutions = results(R, only_real=true, only_nonsingular=true)\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.mapresults","page":"The solve function","title":"HomotopyContinuation.mapresults","text":"mapresults(f::Function, result; conditions...)\n\nApply the function f to all PathResults for which the given conditions apply. For the possible conditions see results.\n\nExample\n\n# This gives us all solutions considered real (but still as a complex vector).\nreal_solutions = mapresults(solution, R, only_real=true)\n\n\n\n\n\nmapresults(f, result::MonodromyResult; only_real=false, real_tol=1e-6)\n\nApply the function f to all entries of MonodromyResult for which the given conditions apply.\n\nExample\n\n# This gives us all solutions considered real (but still as a complex vector).\nreal_solutions = mapresults(solution, R, only_real=true)\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.solutions","page":"The solve function","title":"HomotopyContinuation.solutions","text":"solutions(result; conditions...)\n\nReturn all solution (as Vectors) for which the given conditions apply. For the possible conditions see results.\n\nExample\n\njulia> @polyvar x y\njulia> result = solve([(x-2)y, y+x+3]);\njulia> solutions(result)\n[[2.0+0.0im, -5.0+0.0im], [-3.0+0.0im, 0.0+0.0im]]\n\n\n\n\n\nsolutions(result::MonodromyResult; only_real=false, real_tol=1e-6)\n\nReturn all solutions (as SVectors) for which the given conditions apply.\n\nExample\n\nreal_solutions = solutions(R, only_real=true)\n\n\n\n\n\nsolutions(MS::MonodromySolver)\n\nGet the solutions of the loop.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.real_solutions","page":"The solve function","title":"HomotopyContinuation.real_solutions","text":"real_solutions(result; tol=1e-6, conditions...)\n\nReturn all real solution (as Vectors of reals) for which the given conditions apply. For the possible conditions see results. Note that only_real is always true and real_tol is now tol.\n\nExample\n\njulia> @polyvar x y\njulia> result = solve([(x-2)y, y+x+3]);\njulia> real_solutions(result)\n[[2.0, -5.0], [-3.0, 0.0]]\n\n\n\n\n\nreal_solutions(res::MonodromyResult; tol=1e-6)\n\nReturns the solutions of res whose imaginary part has norm less than 1e-6.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.finite","page":"The solve function","title":"HomotopyContinuation.finite","text":"finite(result::AffineResults; conditions...)\n\nReturn all PathResults for which the solution is finite. This is just a shorthand for results(R; onlyfinite=true, conditions...). For the possible conditions see results.\n\n\n\n\n\n","category":"function"},{"location":"solving/#Base.real-Tuple{Union{Array{#s124,1} where #s124<:PathResult, Result}}","page":"The solve function","title":"Base.real","text":"real(result, tol=1e-6)\n\nGet all results where the solutions are real with the given tolerance tol. See is_real for details regarding the determination of 'realness'.\n\n\n\n\n\n","category":"method"},{"location":"solving/#HomotopyContinuation.at_infinity","page":"The solve function","title":"HomotopyContinuation.at_infinity","text":"at_infinity(result::AffineResult)\n\nGet all results where the solutions is at infinity.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.failed","page":"The solve function","title":"HomotopyContinuation.failed","text":"failed(result)\n\nGet all results where the path tracking failed.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.multiplicities!-Tuple{Result}","page":"The solve function","title":"HomotopyContinuation.multiplicities!","text":"multiplicities!(result::Result; tol=1e-6)\n\nCompute the multiplicities of the solutions in result with respect to the given tolerance.\n\n\n\n\n\n","category":"method"},{"location":"solving/#HomotopyContinuation.multiplicities-Tuple{Union{Array{#s124,1} where #s124<:PathResult, Result}}","page":"The solve function","title":"HomotopyContinuation.multiplicities","text":"multiplicities(V::Results; tol=1e-6)\n\nReturns a Vector of Vector{PathResult}s grouping the PathResults whose solutions appear with multiplicities greater 1 in 'V'. Two solutions are regarded as equal, when their pairwise distance is less than 'tol'.\n\n\n\n\n\n","category":"method"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"If you are interested in the number of solutions of a certain kind we also provide the following helper functions.","category":"page"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"nresults\nnfinite\nnreal\nnsingular\nnnonsingular\nnat_infinity\nnfailed","category":"page"},{"location":"solving/#HomotopyContinuation.nresults","page":"The solve function","title":"HomotopyContinuation.nresults","text":"nresults(\n    result;\n    only_real = false,\n    real_tol = 1e-6,\n    only_nonsingular = false,\n    singular_tol = 1e10,\n    onlyfinite = true,\n)\n\nThe number of solutions which satisfy the corresponding predicates.\n\nExample\n\nresult = solve(F)\n# Get all non-singular results where all imaginary parts are smaller than 1e-8\nnresults(result, only_real=true, real_tol=1e-8, only_nonsingular=true)\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nfinite","page":"The solve function","title":"HomotopyContinuation.nfinite","text":"nfinite(result)\n\nThe number of finite solutions.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nreal","page":"The solve function","title":"HomotopyContinuation.nreal","text":"nreal(result; tol=1e-6)\n\nThe number of real solutions where all imaginary parts of each solution are smaller than tol.\n\n\n\n\n\nnreal(res::MonodromyResult; tol=1e-6)\n\nCounts how many solutions of res have imaginary part norm less than 1e-6.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nsingular","page":"The solve function","title":"HomotopyContinuation.nsingular","text":"nsingular(\n    result;\n    singular_tol = 1e10,\n    multiplicitytol = 1e-5,\n    counting_multiplicities = false,\n    kwargs...,\n)\n\nThe number of singular solutions. A solution is considered singular if its windingnumber is larger than 1 or the condition number is larger than tol. If counting_multiplicities=true the number of singular solutions times their multiplicities is returned.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nnonsingular","page":"The solve function","title":"HomotopyContinuation.nnonsingular","text":"nnonsingular(result; tol=1e-10)\n\nThe number of non-singular solutions.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nat_infinity","page":"The solve function","title":"HomotopyContinuation.nat_infinity","text":"nat_infinity(result)\n\nThe number of solutions at infinity.\n\n\n\n\n\n","category":"function"},{"location":"solving/#HomotopyContinuation.nfailed","page":"The solve function","title":"HomotopyContinuation.nfailed","text":"nafailed(result)\n\nThe number of failed paths.\n\n\n\n\n\n","category":"function"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"Also make sure to check the documentation for PathResult.","category":"page"},{"location":"solving/#Estimate-the-computational-complexity-1","page":"The solve function","title":"Estimate the computational complexity","text":"","category":"section"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"We provide methods to compute the number of paths that needs to be tracked.","category":"page"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"For the totaldegree homotopy:","category":"page"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"bezout_number","category":"page"},{"location":"solving/#HomotopyContinuation.bezout_number","page":"The solve function","title":"HomotopyContinuation.bezout_number","text":"bezout_number(F::MPPolys; variable_groups=[variables(F)], homvars=nothing, parameters=nothing)\nbezout_number(multidegrees, groups::VariableGroups)\n\nCompute the multi-homogeneous bezout number associated to the given system and variable groups.\n\n\n\n\n\n","category":"function"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"For the polyhedral homotopy:","category":"page"},{"location":"solving/#","page":"The solve function","title":"The solve function","text":"mixed_volume","category":"page"},{"location":"solving/#MixedSubdivisions.mixed_volume","page":"The solve function","title":"MixedSubdivisions.mixed_volume","text":"mixed_volume(F::Vector{<:MP.AbstractPolynomialLike}; show_progress=true, algorithm=:regeneration)\nmixed_volume(𝑨::Vector{<:Matrix}; show_progress=true, algorithm=:regeneration)\n\nCompute the mixed volume of the given polynomial system F resp. represented by the support 𝑨. There are two possible values for algorithm:\n\n:total_degree: Use the total degree homotopy algorithm described in Section 7.1\n:regeneration: Use the tropical regeneration algorithm described in Section 7.2\n\n\n\n\n\n","category":"function"},{"location":"reference/#Reference-1","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#AffinePatches-1","page":"Reference","title":"AffinePatches","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Affine patches are there to augment projective system such that they can be considered as (locally) affine system.","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"AbstractAffinePatch\nOrthogonalPatch\nEmbeddingPatch\nRandomPatch\nFixedPatch","category":"page"},{"location":"reference/#HomotopyContinuation.AbstractAffinePatch","page":"Reference","title":"HomotopyContinuation.AbstractAffinePatch","text":"AbstractAffinePatch\n\nAn affine patch is a hyperplane defined by vx-1=0. The currently implemented affine patches are:\n\nEmbeddingPatch\nFixedPatch\nOrthogonalPatch\nRandomPatch\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.OrthogonalPatch","page":"Reference","title":"HomotopyContinuation.OrthogonalPatch","text":"OrthogonalPatch()\n\nThe orthogonal patch is a dynamically changing patch. It computes in such a way that ||x||=1 with respect to the 2-norm. See (for example) Section 3.2 in [HR18].\n\n[HR18]: https://arxiv.org/pdf/1710.06362.pdf\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.EmbeddingPatch","page":"Reference","title":"HomotopyContinuation.EmbeddingPatch","text":"EmbeddingPatch()\n\nHolds an PVector onto its affine patch. With this the effect is basically the same as tracking in affine space.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.RandomPatch","page":"Reference","title":"HomotopyContinuation.RandomPatch","text":"RandomPatch()\n\nA random patch. For this we first draw entries of a vector v independently from a complex normal distribution (randn(ComplexF64)). And then normalize v with respect to the 2-norm.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.FixedPatch","page":"Reference","title":"HomotopyContinuation.FixedPatch","text":"FixedPatch()\n\nThe FixedPatch is similar to the OrthogonalPatch but it doesn't change during the tracking. Instead it only updates at the start of the tracking.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Input-1","page":"Reference","title":"Input","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"We support any polynomials which follow the MultivariatePolynomials interface. By default we export the routines @polyvar, differentiate and variables from the DynamicPolynomials implementation. With these you can simply create variables","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"# Create variables x, y, z\n@polyvar x y z\nf = x^2+y^2+z^2\n\n# You can also create an array of variables\n@polyvar x[1:3] # This creates x1, x2, x3 accessed by x[1], x[2], x[3]\nf = dot(x, x) # = x[1]^2+x[2]^2+x[3]^2\n\n# Also you can create matrices of variables\n# This creates x1_1, x1_2, x2_1, x2_2 accessed by\n# x[1,1], x[1,2], x[2,1], x[2,2]\n@polyvar x[1:2, 1:2]","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"We also provide methods construct compositions of polynomial systems:","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"compose","category":"page"},{"location":"reference/#HomotopyContinuation.compose","page":"Reference","title":"HomotopyContinuation.compose","text":"compose(g, f)::Composition\n\nCompose the polynomial systems g and f. You can also use the infix operator ∘ (written by \\circ).\n\njulia> @polyvar a b c x y z;\njulia> g = [a * b * c];\njulia> f = [x+y, y + z, x + z];\njulia> expand(compose(g, f))\n1-element Array{DynamicPolynomials.Polynomial{true,Int64},1}:\n x²y + x²z + xy² + 2xyz + xz² + y²z + yz²\n\n\n\n\n\n","category":"function"},{"location":"reference/#Distances-and-norms-1","page":"Reference","title":"Distances and norms","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"We provide functions for computing norms and distance. These are subtypes of AbstractNorm:","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"AbstractNorm","category":"page"},{"location":"reference/#HomotopyContinuation.AbstractNorm","page":"Reference","title":"HomotopyContinuation.AbstractNorm","text":"AbstractNorm\n\nAn AbstractNorm represents any norm of a vector space. All norms are callable. norm(x) computes the norm of x and norm(x,y) computes the distance norm(x - y).\n\n\n\n\n\n","category":"type"},{"location":"reference/#","page":"Reference","title":"Reference","text":"They implement","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"distance(u, v, norm::AbstractNorm)\nLinearAlgebra.norm(x, ::AbstractNorm)","category":"page"},{"location":"reference/#HomotopyContinuation.distance-Tuple{Any,Any,AbstractNorm}","page":"Reference","title":"HomotopyContinuation.distance","text":"distance(u, v, norm::AbstractNorm)\n\nCompute the distance ||u-v|| with respect to the given norm norm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#LinearAlgebra.norm-Tuple{Any,AbstractNorm}","page":"Reference","title":"LinearAlgebra.norm","text":"norm(u, norm::AbstractNorm)\n\nCompute the norm ||u|| with respect to the given norm norm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#","page":"Reference","title":"Reference","text":"The following norms are implemented:","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"EuclideanNorm\nInfNorm\nWeightedNorm\nweights(WN::WeightedNorm)\ninit!(w::WeightedNorm, x::AbstractVector)\nupdate!(w::WeightedNorm, x::AbstractVector)","category":"page"},{"location":"reference/#HomotopyContinuation.EuclideanNorm","page":"Reference","title":"HomotopyContinuation.EuclideanNorm","text":"EuclideanNorm\n\nThe usual Euclidean norm resp. 2-norm.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.InfNorm","page":"Reference","title":"HomotopyContinuation.InfNorm","text":"InfNorm <: AbstractNorm\n\nThe infinity or maximum norm.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.WeightedNorm","page":"Reference","title":"HomotopyContinuation.WeightedNorm","text":"WeightedNorm(d::AbstractVector, norm::AbstractNorm; options...)\nWeightedNorm(norm::AbstractNorm, n::Integer; options...)\nWeightedNorm(norm::AbstractNorm, x::AbstractVector; options...)\n\nA WeightedNorm represents a weighted variant of norm norm of a n-dimensional vector space.A norm||x||is weighted by introducing a vector of additional weightsdsuch that the new norm is||D⁻¹x||whereDis the diagonal matrix with diagonald. The WeightedNorm is desigened to change the weights dynamically by using init!(::WeightedNorm, x) and update!(::WeightedNorm, x). The weights are there constructed such that D¹x  10. The weights can be accessed and changed by indexing.\n\nOptions\n\nscale_min = 0.001: The minimal size of dᵢ is scale_min time the (weighted) norm of x.\nscale_abs_min = min(scale_min^2, 200 * sqrt(eps())): The absolute minimal size of dᵢ.\nscale_max = 1.0 / eps() / sqrt(2): The absolute maximal size of dᵢ\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.weights-Tuple{WeightedNorm}","page":"Reference","title":"HomotopyContinuation.weights","text":"weights(WN::WeightedNorm)\n\nReturns the weights of the weighted norm.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HomotopyContinuation.init!-Tuple{WeightedNorm,AbstractArray{T,1} where T}","page":"Reference","title":"HomotopyContinuation.init!","text":"init!(w::WeightedNorm, x::AbstractVector)\n\nSetup the weighted norm w for x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#HomotopyContinuation.update!-Tuple{WeightedNorm,AbstractArray{T,1} where T}","page":"Reference","title":"HomotopyContinuation.update!","text":"update!(w::WeightedNorm, x::AbstractVector)\n\nUpdate the weighted norm w for x, this will interpolate between the previous weights and the norm of x.\n\n\n\n\n\n","category":"method"},{"location":"reference/#Deprecated-1","page":"Reference","title":"Deprecated","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"euclidean_distance\neuclidean_norm","category":"page"},{"location":"reference/#HomotopyContinuation.euclidean_distance","page":"Reference","title":"HomotopyContinuation.euclidean_distance","text":"euclidean_distance(u, v)\n\nCompute ||u-v||₂.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HomotopyContinuation.euclidean_norm","page":"Reference","title":"HomotopyContinuation.euclidean_norm","text":"euclidean_norm(u)\n\nCompute ||u||₂.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Path-informations-1","page":"Reference","title":"Path informations","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"path_info","category":"page"},{"location":"reference/#HomotopyContinuation.path_info","page":"Reference","title":"HomotopyContinuation.path_info","text":"path_info(tracker::CoreTracker, x, t₁ = 1.0, t₀ = 0.0)\npath_info(tracker::PathTracker, x)\n\nTrack a path using the given tracker and start value x. This returns a struct containing detailed informations about the tracked path.\n\nExample\n\njulia> @polyvar x y;\njulia> f = [x^2 + y^2 + 1, x + y - 3];\njulia> tracker, starts = coretracker_startsolutions(f);\njulia> path_info(tracker, first(starts))\nCTPathInfo:\n • # return code → success\n • # steps (✓/✗) → 11 ( 10 / 1 )\n • # factorizations → 31\n • # ldivs → 66\n┌───┬───────┬────────┬───────┬─────────┬─────────┬──────┬─────────┬───────────┬──────┬─────────┐\n│   │     s │     Δs │     ω │   |Δx₀| │     acc │    κ │       ψ │ limit_acc │  |x| │     |r| │\n├───┼───────┼────────┼───────┼─────────┼─────────┼──────┼─────────┼───────────┼──────┼─────────┤\n│ ✓ │     0 │  0.117 │     1 │       0 │ 3.4e-17 │  1.5 │ 2.2e-17 │   3.4e-17 │    1 │ 6.7e-17 │\n│ ✓ │ 0.117 │  0.117 │ 0.866 │ 0.00063 │ 2.7e-17 │ 2.31 │ 1.7e-17 │   2.7e-17 │ 1.13 │ 5.6e-17 │\n│ ✓ │ 0.235 │    0.2 │ 0.817 │ 0.00086 │ 3.7e-14 │ 2.31 │ 1.7e-17 │   2.7e-17 │ 1.29 │ 5.6e-17 │\n│ ✗ │ 0.435 │  0.166 │ 0.437 │   0.021 │ 3.4e-09 │ 2.31 │ 1.7e-17 │   2.7e-17 │ 1.53 │ 5.6e-17 │\n│ ✓ │ 0.435 │  0.105 │  1.08 │   0.041 │ 3.4e-09 │ 2.31 │ 1.7e-17 │   2.7e-17 │ 1.53 │ 5.6e-17 │\n│ ✓ │ 0.539 │  0.105 │  1.08 │  0.0053 │   1e-15 │ 7.03 │ 6.7e-16 │     1e-15 │ 1.47 │ 2.2e-15 │\n│ ✓ │ 0.644 │ 0.0704 │ 0.652 │   0.039 │ 3.4e-08 │ 7.03 │ 6.7e-16 │     1e-15 │ 1.24 │ 2.2e-15 │\n│ ✓ │ 0.714 │ 0.0816 │ 0.408 │  0.0057 │ 1.7e-12 │ 7.03 │ 6.7e-16 │     1e-15 │ 1.33 │ 2.2e-15 │\n│ ✓ │ 0.796 │ 0.0999 │ 0.357 │  0.0049 │ 3.3e-12 │ 7.03 │ 6.7e-16 │     1e-15 │ 1.59 │ 2.2e-15 │\n│ ✓ │ 0.896 │  0.104 │ 0.683 │  0.0032 │ 4.1e-12 │ 7.03 │ 6.7e-16 │     1e-15 │ 1.94 │ 2.2e-15 │\n│ ✓ │     1 │      0 │ 0.748 │ 0.00082 │ 1.5e-16 │ 3.86 │ 6.8e-17 │   1.5e-16 │ 2.24 │ 1.3e-15 │\n└───┴───────┴────────┴───────┴─────────┴─────────┴──────┴─────────┴───────────┴──────┴─────────┘\n\njulia> tracker = pathtracker(f);\n\njulia> path_info(tracker, first(starts))\nPTPathInfo:\n • # return code → success\n • # steps (✓/✗) → 19 ( 18 / 1 )\n • # factorizations → 56\n • # ldivs → 114\n┌───┬───────┬───────┬─────────┬──────────┬──────────┬──────┬───────────┬─────────┬───────┬─────────┬──────┐\n│   │     s │    Δs │    |ν̇| │    min_ν │    max_ν │    κ │ limit_acc │     acc │     ω │   |Δx₀| │  |x| │\n├───┼───────┼───────┼─────────┼──────────┼──────────┼──────┼───────────┼─────────┼───────┼─────────┼──────┤\n│ ✓ │     0 │ 0.126 │     NaN │      NaN │      NaN │  1.5 │   9.6e-18 │ 9.6e-18 │     1 │       0 │    1 │\n│ ✓ │ 0.126 │ 0.126 │     NaN │      NaN │      NaN │  1.5 │   5.4e-17 │ 5.4e-17 │ 0.874 │ 0.00098 │ 1.13 │\n│ ✓ │ 0.251 │ 0.209 │     NaN │      NaN │      NaN │  1.5 │   5.4e-17 │ 5.6e-14 │ 0.829 │ 0.00094 │ 1.29 │\n│ ✓ │  0.46 │ 0.234 │     NaN │      NaN │      NaN │  1.5 │   5.4e-17 │   3e-11 │ 0.733 │  0.0049 │ 1.51 │\n│ ✓ │ 0.694 │  0.23 │     NaN │      NaN │      NaN │  1.5 │   5.4e-17 │ 2.6e-10 │ 0.767 │   0.008 │ 1.54 │\n│ ✓ │ 0.924 │ 0.158 │     NaN │      NaN │      NaN │  1.5 │   5.4e-17 │   6e-08 │  1.16 │   0.028 │ 1.31 │\n│ ✓ │  1.08 │ 0.154 │     NaN │      NaN │      NaN │  1.5 │   5.4e-17 │ 6.3e-11 │ 0.598 │  0.0093 │ 1.21 │\n│ ✓ │  1.24 │  0.25 │     NaN │      NaN │      NaN │  1.5 │   5.4e-17 │ 8.9e-15 │ 0.395 │  0.0015 │  1.3 │\n│ ✓ │  1.48 │  0.38 │     NaN │      NaN │      NaN │  1.5 │   5.4e-17 │ 8.7e-14 │ 0.293 │  0.0022 │ 1.51 │\n│ ✗ │  1.87 │ 0.135 │     NaN │      NaN │      NaN │  1.5 │   5.4e-17 │   8e-13 │ 0.686 │  0.0022 │ 1.78 │\n│ ✓ │     2 │ 0.314 │    0.39 │    -0.26 │    -0.26 │  1.5 │   5.8e-17 │ 5.8e-17 │ 0.566 │ 8.8e-06 │ 1.85 │\n│ ✓ │  2.31 │ 0.314 │    0.23 │    -0.17 │    -0.16 │ 3.64 │   1.2e-16 │ 1.2e-16 │ 0.491 │  0.0001 │ 1.97 │\n│ ✓ │  2.63 │  1.24 │    0.15 │    -0.11 │     -0.1 │ 3.64 │   1.2e-16 │ 3.7e-10 │  0.84 │   3e-05 │ 2.05 │\n│ ✓ │  3.86 │  1.71 │   0.028 │   -0.025 │   -0.023 │ 3.64 │   1.2e-16 │ 1.4e-12 │ 0.751 │   0.002 │ 2.19 │\n│ ✓ │  5.58 │  2.84 │  0.0043 │  -0.0042 │  -0.0037 │ 3.71 │   7.9e-17 │ 7.9e-17 │ 0.275 │  0.0017 │ 2.23 │\n│ ✓ │  8.41 │  5.13 │ 0.00024 │ -0.00024 │ -0.00021 │ 3.71 │   7.9e-17 │ 2.3e-14 │ 0.244 │  0.0012 │ 2.24 │\n│ ✓ │  13.5 │  13.3 │ 1.4e-06 │ -1.4e-06 │ -1.3e-06 │ 3.71 │   7.9e-17 │ 1.1e-08 │ 0.245 │  0.0003 │ 2.24 │\n│ ✓ │  26.8 │    55 │ 4.3e-10 │ -2.5e-12 │ -2.2e-12 │ 3.67 │   1.7e-16 │ 1.7e-16 │ 0.275 │ 9.8e-06 │ 2.24 │\n│ ✓ │  81.8 │     0 │ 4.3e-10 │ -2.5e-12 │ -2.2e-12 │ 3.67 │   1.2e-16 │ 1.2e-16 │ 0.275 │ 1.8e-09 │ 2.24 │\n└───┴───────┴───────┴─────────┴──────────┴──────────┴──────┴───────────┴─────────┴───────┴─────────┴──────┘\n\n\n\n\n\n","category":"function"},{"location":"reference/#Polynomial-Utilities-1","page":"Reference","title":"Polynomial Utilities","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"homogenize\nis_homogeneous\nuniquevar\nlinear_system","category":"page"},{"location":"reference/#HomotopyContinuation.homogenize","page":"Reference","title":"HomotopyContinuation.homogenize","text":"homogenize(f::MP.AbstractPolynomial, variable=uniquevar(f))\n\nHomogenize the polynomial f by using the given variable variable.\n\nhomogenize(F::Vector{<:MP.AbstractPolynomial}, variable=uniquevar(F))\n\nHomogenize each polynomial in F by using the given variable variable.\n\nhomogenize(f::MP.AbstractPolynomial, v::Vector{<:MP.AbstractVariable}, variable=uniquevar(f))\n\nHomogenize the variables v in the polynomial f by using the given variable variable.\n\nhomogenize(F::Vector{<:MP.AbstractPolynomial}, v::Vector{<:MP.AbstractVariable}, variable=uniquevar(F))\n\nHomogenize the variables v in each polynomial in F by using the given variable variable.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HomotopyContinuation.is_homogeneous","page":"Reference","title":"HomotopyContinuation.is_homogeneous","text":"is_homogeneous(f::MP.AbstractPolynomialLike)\n\nChecks whether f is homogeneous.\n\nis_homogeneous(f::MP.AbstractPolynomialLike, vars)\n\nChecks whether f is homogeneous in the variables vars with possible weights.\n\n\n\n\n\nis_homogeneous(F::Vector{MP.AbstractPolynomialLike}, variables)\n\nChecks whether each polynomial in F is homogeneous in the variables variables.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HomotopyContinuation.uniquevar","page":"Reference","title":"HomotopyContinuation.uniquevar","text":"uniquevar(f::MP.AbstractPolynomialLike, tag=:x0)\nuniquevar(F::MPPolys, tag=:x0)\n\nCreates a unique variable.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HomotopyContinuation.linear_system","page":"Reference","title":"HomotopyContinuation.linear_system","text":"linear_system(f::Vector{<:MP.AbstractPolynomialLike})\n\nGiven a polynomial system which represents a linear system Ax=b return A and b. If f is not a linear system nothing is returned.\n\nExample\n\njulia> @polyvar x y z;\njulia> f = [2x+3y+z+5, -1x+2y+4z-2];\njulia> A, b = linear_system(f);\njulia> A\n2×3 Array{Int64,2}:\n  2  3  1\n -1  2  4\n\njulia> b\n2-element Array{Int64,1}:\n -5\n  2\n\n\n\n\n\n","category":"function"},{"location":"reference/#Predictors-and-Correctors-1","page":"Reference","title":"Predictors and Correctors","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"We use a predictor-corrector scheme to track paths. While we have a fixed implementation of Newton's method as a corrector there multiple predictors available:","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"Euler\nHeun\nRalston\nRK3\nRK4\nPade21\nNullPredictor","category":"page"},{"location":"reference/#HomotopyContinuation.Euler","page":"Reference","title":"HomotopyContinuation.Euler","text":"Euler()\n\nThis uses the explicit Euler method for prediction, also known as the tangent predictor.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.Heun","page":"Reference","title":"HomotopyContinuation.Heun","text":"Heun()\n\nThe Heun predictor of order 2.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.Ralston","page":"Reference","title":"HomotopyContinuation.Ralston","text":"Ralston()\n\nThe Ralston predictor of order 2.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.RK3","page":"Reference","title":"HomotopyContinuation.RK3","text":"RK3()\n\nThe classical Runge-Kutta predictor of order 3.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.RK4","page":"Reference","title":"HomotopyContinuation.RK4","text":"RK4()\n\nThe classical Runge-Kutta predictor of order 4.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.Pade21","page":"Reference","title":"HomotopyContinuation.Pade21","text":"Pade21()\n\nThis uses a Padé-approximation of type (2,1) for prediction.\n\n\n\n\n\n","category":"type"},{"location":"reference/#HomotopyContinuation.NullPredictor","page":"Reference","title":"HomotopyContinuation.NullPredictor","text":"NullPredictor()\n\nA predictor which does no prediction step, i.e., it just returns the input as its prediction.\n\n\n\n\n\n","category":"type"},{"location":"reference/#Projective-vectors-1","page":"Reference","title":"Projective vectors","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"To represent solutions in projective spaces we use the ProjectiveVectors.jl package. The following methods are re-exported from the package.","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"PVector\ndims\ndimension_indices\naffine_chart\nProjectiveVectors.embed\n×\ncomponent\ncomponents\ncombine","category":"page"},{"location":"reference/#ProjectiveVectors.PVector","page":"Reference","title":"ProjectiveVectors.PVector","text":"PVector{T, N} <: AbstractProjectiveVector{T, N}\n\nA PVector represents a projective vector z which lives in a product of N projective spaces P(T)^dᵢ. The underlying data structure is a Vector{T}.\n\nPVector(v::AbstractVector, dims::NTuple{N,Int}) where N\n\nCreate a projective vector v living in a product of projective spaces with (projective) dimensions dims.\n\nPVector(v, w, ...)\n\nCreate the product of projective vectors.\n\nExample\n\njulia> PVector([1,2,3], [4, 5])\n[1 : 2 : 3] × [4 : 5]\n\njulia> PVector([1, 2, 3, 4, 5], (2, 1))\n[1 : 2 : 3] × [4 : 5]\n\njulia> PVector([1,2,3], [4, 5], [6, 7, 8])\n[1 : 2 : 3] × [4 : 5] × [6 : 7 : 8]\n\n\n\n\n\n","category":"type"},{"location":"reference/#ProjectiveVectors.dims","page":"Reference","title":"ProjectiveVectors.dims","text":"dims(z::PVector)\n\nDimensions of the projective spaces in which z lives.\n\n\n\n\n\n","category":"function"},{"location":"reference/#ProjectiveVectors.dimension_indices","page":"Reference","title":"ProjectiveVectors.dimension_indices","text":"dimension_indices(z::PVector{T, N})\ndimension_indices(dims::NTuple{N, Int})\n\nReturn a tuple of N UnitRanges indexing the underlying data.\n\nExample\n\njulia> v = PVector([4, 5, 6], [2, 3], [1, 2])\nPVector{Int64, 3}:\n [4, 5, 6] × [2, 3] × [1, 2]\n\njulia> dimension_indices(v)\n(1:3, 4:5, 6:7)\n\n\n\n\n\n","category":"function"},{"location":"reference/#ProjectiveVectors.affine_chart","page":"Reference","title":"ProjectiveVectors.affine_chart","text":"affine_chart(z::PVector)\n\nReturn the affine chart corresponding to the projective vector. This can be seen as the inverse of embed.\n\nExample\n\njulia> v = embed([2.0, 3, 4, 5, 6, 7], (2, 3, 1))\nPVector{Float64, 3}:\n [2.0, 3.0, 1.0] × [4.0, 5.0, 6.0, 1.0] × [7.0, 1.0]\n\njulia> affine_chart(v)\n6-element Array{Float64,1}:\n 2.0\n 3.0\n 4.0\n 5.0\n 6.0\n 7.0\n\n\n\n\n\n","category":"function"},{"location":"reference/#ProjectiveVectors.embed","page":"Reference","title":"ProjectiveVectors.embed","text":"embed(xs::AbstractVector...; normalize=false)\nembed(x::AbstractVector{T}, dims::NTuple{N, Int}; normalize=false)::PVector{T, N}\n\nEmbed an affine vector x in a product of affine spaces by the map πᵢ: xᵢ -> [xᵢ; 1] for each subset xᵢ of x according to dims. If normalize is true the vector is normalized.\n\nExamples\n\njulia> embed([2, 3])\nPVector{Int64, 1}:\n [2, 3, 1]\n\njulia> embed([2, 3], [4, 5, 6])\nPVector{Int64, 2}:\n [2, 3, 1] × [4, 5, 6, 1]\n\njulia> embed([2.0, 3, 4, 5, 6, 7], (2, 3, 1))\nPVector{Float64, 3}:\n [2.0, 3.0, 1.0] × [4.0, 5.0, 6.0, 1.0] × [7.0, 1.0]\n\n julia> embed([2.0, 3, 4, 5, 6, 7], (2, 3, 1), normalize=true)\n PVector{Float64, 3}:\n  [0.5345224838248488, 0.8017837257372732, 0.2672612419124244] × [0.45291081365783825, 0.5661385170722978, 0.6793662204867574, 0.11322770341445956] × [0.9899494936611666, 0.1414213562373095]\n\n\n\n\n\n","category":"function"},{"location":"reference/#LinearAlgebra.:×","page":"Reference","title":"LinearAlgebra.:×","text":"×(v::PVector, w::PVector...)\n\nOperator version of combine.\n\nExample\n\njulia> v = PVector([1, 2, 3]);\njulia> w = PVector([4, 5]);\njulia> v × w\n[1 : 2 : 3] × [4 : 5]\n\n\n\n\n\n","category":"function"},{"location":"reference/#ProjectiveVectors.component","page":"Reference","title":"ProjectiveVectors.component","text":"component(v::PVector{T,N}, i)::PVector{T,1}\n\nObtain the i-th component of v  P(ℂ^n₁)    P(ℂ^nⱼ).\n\nExample\n\njulia> v = PVector([1, 2, 3]);\njulia> w = PVector([4, 5]);\njulia> v × w\n[1 : 2 : 3] × [4 : 5]\njulia> component(v × w, 1)\n[1 : 2 : 3]\n# alternative you can also indexing\njulia> (v × w)[1,:]\n[1 : 2 : 3]\n\n\n\n\n\n","category":"function"},{"location":"reference/#ProjectiveVectors.components","page":"Reference","title":"ProjectiveVectors.components","text":"components(v::PVector{T,N})::NTuple{N, PVector{T, 1}}\n\nDecompose the element v  P(ℂ^n₁)    P(ℂ^nⱼ)  into (v₁  vⱼ) = v\n\nExample\n\njulia> v = PVector([1, 2, 3]);\njulia> w = PVector([4, 5]);\njulia> v × w\n[1 : 2 : 3] × [4 : 5]\njulia> components(v × w) == (v, w)\ntrue\n\n\n\n\n\n","category":"function"},{"location":"reference/#ProjectiveVectors.combine","page":"Reference","title":"ProjectiveVectors.combine","text":"combine(v::PVector, w::PVector...)\n\nCombine the projective vectors v and wᵢ to the flattened product. There is also an operator version, × (written imes<tab>).\n\nExample\n\njulia> v = PVector([1, 2, 3]);\njulia> w = PVector([4, 5]);\njulia> combine(v, w)\n[1 : 2 : 3] × [4 : 5]\n\n\n\n\n\n","category":"function"},{"location":"reference/#Unique-points-and-multiplicities-1","page":"Reference","title":"Unique points and multiplicities","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"We provide functions for sorting analyzing arrays of vectors.","category":"page"},{"location":"reference/#Unique-points-1","page":"Reference","title":"Unique points","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"We provide the unique_points methods to sort through solutions.","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"unique_points","category":"page"},{"location":"reference/#HomotopyContinuation.unique_points","page":"Reference","title":"HomotopyContinuation.unique_points","text":"unique_points(points::AbstractVector{<:AbstractVector}; options...)\n\nCompute all unique points with respect to the given options. See UniquePoints for possible options. In particular, it is possible to pass group actions.\n\nExample\n\njulia> pts = [[1.0,0.5], [1.0,0.5], [0.5,1.0]];\njulia> unique_points(pts)\n2-element Array{Array{Float64,1},1}:\n [1.0, 0.5]\n [0.5, 1.0]\n\njulia> unique_points(pts; group_action = x -> [x[2],x[1]])\n1-element Array{Array{Float64,1},1}:\n [1.0, 0.5]\n\n\n\n\n\n","category":"function"},{"location":"reference/#","page":"Reference","title":"Reference","text":"The unique_points method is powered by the UniquePoints data structure.","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"UniquePoints","category":"page"},{"location":"reference/#HomotopyContinuation.UniquePoints","page":"Reference","title":"HomotopyContinuation.UniquePoints","text":"UniquePoints{V<:AbstractVector, T, F<:Function}\n\nA data structure which holds points of type V where T=real(eltype(V)). This data structure provides an efficient (poly)logarithmic check whether a point already exists where two points u,v are considered equal if F(u,v)<tol, where tol is a tolerance provided through the add! function.\n\nUniquePoints(v::AbstractVector{<:Number}, distance::F)\n\nInitialize the data structure with just one data point v.\n\nUniquePoints(V::Vector{<:AbstractVector{<:Number}}, distance::F; tol=1e-5)\n\nInitialize the data structure with all points in v. These are added in order by add! with the given tolerance tol. In particular, 'UniquePoints' structure will contain only points for which the pairwise distance given by F is less than tol.\n\nUniquePoints(v; kwargs...) = UniquePoints(v, euclidean_distance; kwargs...)\n\nIf F is not specialized, euclidean_distance is used.\n\nOptional keywords:\n\ncheck_real=true adds real from points from group orbits (if they exist). The default is check_real=true.\nThe user can use group_action=foo or, if there is more than one group acting, group_actions=[foo, bar]. Then, points that are in the same group orbit are considered equal. See GroupActions for details regarding the application rules.\n\nExamples\n\njulia> points(UniquePoints([[1.0,0.5], [1.0,0.5], [0.5,1.0]]))\n2-element Array{Array{Float64,1},1}:\n [1.0, 0.5]\n [0.5, 1.0]\n\njulia> points(UniquePoints([[1.0,0.5], [1.0,0.5], [0.5,1.0]], group_action = x -> [x[2],x[1]]))\n1-element Array{Array{Float64,1},1}:\n [1.0, 0.5]\n\n\n\n\n\n","category":"type"},{"location":"reference/#","page":"Reference","title":"Reference","text":"We provide several helper functions for UniquePoints.","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"points\nis_contained\nadd!\nsimple_add!\nempty!","category":"page"},{"location":"reference/#HomotopyContinuation.points","page":"Reference","title":"HomotopyContinuation.points","text":"points(data::UniquePoints)\n\nReturn the points stored in data.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HomotopyContinuation.is_contained","page":"Reference","title":"HomotopyContinuation.is_contained","text":"is_contained(data::UniquePoints{V}, x::V; tol=1e-5)::Bool\n\nCheck whether x is contained in the data by using the tolerance tol to decide for duplicates.\n\nis_contained(data::UniquePoints{V}, x::V, Val{true}(); tol=1e-5)::Int\n\nIf x is contained in data by using the tolerance tol return the index of the data point which already exists. If the data point is not existing -1 is returned. If data has the option check_real enabled, a -2 will be returned once a real vector was added.\n\n\n\n\n\n","category":"function"},{"location":"reference/#HomotopyContinuation.add!","page":"Reference","title":"HomotopyContinuation.add!","text":"add!(data::UniquePoints{V}, x::V; tol=1e-5)::Bool\n\nAdd x to data if it doesn't already exists by using the tolerance tol to decide for duplicates.\n\nadd!(data::UniquePoints{V}, x::V, Val(true); tol=1e-5)::Int\n\nIf x is contained in data by using the tolerance tol to decide for duplicates return the index of the data point which already exists. If the data point is not existing add it to data and return -1. If data has the option check_real enabled, a -2 will be returned once a real vector was added. The element will be the last element of points(data).\n\n\n\n\n\n","category":"function"},{"location":"reference/#HomotopyContinuation.simple_add!","page":"Reference","title":"HomotopyContinuation.simple_add!","text":"simple_add!(data::UniquePoints{V}, x::V, tol::Real)::Bool\n\nSimilarly to add! but does not apply any group actions. If the data point is not existing add it to data and return -1. Otherwise the index of x in data.points is returned.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Base.empty!","page":"Reference","title":"Base.empty!","text":"empty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = Dict(\"a\" => 1, \"b\" => 2)\nDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nDict{String,Int64} with 0 entries\n\n\n\n\n\nempty!(q::Deque{T})\n\nReset the deque.\n\n\n\n\n\nempty!(collection) -> collection\n\nRemove all elements from a collection.\n\nExamples\n\njulia> A = RobinDict(\"a\" => 1, \"b\" => 2)\nRobinDict{String,Int64} with 2 entries:\n  \"b\" => 2\n  \"a\" => 1\n\njulia> empty!(A);\n\njulia> A\nRobinDict{String,Int64} with 0 entries\n\n\n\n\n\nempty!(cb::CircularBuffer)\n\nReset the buffer.\n\n\n\n\n\nempty!(data::UniquePoints)\n\nRemove all points from data.\n\n\n\n\n\n","category":"function"},{"location":"reference/#Multiplicities-1","page":"Reference","title":"Multiplicities","text":"","category":"section"},{"location":"reference/#","page":"Reference","title":"Reference","text":"If instead of unique points, the user wants to have the information which points in an array of points appear with multiplicity, they should use the next function.","category":"page"},{"location":"reference/#","page":"Reference","title":"Reference","text":"multiplicities","category":"page"},{"location":"reference/#HomotopyContinuation.multiplicities","page":"Reference","title":"HomotopyContinuation.multiplicities","text":"multiplicities(vectors; distance=euclidean_distance, tol::Real = 1e-5, kwargs...)\n\nReturns an array of arrays of integers. Each vector w in 'v' contains all indices i,j such that w[i] and w[j] have distance at most tol.\n\nOptional keywords:\n\ncheck_real=true adds real from points from group orbits (if they exist) to the UniquePoints data structure used internally. The default is check_real=false.\nThe user can use group_action=foo or, if there is more than one group acting, group_actions=[foo, bar]. Then, points that are in the same group orbit are considered equal. See GroupActions for details regarding the application rules.\n\njulia> multiplicities([[1,0.5]; [1,0.5]; [1,1]])\n[[1,2]]\n\nThis is the same as\n\nmultiplicities([[1,0.5]; [1,0.5]; [1,1]]; distance=(x,y) -> LinearAlgebra.norm(x-y))\n\nHere is an example for using group actions.\n\njulia> X = [[1, 2, 3, 4], [2,1,3,4], [1,2,4,3], [2,1,4,3]]\njulia> permutation(x) = [x[2], x[1], x[3], x[4]]\njulia> m = multiplicities(X, group_action = permutation)\n[[1,2], [3,4]]\n\n\n\n\n\nmultiplicities(V::Results; tol=1e-6)\n\nReturns a Vector of Vector{PathResult}s grouping the PathResults whose solutions appear with multiplicities greater 1 in 'V'. Two solutions are regarded as equal, when their pairwise distance is less than 'tol'.\n\n\n\n\n\n","category":"function"},{"location":"reference/#","page":"Reference","title":"Reference","text":"The multiplicities functions may also be applied to Result; see here: multiplicities(::HomotopyContinuation.Results).","category":"page"},{"location":"solver/#The-Solver-struct-1","page":"The Solver struct","title":"The Solver struct","text":"","category":"section"},{"location":"solver/#","page":"The Solver struct","title":"The Solver struct","text":"Solver\nsolver\nsolver_startsolutions","category":"page"},{"location":"solver/#HomotopyContinuation.Solver","page":"The Solver struct","title":"HomotopyContinuation.Solver","text":"Solver(pathtracker::PathTracker)\n\nA Solver is a wrapper around a given pathtracker to track multiple paths. It provides on top of the given pathtracker parallelization and an optional path jumping check. To construct a  Solver it is convenient to use the solver or solver_startsolutions functions. Given a solver one can use the solve function to solve a system. This struct is constructed for any call to solve unless already explicitly provided.\n\nExample\n\nAssume we want to solve a polynomial system repeatedly for many different values of the parameters p. The following example shows how to use a Solver to avoid some computational overhead compared to naively calling solve.\n\n@polyvar x y z p[1:3]\nF = [\n    x + 3 + 2y + 2 * y^2 - p[1],\n    (x - 2 + 5y) * z + 4 - p[2] * z,\n    (x + 2 + 4y) * z + 5 - p[3] * z,\n]\nq = randn(ComplexF64, 3)\nS = solutions(solve(subs(F, p => q)))\n# create some fake parameter values\nparams = [randn(3) for _ = 1:1000]\n# create a `Solver` to reuse for the path tracking\nF_solver = solver(F; parameters = p, generic_parameters = q)\n# solve the system F for all paramaters p in params\nparams_solutions = map(params) do p\n    solutions(solve(F_solver, S; target_parameters = p))\nend\n\n\n\n\n\n","category":"type"},{"location":"solver/#HomotopyContinuation.solver","page":"The Solver struct","title":"HomotopyContinuation.solver","text":"solver(args...; kwargs...)\n\nCreate a Solver. Takes almost the same arguments as solve.\n\n\n\n\n\n","category":"function"},{"location":"solver/#HomotopyContinuation.solver_startsolutions","page":"The Solver struct","title":"HomotopyContinuation.solver_startsolutions","text":"solver_startsolutions(args...; kwargs...)\n\nCreate a Solver and start solutions. Takes almost the same arguments as solve.\n\n\n\n\n\n","category":"function"},{"location":"#Introduction-1","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"HomotopyContinuation.jl is a package for solving systems of polynomials equations with only finitely many solutions using numerical homotopy continuation. If this is your first time reading this documentation, we recommend you start with the getting started guide.","category":"page"},{"location":"#Contents-1","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"#","page":"Introduction","title":"Introduction","text":"Pages = [\n    \"solving.md\",\n    \"solver.md\",\n    \"monodromy.md\",\n    \"input.md\",\n    \"path_tracker.md\",\n    \"core_tracker.md\",\n    \"homotopies.md\",\n    \"systems.md\",\n    \"reference.md\",\n]","category":"page"}]
}
